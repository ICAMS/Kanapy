

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Applications &mdash; kanapy 6.5.3.post1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=53ab5b41"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Usage" href="usage.html" />
    <link rel="prev" title="Overview" href="readme.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            kanapy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="readme.html">Overview</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Applications</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#geometry-module">Geometry module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#microstructure-with-equiaxed-grains">Microstructure with equiaxed grains</a></li>
<li class="toctree-l3"><a class="reference internal" href="#microstructure-with-elongated-grains">Microstructure with elongated grains</a></li>
<li class="toctree-l3"><a class="reference internal" href="#simulation-benchmarks">Simulation benchmarks</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#texture-module">Texture module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#odf-reconstruction">ODF reconstruction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#odf-reconstruction-with-orientation-assignment">ODF reconstruction with orientation assignment</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="method.html">Modeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="kanapy.html">Code documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="history.html">History</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">kanapy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Applications</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/applications.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="applications">
<h1>Applications<a class="headerlink" href="#applications" title="Link to this heading"></a></h1>
<section id="geometry-module">
<h2>Geometry module<a class="headerlink" href="#geometry-module" title="Link to this heading"></a></h2>
<section id="microstructure-with-equiaxed-grains">
<h3>Microstructure with equiaxed grains<a class="headerlink" href="#microstructure-with-equiaxed-grains" title="Link to this heading"></a></h3>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Voronoi_diagram">Voronoi</a> and <a class="reference external" href="https://en.wikipedia.org/wiki/Power_diagram">Laguerre</a> tessellations are some of the popular methods for generating polycrystalline microstructures. These approaches require positions and weights as input parameters for generating tessellation cells that resemble grains of a polycrystal. In this regard, the proposed particle packing approach can be used to generate the required information. Microstructures with equiaxed grains are best approximated by spheres, and after obtaining the necessary packing fraction, positions and radii can be outputted.</p>
<figure class="align-center" id="id1">
<img alt="_images/sphere_app.png" src="_images/sphere_app.png" />
<figcaption>
<p><span class="caption-text"><strong>Figure</strong>: An example of sphere packing (left), radical Voronoi tesselation (center) and FE tetrahedral mesh (right).</span><a class="headerlink" href="#id1" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>In this example, to obtain a high packing fraction, the box size is set as the volume sum of all the spheres. This definition of the box size will inevitably result in an overlap of spheres at the final stages of the simulation. This is because the packing fraction of <span class="math notranslate nohighlight">\(100\%\)</span> is unachievable without the occurrence of overlaps. A reasonable amount of overlap is accepted, as the input data obtained from microstructure characterization techniques (like EBSD) are also approximations. Hence, for further post-processing, it is suggested to choose the time step at which the spheres are tightly packed and at which there is the least amount of overlap. The remaining empty spaces will get assigned to the closest sphere when it is sent to the tessellation and meshing routine. Complete freedom in selecting the desired time step of the simulation to be sent for further processing is one of the highlights of this approach.</p>
<p>Using the information obtained from sphere packing, radical Voronoi tessellation can be performed by Neper. And FE discretization of the tessellation cells by tetrahedral elements can also be done within Neper - <a class="reference external" href="https://doi.org/10.1016/j.cma.2011.01.002">Quey (2011)</a> with assistance from the FE mesh generating software Gmsh - <a class="reference external" href="https://doi.org/10.1002/nme.2579">Geuzaine (2009)</a>.</p>
</section>
<section id="microstructure-with-elongated-grains">
<h3>Microstructure with elongated grains<a class="headerlink" href="#microstructure-with-elongated-grains" title="Link to this heading"></a></h3>
<p>Microstructures generated through conventional manufacturing processes like rolling and state-of-the-art processes like additive manufacturing (AM) consist of both elongated and equiaxed grains. In the context of AM, this is due to the complex solidification process, which occurs as a result of constant re-heating and re-cooling of previously melted layers during the manufacturing. The morphology of the grains along with the texture plays an important role in the resulting mechanical behavior. Hence, modeling such complex microstructures is vital, and in this regard the proposed approach of random ellipsoid packing is used.</p>
<figure class="align-center" id="id2">
<img alt="_images/ellipsoid_app.png" src="_images/ellipsoid_app.png" />
<figcaption>
<p><span class="caption-text"><strong>Figure</strong>: An example of ellipsoidal packing (left), Voxelization - FE hexahedral mesh (right).</span><a class="headerlink" href="#id2" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The ellipsoid packing process is similar to that of sphere packing as described earlier. Once the ellipsoids are tightly packed with minimal acceptable overlaps, they are processed further for meshing. Since Voronoi tessellations cannot be applied to anisotropic particles such as ellipsoids, a voxel-based mesh-generating routine that utilizes convex hull for discretizing the RVE is employed. The voxelization (meshing) routine is made of 2 stages. The number of voxels in the RVE has a direct influence on the FE solution and the FE simulation time and must hence be meticulously chosen. The choice is not arbitrary, as it is constrained by how well the grains of the RVE are represented with respect to their geometry and the FEM simulation time.</p>
</section>
<section id="simulation-benchmarks">
<h3>Simulation benchmarks<a class="headerlink" href="#simulation-benchmarks" title="Link to this heading"></a></h3>
<p>To estimate the performance of Kanapy with respect to its particle packing and voxelization routines, multiple realizations of both sphere and ellipsoid packing was performed on a 2.60 GHz Intel Xeon CPU. Figure 1 depicts graphically the average CPU time recorded over 10 simulation runs for each realization of particle packing. The data is tabulated in Table 1. A significant difference in the variation of CPU time can be observed between spheres and ellipsoids of the same number. The difference arises from the fact that, two layered collision detection is sufficient to estimate if spheres collide. But ellipsoid collision detection requires an additional computational step of solving the characteristic equation as described in <a class="reference internal" href="method.html#overlap-detection"><span class="std std-ref">Overlap detection</span></a>.</p>
<figure class="align-center" id="id3">
<img alt="_images/CPUtime_analysis_packing.png" src="_images/CPUtime_analysis_packing.png" />
<figcaption>
<p><span class="caption-text"><strong>Figure 1</strong>: Log-log plot depicting the performance of the particle packing routine in terms of average CPU time (in seconds) recorded for different realizations of packing of spheres and ellipsoids.</span><a class="headerlink" href="#id3" title="Link to this image"></a></p>
</figcaption>
</figure>
<table class="docutils align-default" id="id4">
<caption><span class="caption-text"><strong>Table 1</strong>: Particle packing simulation tests for spheres and ellipsoids. The CPU time is averaged over 10 simulation runs.</span><a class="headerlink" href="#id4" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 33.3%" />
<col style="width: 33.3%" />
<col style="width: 33.3%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Number of</p></th>
<th class="head"><p>CPU time (s)</p></th>
<th class="head"></th>
</tr>
<tr class="row-even"><th class="head"><p>particles</p></th>
<th class="head"><p>Sphere</p></th>
<th class="head"><p>Ellipsoids</p></th>
</tr>
</thead>
<tbody>
<tr class="row-odd"><td><p>50</p></td>
<td><p>50.63</p></td>
<td><p>72.29</p></td>
</tr>
<tr class="row-even"><td><p>100</p></td>
<td><p>91.15</p></td>
<td><p>163.88</p></td>
</tr>
<tr class="row-odd"><td><p>500</p></td>
<td><p>362.32</p></td>
<td><p>618.73</p></td>
</tr>
<tr class="row-even"><td><p>1000</p></td>
<td><p>704.13</p></td>
<td><p>1174.94</p></td>
</tr>
<tr class="row-odd"><td><p>5000</p></td>
<td><p>3119.56</p></td>
<td><p>4635.41</p></td>
</tr>
</tbody>
</table>
<p>Figure 2 depicts the CPU time recorded for the kanapy’s voxelization routine. The CPU time is estimated for various combinations of number of grains and number of voxels. These results are tabulated in Table 2.</p>
<figure class="align-center" id="id5">
<img alt="_images/CPUtime_analysis_voxelization.png" src="_images/CPUtime_analysis_voxelization.png" />
<figcaption>
<p><span class="caption-text"><strong>Figure 2</strong>: Plot depicting the performance of the voxelization routine in terms of CPU time (in seconds) for various combinations of grain numbers and total voxel numbers.</span><a class="headerlink" href="#id5" title="Link to this image"></a></p>
</figcaption>
</figure>
<table class="docutils align-default" id="id6">
<caption><span class="caption-text"><strong>Table 2</strong>: Voxelization routine performance data for various combinations of grain numbers and total voxel numbers.</span><a class="headerlink" href="#id6" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 33.3%" />
<col style="width: 22.2%" />
<col style="width: 22.2%" />
<col style="width: 22.2%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Number of voxels</p></th>
<th class="head"></th>
<th class="head"><p>CPU time (s)</p></th>
<th class="head"></th>
</tr>
<tr class="row-even"><th class="head"></th>
<th class="head"><p>100 grains</p></th>
<th class="head"><p>500 grains</p></th>
<th class="head"><p>1000 grains</p></th>
</tr>
</thead>
<tbody>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(20^3\)</span> = 8000</p></td>
<td><p>7.09</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(30^3\)</span> = 27,000</p></td>
<td><p>11.33</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(40^3\)</span> = 64,000</p></td>
<td><p>18.9</p></td>
<td><p>53.63</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(50^3\)</span> = 125,000</p></td>
<td><p>28.26</p></td>
<td><p>78.33</p></td>
<td><p>122.19</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(60^3\)</span> = 216,000</p></td>
<td><p>44.79</p></td>
<td><p>123.36</p></td>
<td><p>186.54</p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(70^3\)</span> = 343,000</p></td>
<td><p>68.65</p></td>
<td><p>186.49</p></td>
<td><p>282.17</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(80^3\)</span> = 512,000</p></td>
<td></td>
<td><p>257.95</p></td>
<td><p>378.13</p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(90^3\)</span> = 729,000</p></td>
<td></td>
<td><p>389.48</p></td>
<td><p>528.95</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(100^3\)</span> = 1,000,000</p></td>
<td></td>
<td></td>
<td><p>683.30</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="texture-module">
<h2>Texture module<a class="headerlink" href="#texture-module" title="Link to this heading"></a></h2>
<p>The ODF reconstruction and the orientation assignment algorithms are both implemented as MATLAB functions within Kanapy. Both these algorithms utilizes several MTEX <a class="reference external" href="https://www.tib.eu/en/search/id/TIBKAT%3A623768526/">Bachmann (2010)</a> functions, and are called within Kanapy by python. The ODF reconstruction algorithm can be used independently (if the required inputs are provided), whereas the orientation assignment algorithm only works if the ODF reconstruction is performed and the RVE is generated by Kanapy’s geometry module. The ODF reconstruction MATLAB function can also be used as a standalone program outside of Kanapy’s framework, but it still requires MTEX installation. Please refer to the comments in the MATLAB scripts for their independent usage. Various possible input configurations are discussed below, which have been exemplified using the Titanium EBSD data available within MTEX.</p>
<p>Since both these algorithms are implemented as MATLAB functions that calls other MTEX functions, the MATLAB and MTEX installation paths are required for Kanapy’s texture module. Make sure to set up the texture module within kanapy by running the command:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>conda<span class="w"> </span>activate<span class="w"> </span>knpy
<span class="gp gp-VirtualEnv">(knpy)</span> <span class="gp">$ </span>kanapy<span class="w"> </span>setuptexture
</pre></div>
</div>
<section id="odf-reconstruction">
<h3>ODF reconstruction<a class="headerlink" href="#odf-reconstruction" title="Link to this heading"></a></h3>
<p>To use the ODF reconstruction algorithm, the EBSD data estimated using MTEX must be given as input in the form of (.mat) file. By providing the number of discrete orientations (<span class="math notranslate nohighlight">\(N^\prime\)</span>) required, the algorithm can be used in the minimum possible configuration. Note here the value of <span class="math notranslate nohighlight">\(\kappa\)</span> is set to a default value of <span class="math notranslate nohighlight">\(0.0873\)</span> rad. Figure 3 depicts the pole figure (plotted using MTEX) estimated from the experiment EBSD data file provided and Figure 4 depicts the pole figure for 30 discrete orientations obtained as output with the default <span class="math notranslate nohighlight">\(\kappa\)</span> value.</p>
<figure class="align-center" id="id7">
<img alt="_images/odf.png" src="_images/odf.png" />
<figcaption>
<p><span class="caption-text"><strong>Figure 3</strong>: Plot depicting the pole figure obtained from EBSD data analysis.</span><a class="headerlink" href="#id7" title="Link to this image"></a></p>
</figcaption>
</figure>
<figure class="align-center" id="id8">
<img alt="_images/odfred30_defKernel.png" src="_images/odfred30_defKernel.png" />
<figcaption>
<p><span class="caption-text"><strong>Figure 4</strong>: Plot depicting the pole figure obtained from 30 discrete orientation with default <span class="math notranslate nohighlight">\(\kappa\)</span> value of <span class="math notranslate nohighlight">\(0.0873\)</span> rad.</span><a class="headerlink" href="#id8" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Alternately, the initial <span class="math notranslate nohighlight">\(\kappa\)</span> value can be specified (in radians) or the grains estimated using MTEX can be provided as an input in the (.mat) file format. If the grains (.mat) file is provided, then the optimum <span class="math notranslate nohighlight">\(\kappa\)</span> is estimated using the mean orientation of the grains (by an MTEX function). Figure 5 shows the pole figure (plotted using MTEX) estimated from EBSD data analysis and Figure 6 shows the pole figure for 30 discrete orientations obtained as output with <span class="math notranslate nohighlight">\(\kappa\)</span> value estimated using grain mean orientation.</p>
<figure class="align-center" id="id9">
<img alt="_images/odf.png" src="_images/odf.png" />
<figcaption>
<p><span class="caption-text"><strong>Figure 5</strong>: Plot depicting the pole figure of ODF data obtained from EBSD data analysis.</span><a class="headerlink" href="#id9" title="Link to this image"></a></p>
</figcaption>
</figure>
<figure class="align-center" id="id10">
<img alt="_images/odfred30_optKernel.png" src="_images/odfred30_optKernel.png" />
<figcaption>
<p><span class="caption-text"><strong>Figure 6</strong>: Plot depicting the pole figure of reconstructed ODF of 30 discrete orientation with <span class="math notranslate nohighlight">\(\kappa\)</span> value estimated using grain mean orientations.</span><a class="headerlink" href="#id10" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The output from the ODF reconstruction algorithm is written to a (.txt) file, which consists of the <span class="math notranslate nohighlight">\(L_1\)</span> error of ODF reconstruction, the initial (<span class="math notranslate nohighlight">\(\kappa\)</span>) and the optimized (<span class="math notranslate nohighlight">\(\kappa^\prime\)</span>) values, and a list of the discrete orientations.</p>
</section>
<section id="odf-reconstruction-with-orientation-assignment">
<h3>ODF reconstruction with orientation assignment<a class="headerlink" href="#odf-reconstruction-with-orientation-assignment" title="Link to this heading"></a></h3>
<p>In addition to the ODF reconstruction, kanapy’s texture module can also be used to determine the optimal assignment of orientations to the grains. The orientation assignment algorithm can be used in this regard. The EBSD and the grain (.mat) files, along with the grain boundary shared surface area information are the required mandatory inputs. The grain boundary shared surface area is the output that is available after generating the RVE using kanapy’s geometry module. As explained earlier the surface area is used as weights for estimating the disorientation angle distribution.</p>
<p>An optional input that can be provided is the grain volume information, which is used for weighting the orientations after assignment and for estimating the ODF represented by the RVE. Figure 7 shows the ODF reconstructed using 40 discrete orientations weighted as per the grain volume (obtained from kanapy’s geometry module) and Figure 8 shows the comparison of the disorientation angle distribution between the EBSD data and the RVE (after orientation assignment).</p>
<figure class="align-center" id="id11">
<img alt="_images/odfred40_odfcor.png" src="_images/odfred40_odfcor.png" />
<figcaption>
<p><span class="caption-text"><strong>Figure 7</strong>: Pole figure of the ODF estimated after reconstruction with 40 discrete orientation weighted as per the grain volume and assigned using the orientation assignment algorithm.</span><a class="headerlink" href="#id11" title="Link to this image"></a></p>
</figcaption>
</figure>
<figure class="align-center" id="id12">
<img alt="_images/disorientation_fitting.png" src="_images/disorientation_fitting.png" />
<figcaption>
<p><span class="caption-text"><strong>Figure 8</strong>: Bar plot depicting the comparison of the disorientation angle distribution between the EBSD data and the generated RVE.</span><a class="headerlink" href="#id12" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The output of the orientation assignment algorithm is also written to a (.txt) file. It contains the <span class="math notranslate nohighlight">\(L_1\)</span> error due to ODF reconstruction, the <span class="math notranslate nohighlight">\(L_1\)</span> error between disorientation angle distributions from the EBSD data and the RVE, the initial (<span class="math notranslate nohighlight">\(\kappa\)</span>) and the optimized (<span class="math notranslate nohighlight">\(\kappa^\prime\)</span>) values, and a list of the discrete orientations each with a specific grain number that it should be assigned to.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="readme.html" class="btn btn-neutral float-left" title="Overview" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="usage.html" class="btn btn-neutral float-right" title="Usage" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright This work is published under a CC BY-SA 4.0 license.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>