

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>kanapy.core.api &mdash; kanapy 6.5.3.post1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=53ab5b41"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            kanapy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../applications.html">Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../method.html">Modeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kanapy.html">Code documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../history.html">History</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">kanapy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">kanapy.core.api</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for kanapy.core.api</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; Module defining class Microstructure that contains the necessary</span>
<span class="sd">methods and attributes to analyze experimental microstructures in form</span>
<span class="sd">of EBSD maps to generate statistical descriptors for 3D microstructures, and </span>
<span class="sd">to create synthetic RVE that fulfill the required statistical microstructure</span>
<span class="sd">descriptors.</span>

<span class="sd">The methods of the class Microstructure for an API that can be used to generate</span>
<span class="sd">Python workflows.</span>

<span class="sd">Authors: Alexander Hartmaier, Golsa Tolooei Eshlghi, Abhishek Biswas</span>
<span class="sd">Institution: ICAMS, Ruhr University Bochum</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">platform</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">hashlib</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">Delaunay</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">importlib.metadata</span><span class="w"> </span><span class="kn">import</span> <span class="n">version</span> <span class="k">as</span> <span class="n">pkg_version</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.grains</span><span class="w"> </span><span class="kn">import</span> <span class="n">calc_polygons</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.entities</span><span class="w"> </span><span class="kn">import</span> <span class="n">Simulation_Box</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.input_output</span><span class="w"> </span><span class="kn">import</span> <span class="n">export2abaqus</span><span class="p">,</span> <span class="n">writeAbaqusMat</span><span class="p">,</span> <span class="n">read_dump</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.initializations</span><span class="w"> </span><span class="kn">import</span> <span class="n">RVE_creator</span><span class="p">,</span> <span class="n">mesh_creator</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.packing</span><span class="w"> </span><span class="kn">import</span> <span class="n">packingRoutine</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.voxelization</span><span class="w"> </span><span class="kn">import</span> <span class="n">voxelizationRoutine</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.smoothingGB</span><span class="w"> </span><span class="kn">import</span> <span class="n">smoothingRoutine</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.rve_stats</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_stats_vox</span><span class="p">,</span> <span class="n">get_stats_part</span><span class="p">,</span> <span class="n">get_stats_poly</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.plotting</span><span class="w"> </span><span class="kn">import</span> <span class="n">plot_init_stats</span><span class="p">,</span> <span class="n">plot_voxels_3D</span><span class="p">,</span> <span class="n">plot_ellipsoids_3D</span><span class="p">,</span> \
    <span class="n">plot_polygons_3D</span><span class="p">,</span> <span class="n">plot_output_stats</span><span class="p">,</span> <span class="n">plot_particles_3D</span>


<div class="viewcode-block" id="Microstructure">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.api.Microstructure">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Microstructure</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define a class for creating and managing synthetic microstructures</span>

<span class="sd">    This class provides tools to define, generate, and analyze synthetic</span>
<span class="sd">    microstructures composed of one or multiple phases. It integrates particle</span>
<span class="sd">    packing, voxelization, and grain geometry generation for RVE (Representative</span>
<span class="sd">    Volume Element) modeling.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    descriptor : list of dict, optional</span>
<span class="sd">        List of dictionaries describing the microstructure of each phase.</span>
<span class="sd">        Dictionary keys typically include &quot;Grains type&quot;, &quot;Equivalent diameter&quot;,</span>
<span class="sd">        &quot;Aspect ratio&quot;, &quot;Tilt Angle&quot;, &quot;RVE&quot;, and &quot;Simulation&quot;.</span>
<span class="sd">    file : str, optional</span>
<span class="sd">        Path to a JSON or other input file to initialize the microstructure.</span>
<span class="sd">    name : str, default=&#39;Microstructure&#39;</span>
<span class="sd">        Name of the microstructure</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        Name of the microstructure</span>
<span class="sd">    nphases : int or None</span>
<span class="sd">        Number of phases in the microstructure</span>
<span class="sd">    ngrains : ndarray or None</span>
<span class="sd">        Array of grain counts in each phase</span>
<span class="sd">    nparticles : list or None</span>
<span class="sd">        List of the number of particles in each phase</span>
<span class="sd">    descriptor : list of dict or None</span>
<span class="sd">        Descriptor used to define microstructure if provided</span>
<span class="sd">    precipit : float or None</span>
<span class="sd">        Indicates the presence of precipitates, pores, or secondary particles</span>
<span class="sd">        in a continuous matrix. If float, specifies their volume fraction</span>
<span class="sd">    from_voxels : bool</span>
<span class="sd">        True if the microstructure is imported from a voxel file</span>
<span class="sd">    particles : list or None</span>
<span class="sd">        List of particle objects containing geometric information</span>
<span class="sd">    rve : RVE_creator or None</span>
<span class="sd">        Object containing RVE information including mesh dimensions,</span>
<span class="sd">        particle count, periodicity, and phase volume fractions</span>
<span class="sd">    simbox : Simulation_Box or None</span>
<span class="sd">        Object defining the geometric boundaries of the RVE simulation domain</span>
<span class="sd">    mesh : mesh_creator or None</span>
<span class="sd">        Object storing voxelized mesh data including grain assignments,</span>
<span class="sd">        voxel connectivity, and smoothed node coordinates</span>
<span class="sd">    geometry : dict or None</span>
<span class="sd">        Dictionary of grain geometries. Keys may include &quot;Vertices&quot;, &quot;Points&quot;,</span>
<span class="sd">        &quot;Simplices&quot;, &quot;Facets&quot;, &quot;Grains&quot;, &quot;GBnodes&quot;, &quot;GBarea&quot;, &quot;GBfaces&quot;</span>
<span class="sd">    rve_stats : list of dict or None</span>
<span class="sd">        Statistical information for different RVE representations,</span>
<span class="sd">        including particles, voxels, and polyhedral grains</span>
<span class="sd">    rve_stats_labels : list of str or None</span>
<span class="sd">        Labels corresponding to the types of RVEs analyzed, e.g., &quot;Particles&quot;,</span>
<span class="sd">        &quot;Voxels&quot;, &quot;Grains&quot;</span>
<span class="sd">    vf_vox : ndarray or None</span>
<span class="sd">        Phase volume fractions obtained from voxelized structures</span>
<span class="sd">    ialloy : int or None</span>
<span class="sd">        Alloy identifier used for material library mapping</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The class can initialize from either a statistical descriptor or a JSON data file</span>
<span class="sd">    - When only one phase is specified with a volume fraction &lt; 1.0,</span>
<span class="sd">      a matrix phase is automatically added with a complementary fraction (1 - vf)</span>
<span class="sd">    - Kanapy is tested for up to two phases; using more may yield unpredictable results</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">descriptor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Microstructure&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nphases</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ngrains</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nparticles</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">precipit</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rve</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">particles</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simbox</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rve_stats</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rve_stats_labels</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_voxels</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ialloy</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vf_vox</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">descriptor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Please provide either a dictionary with statistics or an data file name&#39;</span><span class="p">)</span>

            <span class="c1"># Open the user data statistics file and read the data</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">file</span><span class="p">))</span> <span class="k">as</span> <span class="n">json_file</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">json_file</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;An unexpected exception occurred: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="s2">&quot;File: &#39;</span><span class="si">{}</span><span class="s2">&#39; does not exist in the current working directory!</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">descriptor</span> <span class="o">==</span> <span class="s1">&#39;from_voxels&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">from_voxels</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">descriptor</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="p">[</span><span class="n">descriptor</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nphases</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">descriptor</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nphases</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nphases</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Kanapy is only tested for 2 phases, use at own risk for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nphases</span><span class="si">}</span><span class="s1"> phases&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s1">&#39;WARNING: Input parameter (descriptor) and file are given. Only descriptor will be used.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nphases</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="s1">&#39;Phase&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">vf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Phase&#39;</span><span class="p">][</span><span class="s1">&#39;Volume fraction&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">vf</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">:</span>
                <span class="c1"># consider precipitates/pores/particles with volume fraction fill_factor in a matrix</span>
                <span class="c1"># precipitates will be phase 0, matrix phase will get number 1 and be assigned to grain with ID 0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">precipit</span> <span class="o">=</span> <span class="n">vf</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nphases</span> <span class="o">=</span> <span class="mi">2</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Only one phase with volume fraction </span><span class="si">{</span><span class="n">vf</span><span class="si">}</span><span class="s1"> is given.&#39;</span><span class="p">)</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Will consider a sparse distribution in a matrix phase with phase number 1, &#39;</span> <span class="o">+</span>
                             <span class="s1">&#39;which will be assigned to grain with ID 0.&#39;</span><span class="p">)</span>
        <span class="k">return</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    --------        Routines for user interface        --------</span>
<span class="sd">    &quot;&quot;&quot;</span>


<div class="viewcode-block" id="Microstructure.init_RVE">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.api.Microstructure.init_RVE">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">init_RVE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">descriptor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsteps</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the Representative Volume Element (RVE) of the microstructure</span>

<span class="sd">        This method creates the voxel- or particle-based RVE using the provided</span>
<span class="sd">        phase descriptor(s). It sets up the mesh dimensions, particle distribution,</span>
<span class="sd">        and simulation box geometry. The RVE object is constructed using the</span>
<span class="sd">        `RVE_creator` class, and key attributes such as `nparticles` and `simbox`</span>
<span class="sd">        are updated accordingly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        descriptor : list of dict, dict, or None, optional</span>
<span class="sd">            Description of the microstructure phases. Each dictionary specifies</span>
<span class="sd">            parameters such as grain type, equivalent diameter, aspect ratio,</span>
<span class="sd">            and tilt angle. If `None`, the class attribute `self.descriptor` is used.</span>
<span class="sd">        nsteps : int, optional</span>
<span class="sd">            Number of optimization or relaxation steps for RVE generation.</span>
<span class="sd">            Default is 1000.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Assumes that `RVE_creator` and `Simulation_Box` are available and correctly configured.</span>
<span class="sd">        - If `self.precipit` is defined, an additional &#39;Matrix&#39; phase is automatically</span>
<span class="sd">          added to preserve total volume fraction normalization.</span>

<span class="sd">        Attributes Updated</span>
<span class="sd">        ------------------</span>
<span class="sd">        rve : RVE_creator</span>
<span class="sd">            The created RVE object containing voxel/particle information, size,</span>
<span class="sd">            periodicity, and phase volume fractions.</span>
<span class="sd">        nparticles : list</span>
<span class="sd">            Number of particles per phase after RVE generation.</span>
<span class="sd">        simbox : Simulation_Box</span>
<span class="sd">            Object containing the geometric boundaries of the RVE domain.</span>
<span class="sd">        precipit : float or None</span>
<span class="sd">            If not None, a &#39;Matrix&#39; phase is appended to `rve.phase_names` and its</span>
<span class="sd">            volume fraction is adjusted as (1.0 - precipit).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            Updates class attributes with the initialized RVE and simulation box.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">descriptor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">descriptor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">descriptor</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">descriptor</span> <span class="o">=</span> <span class="p">[</span><span class="n">descriptor</span><span class="p">]</span>

        <span class="c1"># initialize RVE, including mesh dimensions and particle distribution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rve</span> <span class="o">=</span> <span class="n">RVE_creator</span><span class="p">(</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">nsteps</span><span class="o">=</span><span class="n">nsteps</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">precipit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">phase_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Matrix&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">phase_vf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">precipit</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nparticles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">nparticles</span>
        <span class="c1"># store geometry in simbox object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simbox</span> <span class="o">=</span> <span class="n">Simulation_Box</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="Microstructure.pack">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.api.Microstructure.pack">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">pack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">particle_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">k_rep</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">k_att</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">fill_factor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">poly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_files</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pack particles into the simulation box according to the RVE settings.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        particle_data : array-like or None, optional</span>
<span class="sd">            Particle information. If None, uses self.rve.particle_data.</span>
<span class="sd">        k_rep : float, optional</span>
<span class="sd">            Repulsion coefficient between particles. Default is 0.0.</span>
<span class="sd">        k_att : float, optional</span>
<span class="sd">            Attraction coefficient between particles. Default is 0.0.</span>
<span class="sd">        fill_factor : float or None, optional</span>
<span class="sd">            Fraction of simulation box to fill. Defaults to 1.0 if self.precipit is set.</span>
<span class="sd">        poly : optional</span>
<span class="sd">            Additional packing options for polyhedral particles.</span>
<span class="sd">        save_files : bool, optional</span>
<span class="sd">            If True, saves packed particle data to files.</span>
<span class="sd">        verbose : bool, optional</span>
<span class="sd">            If True, prints progress and warnings during packing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        particles : list</span>
<span class="sd">            List of packed particle objects with positions and geometrical information.</span>
<span class="sd">        simbox : Simulation_Box</span>
<span class="sd">            Updated simulation box reflecting particle packing.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If no particle data is available.</span>
<span class="sd">        AttributeError</span>
<span class="sd">            If RVE or simulation box is not initialized before packing.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If self.precipit &gt; 0.65, particle overlaps may occur.</span>
<span class="sd">        Requires self.rve and self.simbox to be initialized before calling.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">particle_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">particle_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">particle_data</span>
            <span class="k">if</span> <span class="n">particle_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No particle_data in pack. Run create_RVE first.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fill_factor</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">precipit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fill_factor</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># pack to full volume fraction defined in particles</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Sparse particles (precipitates/pores): &#39;</span>
                  <span class="sa">f</span><span class="s1">&#39;Packing up to particle volume fraction of </span><span class="si">{</span><span class="p">(</span><span class="mi">100</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">precipit</span><span class="p">)</span><span class="si">:</span><span class="s1">.1f</span><span class="si">}</span><span class="s1">%.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">precipit</span> <span class="o">&gt;</span> <span class="mf">0.65</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Overlap of particles will occur since volume fraction &gt; 65%&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">particles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">simbox</span> <span class="o">=</span> \
            <span class="n">packingRoutine</span><span class="p">(</span><span class="n">particle_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">periodic</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">packing_steps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">simbox</span><span class="p">,</span>
                           <span class="n">k_rep</span><span class="o">=</span><span class="n">k_rep</span><span class="p">,</span> <span class="n">k_att</span><span class="o">=</span><span class="n">k_att</span><span class="p">,</span> <span class="n">fill_factor</span><span class="o">=</span><span class="n">fill_factor</span><span class="p">,</span>
                           <span class="n">poly</span><span class="o">=</span><span class="n">poly</span><span class="p">,</span> <span class="n">save_files</span><span class="o">=</span><span class="n">save_files</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span></div>


<div class="viewcode-block" id="Microstructure.voxelize">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.api.Microstructure.voxelize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">voxelize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">particles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate the RVE by assigning voxels to grains.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        particles : list or None, optional</span>
<span class="sd">            List of particle objects to voxelize. If None, uses `self.particles`.</span>
<span class="sd">        dim : tuple of int, optional</span>
<span class="sd">            3-tuple specifying the number of voxels in each spatial direction.</span>
<span class="sd">            If None, uses `self.rve.dim`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            The voxelized mesh is stored in `self.mesh`. Phase voxel fractions are</span>
<span class="sd">            stored in `self.vf_vox` and printed to the console.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            - If `particles` is None and `self.particles` is not available.</span>
<span class="sd">            - If `dim` is not a 3-tuple when specified.</span>
<span class="sd">        AttributeError</span>
<span class="sd">            If `self.rve` or `self.simbox` is not initialized before voxelization.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Requires `self.particles` to be initialized by `pack()`.</span>
<span class="sd">        - Updates `self.mesh`, `self.ngrains`, `self.Ngr`, and `self.vf_vox`.</span>
<span class="sd">        - Logs warnings if phase volume fractions do not sum to 1.</span>
<span class="sd">        - Removes polyhedral grain geometries (`self.geometry`) after re-meshing to avoid inconsistencies.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">particles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">particles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particles</span>
            <span class="k">if</span> <span class="n">particles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No particles in voxelize. Run pack first.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">dim</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">tuple</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;&quot;dim&quot; must be a 3-tuple of the voxel numbers in each direction, not </span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="n">dim</span>

        <span class="c1"># initialize voxel structure (= mesh)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh_creator</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nphases</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nphases</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">create_voxels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">simbox</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> \
            <span class="n">voxelizationRoutine</span><span class="p">(</span><span class="n">particles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nphases</span><span class="p">,</span> <span class="n">prec_vf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">precipit</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nparticles</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">ngrains_phase</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Number of grains per phase changed from </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nparticles</span><span class="si">}</span><span class="s1"> to &#39;</span> <span class="o">+</span>
                         <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">ngrains_phase</span><span class="p">)</span><span class="si">}</span><span class="s1"> during voxelization.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ngrains</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">ngrains_phase</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ngr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">ngrains_phase</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># extract volume fractions from voxelized grains</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nphases</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vf_vox</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nphases</span><span class="p">)</span>
            <span class="n">vox_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nphases</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">igr</span><span class="p">,</span> <span class="n">ip</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grain_phase_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">vox_count</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="p">[</span><span class="n">igr</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Volume fractions of phases in voxel structure:&#39;</span><span class="p">)</span>
            <span class="n">vt</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nphases</span><span class="p">):</span>
                <span class="n">vf_act</span> <span class="o">=</span> <span class="n">vox_count</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nvox</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vf_vox</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span> <span class="o">=</span> <span class="n">vf_act</span>
                <span class="n">vt</span> <span class="o">+=</span> <span class="n">vf_act</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">ip</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">phase_names</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span><span class="si">}</span><span class="s1"> (</span><span class="si">{</span><span class="p">(</span><span class="n">vf_act</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">%)&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">vt</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">):</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Volume fractions of phases in voxels do not add up to 1. Value: </span><span class="si">{</span><span class="n">vt</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vf_vox</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># remove grain information if it already exists to avoid inconsistencies</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Removing polyhedral grain geometries and statistical data after re-meshing.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Microstructure.smoothen">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.api.Microstructure.smoothen">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">smoothen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes_v</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">voxel_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">grain_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate smoothed grain boundaries from a voxelated mesh.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes_v : array-like or None, optional</span>
<span class="sd">            Mesh node coordinates. If None, uses `self.mesh.nodes`.</span>
<span class="sd">        voxel_dict : dict or None, optional</span>
<span class="sd">            Dictionary of voxels in the mesh. If None, uses `self.mesh.voxel_dict`.</span>
<span class="sd">        grain_dict : dict or None, optional</span>
<span class="sd">            Dictionary mapping grains to their voxels. If None, uses `self.mesh.grain_dict`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            The smoothed nodes are stored in `self.mesh.nodes_smooth`. Grain boundary</span>
<span class="sd">            faces are optionally stored in `self.geometry[&#39;GBfaces&#39;]`.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `nodes_v` is None and `self.mesh.nodes` is not available.</span>
<span class="sd">        AttributeError</span>
<span class="sd">            If `self.mesh` is not initialized before calling `smoothen()`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Requires `self.mesh` to be initialized by `voxelize()`.</span>
<span class="sd">        - Updates `self.mesh.nodes_smooth` with smoothed node coordinates.</span>
<span class="sd">        - Adds &#39;GBfaces&#39; entry to `self.geometry` if it exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nodes_v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nodes_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span>
            <span class="k">if</span> <span class="n">nodes_v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No nodes_v in smoothen. Run voxelize first.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">voxel_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">voxel_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">voxel_dict</span>
        <span class="k">if</span> <span class="n">grain_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">grain_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes_smooth</span><span class="p">,</span> <span class="n">grain_facesDict</span> <span class="o">=</span> \
            <span class="n">smoothingRoutine</span><span class="p">(</span><span class="n">nodes_v</span><span class="p">,</span> <span class="n">voxel_dict</span><span class="p">,</span> <span class="n">grain_dict</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="s1">&#39;GBfaces&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">grain_facesDict</span></div>


<div class="viewcode-block" id="Microstructure.generate_grains">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.api.Microstructure.generate_grains">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">generate_grains</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate and store polyhedral grain geometry, including particle- and grain-diameter attributes,</span>
<span class="sd">        for statistical comparison</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Requires `self.mesh` to be initialized by `voxelize`.</span>
<span class="sd">        - Updates `self.geometry` with polyhedral grain volumes and shared grain boundary (GB) areas.</span>
<span class="sd">        - If `self.precipit` is True, irregular grain 0 is temporarily removed from analysis.</span>
<span class="sd">        - Logs warnings if grains are not represented in the polyhedral geometry.</span>
<span class="sd">        - Prints volume fractions of each phase in the polyhedral geometry.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            The calculated grain geometry is stored in `self.geometry`. Phase volume fractions</span>
<span class="sd">            are printed to the console.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            - If `self.mesh` or `self.mesh.grains` is None (i.e., voxelized microstructure not available).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grains</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No information about voxelized microstructure. Run voxelize first.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">precipit</span> <span class="ow">and</span> <span class="mi">0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># in case of precipit, remove irregular grain 0 from analysis</span>
            <span class="n">empty_vox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">grain_store</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grain_phase_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">empty_vox</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">grain_store</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> \
            <span class="n">calc_polygons</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>  <span class="c1"># updates RVE_data</span>
        <span class="c1"># verify that geometry[&#39;Grains&#39;] and mesh.grain_dict are consistent</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;if np.any(self.geometry[&#39;Ngrains&#39;] != self.ngrains):</span>
<span class="sd">            logging.warning(f&#39;Only facets for {self.geometry[&quot;Ngrains&quot;]} created, but {self.Ngr} grains in voxels.&#39;)</span>
<span class="sd">            for igr in self.mesh.grain_dict.keys():</span>
<span class="sd">                if igr not in self.geometry[&#39;Grains&#39;].keys():</span>
<span class="sd">                    logging.warning(f&#39;Grain: {igr} not in geometry. Be aware when creating GB textures.&#39;)&quot;&quot;&quot;</span>
        <span class="c1"># verify that geometry[&#39;GBarea&#39;] is consistent with geometry[&#39;Grains&#39;]</span>
        <span class="n">gba</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="s1">&#39;GBarea&#39;</span><span class="p">]</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">igr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">gblist</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gba</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">gblist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="s1">&#39;Grains&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">ind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">igr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gblist</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">gblist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="s1">&#39;Grains&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">ind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">igr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gblist</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span><span class="si">}</span><span class="s1"> grains are not represented in polyhedral geometry.&#39;</span><span class="p">)</span>
            <span class="c1"># logging.warning(&#39;Consider increasing the number of voxels, as grains appear to be very irregular.&#39;)</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;ind.reverse()</span>
<span class="sd">            igr.reverse()</span>
<span class="sd">            for j, i in enumerate(ind):</span>
<span class="sd">                logging.warning(f&#39;Removing {gba[i]} from GBarea as grain {igr[j]} does not exist.&#39;)</span>
<span class="sd">                gba.pop(i)</span>
<span class="sd">            self.geometry[&#39;GBarea&#39;] = gba&quot;&quot;&quot;</span>
        <span class="c1"># extract volume fractions from polyhedral grains</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nphases</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ph_vol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nphases</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">igr</span><span class="p">,</span> <span class="n">grd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="s1">&#39;Grains&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">ip</span> <span class="o">=</span> <span class="n">grd</span><span class="p">[</span><span class="s1">&#39;Phase&#39;</span><span class="p">]</span>
                <span class="n">ph_vol</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span> <span class="o">+=</span> <span class="n">grd</span><span class="p">[</span><span class="s1">&#39;Volume&#39;</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Volume fractions of phases in polyhedral geometry:&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nphases</span><span class="p">):</span>
                <span class="n">vf</span> <span class="o">=</span> <span class="mf">100.0</span> <span class="o">*</span> <span class="n">ph_vol</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">ip</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">phase_names</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span><span class="si">}</span><span class="s1"> (</span><span class="si">{</span><span class="n">vf</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="s1">%)&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">empty_vox</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># add removed grain again</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">empty_vox</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grain_phase_dict</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">grain_store</span></div>


<div class="viewcode-block" id="Microstructure.generate_orientations">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.api.Microstructure.generate_orientations">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">generate_orientations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">ang</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">omega</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Nbase</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>
                              <span class="n">hist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shared_area</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">iphase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate orientations for grains in a representative volume element (RVE)</span>
<span class="sd">        to achieve a desired crystallographic texture</span>

<span class="sd">        This method assigns grain orientations to achieve a specified texture. The</span>
<span class="sd">        input can be an EBSDmap object or a string defining the type of orientation set</span>
<span class="sd">        (random or unimodal). For unimodal textures, `ang` and `omega` must be specified.</span>
<span class="sd">        Generated orientations are stored in `self.mesh.grain_ori_dict`, and</span>
<span class="sd">        `self.mesh.texture` is updated accordingly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : EBSDmap or str</span>
<span class="sd">            Input source for orientations. Can be an `EBSDmap` object or a string</span>
<span class="sd">            specifying the type of orientation set:</span>
<span class="sd">            - &#39;random&#39; or &#39;rnd&#39; : generate a random orientation set</span>
<span class="sd">            - &#39;unimodal&#39;, &#39;uni_mod&#39;, or &#39;uni_modal&#39; : generate a unimodal orientation set</span>
<span class="sd">        ang : float, optional</span>
<span class="sd">            Orientation angle for unimodal texture (required if `data` is unimodal).</span>
<span class="sd">        omega : float, optional</span>
<span class="sd">            Kernel halfwidth for unimodal texture (required if `data` is unimodal).</span>
<span class="sd">        Nbase : int, default=5000</span>
<span class="sd">            Number of base orientations used in random or unimodal generation.</span>
<span class="sd">        hist : array_like, optional</span>
<span class="sd">            Histogram for the grain orientations, used to weight orientations.</span>
<span class="sd">        shared_area : array_like or float, optional</span>
<span class="sd">            Shared grain boundary area for weighted orientation generation.</span>
<span class="sd">        iphase : int, optional</span>
<span class="sd">            Phase index for which orientations are generated. If None, all phases are processed.</span>
<span class="sd">        verbose : bool, default=False</span>
<span class="sd">            If True, prints additional information during orientation generation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            The generated orientations are stored in `self.mesh.grain_ori_dict` and</span>
<span class="sd">            `self.mesh.texture` is updated to reflect the type of generated texture.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            - If grain geometry is not defined (i.e., `self.mesh.grains` is None).</span>
<span class="sd">            - If `data` is unimodal but `ang` or `omega` are not provided.</span>
<span class="sd">            - If `data` is neither `EBSDmap` nor a recognized string option.</span>
<span class="sd">            - If histogram is provided but GB areas are not defined (and `shared_area` is None).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Generate random orientations for all grains</span>
<span class="sd">        &gt;&gt;&gt; rve.generate_orientations(&#39;random&#39;)</span>

<span class="sd">        &gt;&gt;&gt; # Generate unimodal orientations with specified angle and halfwidth</span>
<span class="sd">        &gt;&gt;&gt; rve.generate_orientations(&#39;unimodal&#39;, ang=30.0, omega=10.0)</span>

<span class="sd">        &gt;&gt;&gt; # Generate orientations for a specific phase with histogram weighting</span>
<span class="sd">        &gt;&gt;&gt; rve.generate_orientations(&#39;random&#39;, hist=hist_array, iphase=1)</span>

<span class="sd">        &gt;&gt;&gt; # Generate orientations using an EBSDmap object</span>
<span class="sd">        &gt;&gt;&gt; rve.generate_orientations(ebsd_map_obj)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">kanapy</span><span class="w"> </span><span class="kn">import</span> <span class="n">__backend__</span>
        <span class="k">if</span> <span class="n">__backend__</span> <span class="o">==</span> <span class="s1">&#39;mtex&#39;</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">kanapy_mtex.texture</span><span class="w"> </span><span class="kn">import</span> <span class="n">EBSDmap</span><span class="p">,</span> <span class="n">createOrisetRandom</span><span class="p">,</span> <span class="n">createOriset</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Using MTEX library to read EBSD maps and generate orientations.&#39;</span><span class="p">)</span>
            <span class="n">MTEX</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">kanapy.texture</span><span class="w"> </span><span class="kn">import</span> <span class="n">EBSDmap</span><span class="p">,</span> <span class="n">createOrisetRandom</span><span class="p">,</span> <span class="n">createOriset</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Using ORIX library to read EBSD maps and generate orientations.&#39;</span><span class="p">)</span>
            <span class="n">MTEX</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grains</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Grain geometry is not defined. Run voxelize first.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">shared_area</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">hist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">gba</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;If histogram for GB texture is provided, GB areas must be defined.</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span>
                                     <span class="s1">&#39;Run generate_grains() first, to calculate GB areas.&#39;</span><span class="p">)</span>
                <span class="n">gba</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="s1">&#39;GBarea&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">shared_area</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">gba</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gba</span> <span class="o">=</span> <span class="n">shared_area</span>

        <span class="n">ori_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ip</span><span class="p">,</span> <span class="n">ngr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ngrains</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">EBSDmap</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">iphase</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">iphase</span> <span class="o">==</span> <span class="n">ip</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">gba</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">MTEX</span><span class="p">:</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Shared are is currently only available in kanapy-mtex.</span><span class="se">\n</span><span class="s1">&#39;</span>
                                        <span class="s1">&#39;This option will be ignored.&#39;</span><span class="p">)</span>
                        <span class="n">gba</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">ori_rve</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">calcORI</span><span class="p">(</span><span class="n">ngr</span><span class="p">,</span> <span class="n">iphase</span><span class="o">=</span><span class="n">ip</span><span class="p">,</span> <span class="n">shared_area</span><span class="o">=</span><span class="n">gba</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">texture</span> <span class="o">=</span> <span class="s2">&quot;ODF&quot;</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;random&#39;</span><span class="p">,</span> <span class="s1">&#39;rnd&#39;</span><span class="p">]:</span>
                    <span class="n">ori_rve</span> <span class="o">=</span> <span class="n">createOrisetRandom</span><span class="p">(</span><span class="n">ngr</span><span class="p">,</span> <span class="n">Nbase</span><span class="o">=</span><span class="n">Nbase</span><span class="p">,</span> <span class="n">hist</span><span class="o">=</span><span class="n">hist</span><span class="p">,</span> <span class="n">shared_area</span><span class="o">=</span><span class="n">gba</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">texture</span> <span class="o">=</span> <span class="s2">&quot;Random&quot;</span>
                <span class="k">elif</span> <span class="n">data</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;unimodal&#39;</span><span class="p">,</span> <span class="s1">&#39;uni_mod&#39;</span><span class="p">,</span> <span class="s1">&#39;uni_modal&#39;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">ang</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">omega</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;To generate orientation sets of type &quot;unimodal&quot; angle &quot;ang&quot; and kernel&#39;</span> <span class="o">+</span>
                                         <span class="s1">&#39;halfwidth &quot;omega&quot; are required.&#39;</span><span class="p">)</span>
                    <span class="n">ori_rve</span> <span class="o">=</span> <span class="n">createOriset</span><span class="p">(</span><span class="n">ngr</span><span class="p">,</span> <span class="n">ang</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">hist</span><span class="o">=</span><span class="n">hist</span><span class="p">,</span> <span class="n">shared_area</span><span class="o">=</span><span class="n">gba</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">texture</span> <span class="o">=</span> <span class="s2">&quot;Unimodal&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">texture</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Argument to generate grain orientation must be either of type EBSDmap or &#39;</span> <span class="o">+</span>
                                 <span class="s1">&#39;&quot;random&quot; or &quot;unimodal&quot;&#39;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">igr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grain_phase_dict</span><span class="p">[</span><span class="n">igr</span><span class="p">]</span> <span class="o">==</span> <span class="n">ip</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">iphase</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">iphase</span> <span class="o">==</span> <span class="n">ip</span><span class="p">:</span>
                        <span class="n">ind</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">ip</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ngrains</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">ori_dict</span><span class="p">[</span><span class="n">igr</span><span class="p">]</span> <span class="o">=</span> <span class="n">ori_rve</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grain_ori_dict</span> <span class="o">=</span> <span class="n">ori_dict</span>
        <span class="k">return</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    --------     Plotting methods          --------</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Microstructure.plot_ellipsoids">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.api.Microstructure.plot_ellipsoids">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_ellipsoids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;prism&#39;</span><span class="p">,</span> <span class="n">dual_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">phases</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a 3D plot of particles in the RVE</span>

<span class="sd">        This function visualizes ellipsoidal particles in the Representative Volume Element (RVE).</span>
<span class="sd">        Particles can be colored according to phase, and a custom colormap can be used.</span>
<span class="sd">        Note that `dual_phase` is deprecated; use `phases` instead.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cmap : str, optional</span>
<span class="sd">            Colormap used for plotting particles. Default is &#39;prism&#39;.</span>
<span class="sd">        dual_phase : bool or None, optional</span>
<span class="sd">            Deprecated parameter for indicating dual-phase visualization.</span>
<span class="sd">            Use `phases` instead. Default is None.</span>
<span class="sd">        phases : bool, optional</span>
<span class="sd">            If True, color particles according to their phase. Default is False.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Requires `self.particles` to be initialized by `pack`.</span>
<span class="sd">        - Automatically calculates aspect ratios of the RVE for proper 3D plotting.</span>
<span class="sd">        - Prints a warning if `dual_phase` is used and maps it to `phases`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            Displays a 3D plot of ellipsoidal particles using `plot_ellipsoids_3D`.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            - If `self.particles` is None.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Simple 3D plot with default colormap</span>
<span class="sd">        &gt;&gt;&gt; rve.plot_ellipsoids()</span>

<span class="sd">        &gt;&gt;&gt; # Color particles according to phase</span>
<span class="sd">        &gt;&gt;&gt; rve.plot_ellipsoids(phases=True)</span>

<span class="sd">        &gt;&gt;&gt; # Use a custom colormap</span>
<span class="sd">        &gt;&gt;&gt; rve.plot_ellipsoids(cmap=&#39;viridis&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dual_phase</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Use of &quot;dual_phase&quot; is depracted. Use parameter &quot;phases&quot; instead.&#39;</span><span class="p">)</span>
            <span class="n">phases</span> <span class="o">=</span> <span class="n">dual_phase</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">particles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No particle to plot. Run pack first.&#39;</span><span class="p">)</span>
        <span class="n">hmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">asp_arr</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">hmin</span><span class="p">),</span>
                   <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">hmin</span><span class="p">),</span>
                   <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">hmin</span><span class="p">)]</span>
        <span class="n">plot_ellipsoids_3D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">particles</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">phases</span><span class="o">=</span><span class="n">phases</span><span class="p">,</span> <span class="n">asp_arr</span><span class="o">=</span><span class="n">asp_arr</span><span class="p">)</span></div>


<div class="viewcode-block" id="Microstructure.plot_particles">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.api.Microstructure.plot_particles">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_particles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;prism&#39;</span><span class="p">,</span> <span class="n">dual_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">phases</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_hull</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a 3D plot of particles in the RVE.</span>

<span class="sd">        This function visualizes particles in the Representative Volume Element (RVE) in 3D.</span>
<span class="sd">        Particles can be colored according to phase, plotted with their convex hulls, and</span>
<span class="sd">        displayed using a custom colormap.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cmap : str, optional</span>
<span class="sd">            Colormap used for plotting particles. Default is &#39;prism&#39;.</span>
<span class="sd">        dual_phase : bool or None, optional</span>
<span class="sd">            Deprecated parameter for indicating dual-phase visualization.</span>
<span class="sd">            Use `phases` instead. Default is None.</span>
<span class="sd">        phases : bool, optional</span>
<span class="sd">            If True, color particles according to their phase. Default is False.</span>
<span class="sd">        plot_hull : bool, optional</span>
<span class="sd">            If True, plot the convex hull (inner polygon) of each particle. Default is True.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Requires `self.particles` to be initialized by `pack`.</span>
<span class="sd">        - Automatically calculates aspect ratios of the RVE for proper 3D plotting.</span>
<span class="sd">        - Prints a warning if `dual_phase` is used and maps it to `phases`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            Displays a 3D plot of particles using `plot_particles_3D`.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            - If `self.particles` is None.</span>
<span class="sd">            - If particles do not have inner polygons.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Simple 3D plot with default colormap and convex hulls</span>
<span class="sd">        &gt;&gt;&gt; rve.plot_particles()</span>

<span class="sd">        &gt;&gt;&gt; # Color particles according to phase</span>
<span class="sd">        &gt;&gt;&gt; rve.plot_particles(phases=True)</span>

<span class="sd">        &gt;&gt;&gt; # Plot particles without convex hulls and use a custom colormap</span>
<span class="sd">        &gt;&gt;&gt; rve.plot_particles(cmap=&#39;viridis&#39;, plot_hull=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dual_phase</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Use of &quot;dual_phase&quot; is depracted. Use parameter &quot;phases&quot; instead.&#39;</span><span class="p">)</span>
            <span class="n">phases</span> <span class="o">=</span> <span class="n">dual_phase</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">particles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No particle to plot. Run pack first.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">inner</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Ellipsoids without inner polygon cannot be plotted.&#39;</span><span class="p">)</span>
        <span class="n">hmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">asp_arr</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">hmin</span><span class="p">),</span>
                   <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">hmin</span><span class="p">),</span>
                   <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">hmin</span><span class="p">)]</span>
        <span class="n">plot_particles_3D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">particles</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
                          <span class="n">phases</span><span class="o">=</span><span class="n">phases</span><span class="p">,</span> <span class="n">plot_hull</span><span class="o">=</span><span class="n">plot_hull</span><span class="p">,</span> <span class="n">asp_arr</span><span class="o">=</span><span class="n">asp_arr</span><span class="p">)</span></div>


<div class="viewcode-block" id="Microstructure.plot_voxels">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.api.Microstructure.plot_voxels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_voxels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sliced</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dual_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">phases</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;prism&#39;</span><span class="p">,</span> <span class="n">ori</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">color_key</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a 3D visualization of the voxelized RVE structure</span>

<span class="sd">        This function visualizes the voxel-based microstructure of the RVE. It supports</span>
<span class="sd">        coloring by phase, grain ID, or crystallographic orientation, and can optionally</span>
<span class="sd">        render a sliced view of the 3D voxel mesh.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sliced : bool, optional</span>
<span class="sd">            If True, generates a sliced view of the voxel mesh to visualize the internal structure.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        dual_phase : bool or None, optional</span>
<span class="sd">            Deprecated parameter for dual-phase visualization. Use `phases` instead.</span>
<span class="sd">            Default is None.</span>
<span class="sd">        phases : bool, optional</span>
<span class="sd">            If True, color voxels by phase instead of grain ID. Default is False.</span>
<span class="sd">        cmap : str, optional</span>
<span class="sd">            Name of the matplotlib colormap used for rendering. Default is &#39;prism&#39;.</span>
<span class="sd">        ori : array-like, bool, or None, optional</span>
<span class="sd">            Array of grain orientations, or True to use `self.mesh.grain_ori_dict` for coloring</span>
<span class="sd">            via inverse pole figure (IPF) mapping. Default is None.</span>
<span class="sd">        color_key : int, optional</span>
<span class="sd">            Selects the color mapping for orientations:</span>
<span class="sd">            - 0: iphHSVKey</span>
<span class="sd">            - 1: BungeColorKey</span>
<span class="sd">            - 2: ipfHKLKey</span>
<span class="sd">            Default is 0.</span>
<span class="sd">        silent : bool, optional</span>
<span class="sd">            If True, suppresses figure display and returns the matplotlib figure object instead.</span>
<span class="sd">            Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : matplotlib.figure.Figure or None</span>
<span class="sd">            Returns the figure object if `silent=True`. Otherwise, displays the 3D plot and returns None.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `self.mesh.grains` is None, indicating that voxelization has not been performed.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Requires that the voxel mesh (`self.mesh`) has been generated by `voxelize()`.</span>
<span class="sd">        - If `ori` is provided, orientation-based coloring is applied using `get_ipf_colors()`.</span>
<span class="sd">        - Prints a warning if `dual_phase` is used, since it is deprecated and replaced by `phases`.</span>
<span class="sd">        - Automatically computes aspect ratios of the RVE to ensure accurate 3D visualization.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Simple 3D plot of voxelized RVE</span>
<span class="sd">        &gt;&gt;&gt; rve.plot_voxels()</span>

<span class="sd">        &gt;&gt;&gt; # Plot a sliced view of the voxel mesh</span>
<span class="sd">        &gt;&gt;&gt; rve.plot_voxels(sliced=True)</span>

<span class="sd">        &gt;&gt;&gt; # Color voxels by phase and use a custom colormap</span>
<span class="sd">        &gt;&gt;&gt; rve.plot_voxels(phases=True, cmap=&#39;viridis&#39;)</span>

<span class="sd">        &gt;&gt;&gt; # Use orientation-based coloring via IPF mapping</span>
<span class="sd">        &gt;&gt;&gt; rve.plot_voxels(ori=True, color_key=2)</span>

<span class="sd">        &gt;&gt;&gt; # Suppress figure display and get the matplotlib Figure object</span>
<span class="sd">        &gt;&gt;&gt; fig = rve.plot_voxels(silent=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dual_phase</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Use of &quot;dual_phase&quot; is depracted. Use parameter &quot;phases&quot; instead.&#39;</span><span class="p">)</span>
            <span class="n">phases</span> <span class="o">=</span> <span class="n">dual_phase</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grains</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No voxels or elements to plot. Run voxelize first.&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">phases</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">phases</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grains</span>
        <span class="k">if</span> <span class="n">ori</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span><span class="w">  </span><span class="nn">kanapy</span><span class="w"> </span><span class="kn">import</span> <span class="n">__backend__</span>
            <span class="k">if</span> <span class="n">__backend__</span> <span class="o">==</span> <span class="s2">&quot;mtex&quot;</span><span class="p">:</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">kanapy_mtex.texture</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_ipf_colors</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">kanapy.texture</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_ipf_colors</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ori</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ori</span><span class="p">:</span>
                <span class="n">ori</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">val</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grain_ori_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
            <span class="n">clist</span> <span class="o">=</span> <span class="n">get_ipf_colors</span><span class="p">(</span><span class="n">ori</span><span class="p">,</span> <span class="n">color_key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clist</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">hmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">asp_arr</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">hmin</span><span class="p">),</span>
                   <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">hmin</span><span class="p">),</span>
                   <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">hmin</span><span class="p">)]</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plot_voxels_3D</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sliced</span><span class="o">=</span><span class="n">sliced</span><span class="p">,</span>
                             <span class="n">phases</span><span class="o">=</span><span class="n">phases</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">clist</span><span class="o">=</span><span class="n">clist</span><span class="p">,</span>
                             <span class="n">silent</span><span class="o">=</span><span class="n">silent</span><span class="p">,</span> <span class="n">asp_arr</span><span class="o">=</span><span class="n">asp_arr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">silent</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fig</span></div>


<div class="viewcode-block" id="Microstructure.plot_grains">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.api.Microstructure.plot_grains">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_grains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;prism&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span>
                    <span class="n">ec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dual_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">phases</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the polygonalized microstructure of the RVE in 3D.</span>

<span class="sd">        This function visualizes the polygonal (polyhedral) grain geometry of the</span>
<span class="sd">        microstructure, typically after `generate_grains()` has been executed.</span>
<span class="sd">        Users can customize the colormap, transparency, and edge color. It also</span>
<span class="sd">        supports coloring grains by phase.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        geometry : dict or None, optional</span>
<span class="sd">            Dictionary containing the polygonal grain geometries. If None, uses</span>
<span class="sd">            `self.geometry`.</span>
<span class="sd">        cmap : str, optional</span>
<span class="sd">            Matplotlib colormap name for rendering grain colors. Default is &#39;prism&#39;.</span>
<span class="sd">        alpha : float, optional</span>
<span class="sd">            Transparency level of the grain surfaces (0 = fully transparent,</span>
<span class="sd">            1 = fully opaque). Default is 0.4.</span>
<span class="sd">        ec : list or None, optional</span>
<span class="sd">            Edge color specified as an RGBA list, e.g. `[0.5, 0.5, 0.5, 0.1]`.</span>
<span class="sd">            Default is `[0.5, 0.5, 0.5, 0.1]`.</span>
<span class="sd">        dual_phase : bool or None, optional</span>
<span class="sd">            Deprecated parameter for dual-phase coloring. Use `phases` instead.</span>
<span class="sd">            Default is None.</span>
<span class="sd">        phases : bool, optional</span>
<span class="sd">            If True, color grains by phase rather than by grain ID. Default is False.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Requires polygonal grain data generated by `generate_grains()`.</span>
<span class="sd">        - Automatically computes the aspect ratio of the RVE for correct 3D scaling.</span>
<span class="sd">        - Visualization is handled by `plot_polygons_3D()`.</span>
<span class="sd">        - The parameter `dual_phase` is deprecated; prefer using `phases` instead.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            Displays a 3D plot of polygonal grains.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If no polygonal geometry is available (i.e., `self.geometry` is None).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Simple 3D plot of polygonal grains with default settings</span>
<span class="sd">        &gt;&gt;&gt; rve.plot_grains()</span>

<span class="sd">        &gt;&gt;&gt; # Color grains by phase</span>
<span class="sd">        &gt;&gt;&gt; rve.plot_grains(phases=True)</span>

<span class="sd">        &gt;&gt;&gt; # Use a custom colormap and set transparency</span>
<span class="sd">        &gt;&gt;&gt; rve.plot_grains(cmap=&#39;viridis&#39;, alpha=0.6)</span>

<span class="sd">        &gt;&gt;&gt; # Specify edge color</span>
<span class="sd">        &gt;&gt;&gt; rve.plot_grains(ec=[0.2, 0.2, 0.2, 0.3])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ec</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">dual_phase</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Use of &quot;dual_phase&quot; is depracted. Use parameter &quot;phases&quot; instead.&#39;</span><span class="p">)</span>
            <span class="n">phases</span> <span class="o">=</span> <span class="n">dual_phase</span>
        <span class="k">if</span> <span class="n">geometry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">geometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span>
        <span class="k">if</span> <span class="n">geometry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No polygons for grains defined. Run generate_grains() first&#39;</span><span class="p">)</span>
        <span class="n">hmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">asp_arr</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">hmin</span><span class="p">),</span>
                   <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">hmin</span><span class="p">),</span>
                   <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">hmin</span><span class="p">)]</span>
        <span class="n">plot_polygons_3D</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">ec</span><span class="o">=</span><span class="n">ec</span><span class="p">,</span>
                         <span class="n">phases</span><span class="o">=</span><span class="n">phases</span><span class="p">,</span> <span class="n">asp_arr</span><span class="o">=</span><span class="n">asp_arr</span><span class="p">)</span></div>


<div class="viewcode-block" id="Microstructure.plot_stats">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.api.Microstructure.plot_stats">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">gs_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gs_param</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">ar_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ar_param</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">dual_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">phases</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">save_files</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">show_all</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">silent</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">enhanced_plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot particle, voxel, and grain diameter statistics for comparison</span>

<span class="sd">        This method analyzes the microstructure at different representation levels</span>
<span class="sd">        (particles, voxels, and polyhedral grains) and plots corresponding statistical</span>
<span class="sd">        distributions. It can optionally handle multiphase materials, save plots,</span>
<span class="sd">        and display detailed information about geometric parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : str or None, optional</span>
<span class="sd">            Specifies which type of data to analyze and plot:</span>
<span class="sd">            - &#39;p&#39; : particles</span>
<span class="sd">            - &#39;v&#39; : voxels</span>
<span class="sd">            - &#39;g&#39; : grains</span>
<span class="sd">            If None, all available data types are analyzed.</span>
<span class="sd">        gs_data : list or array-like, optional</span>
<span class="sd">            Grain size data for comparison with simulation results.</span>
<span class="sd">        gs_param : list or array-like, optional</span>
<span class="sd">            Parameters for fitting grain size distributions.</span>
<span class="sd">        ar_data : list or array-like, optional</span>
<span class="sd">            Aspect ratio data for comparison with simulation results.</span>
<span class="sd">        ar_param : list or array-like, optional</span>
<span class="sd">            Parameters for fitting aspect ratio distributions.</span>
<span class="sd">        dual_phase : bool or None, optional</span>
<span class="sd">            Deprecated. Use `phases` instead.</span>
<span class="sd">        phases : bool, optional</span>
<span class="sd">            If True, perform separate statistical analysis for each phase.</span>
<span class="sd">        save_files : bool, optional</span>
<span class="sd">            If True, save generated plots and statistical results to files.</span>
<span class="sd">        show_all : bool, optional</span>
<span class="sd">            If True, display all generated plots interactively.</span>
<span class="sd">        verbose : bool, optional</span>
<span class="sd">            If True, print detailed numerical results during analysis.</span>
<span class="sd">        silent : bool, optional</span>
<span class="sd">            If True, suppresses console output and returns figures directly.</span>
<span class="sd">        enhanced_plot : bool, optional</span>
<span class="sd">            If True, use enhanced plot styling (automatically enabled when `silent=True`).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        flist : list of matplotlib.figure.Figure or None</span>
<span class="sd">            List of generated figure objects if `silent=True`, otherwise None.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        None</span>
<span class="sd">            This function does not raise exceptions if data is missing. Instead, it logs an</span>
<span class="sd">            error message and returns immediately.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Computes and compares geometric parameters such as principal axis lengths</span>
<span class="sd">          (a, b, c), aspect ratios, rotation axes, and equivalent diameters.</span>
<span class="sd">        - Results are stored in `self.rve_stats` and labeled in `self.rve_stats_labels`.</span>
<span class="sd">        - For multiphase structures, statistics are calculated per phase.</span>
<span class="sd">        - `dual_phase` is deprecated; prefer using `phases`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Plot all statistics with default settings</span>
<span class="sd">        &gt;&gt;&gt; rve.plot_stats()</span>

<span class="sd">        &gt;&gt;&gt; # Plot only particle statistics and show all plots interactively</span>
<span class="sd">        &gt;&gt;&gt; rve.plot_stats(data=&#39;p&#39;, show_all=True)</span>

<span class="sd">        &gt;&gt;&gt; # Perform multiphase statistical analysis and save figures</span>
<span class="sd">        &gt;&gt;&gt; rve.plot_stats(phases=True, save_files=True)</span>

<span class="sd">        &gt;&gt;&gt; # Suppress console output and get figure objects</span>
<span class="sd">        &gt;&gt;&gt; figs = rve.plot_stats(silent=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dual_phase</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Use of &quot;dual_phase&quot; is depracted. Use parameter &quot;phases&quot; instead.&#39;</span><span class="p">)</span>
            <span class="n">phases</span> <span class="o">=</span> <span class="n">dual_phase</span>
        <span class="k">if</span> <span class="n">silent</span><span class="p">:</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">show_all</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">enhanced_plot</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">ax_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">phases</span><span class="p">:</span>
            <span class="n">nphases</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nphases</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">precipit</span> <span class="ow">and</span> <span class="mi">0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="c1"># in case of precipit, remove irregular grain 0 from analysis</span>
                <span class="n">nphases</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nphases</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">gs_data</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">gs_data</span><span class="p">)</span> <span class="o">==</span> <span class="n">nphases</span><span class="p">):</span>
            <span class="n">gs_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">gs_data</span><span class="p">]</span> <span class="o">*</span> <span class="n">nphases</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">gs_param</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">gs_param</span><span class="p">)</span> <span class="o">==</span> <span class="n">nphases</span><span class="p">):</span>
            <span class="n">gs_param</span> <span class="o">=</span> <span class="p">[</span><span class="n">gs_param</span><span class="p">]</span> <span class="o">*</span> <span class="n">nphases</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">ar_data</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">ar_data</span><span class="p">)</span> <span class="o">==</span> <span class="n">nphases</span><span class="p">):</span>
            <span class="n">ar_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">ar_data</span><span class="p">]</span> <span class="o">*</span> <span class="n">nphases</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">ar_param</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">ar_param</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">gs_param</span><span class="p">)):</span>
            <span class="n">ar_param</span> <span class="o">=</span> <span class="p">[</span><span class="n">ar_param</span><span class="p">]</span> <span class="o">*</span> <span class="n">nphases</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        gs_data = [ebsd.ms_data[i][&#39;gs_data&#39;] for i in range(nphases)]</span>
<span class="sd">        gs_param = [ebsd.ms_data[i][&#39;gs_param&#39;] for i in range(nphases)]</span>
<span class="sd">        ar_data = [ebsd.ms_data[i][&#39;ar_data&#39;] for i in range(nphases)]</span>
<span class="sd">        ar_param = [ebsd.ms_data[i][&#39;ar_param&#39;] for i in range(nphases)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">iphase</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">flist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nphases</span><span class="p">):</span>
            <span class="n">stats_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">phases</span><span class="p">:</span>
                <span class="n">iphase</span> <span class="o">=</span> <span class="n">ip</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Plotting statistical information for phase </span><span class="si">{</span><span class="n">ip</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="c1"># Analyze and plot particles statistics</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">particles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> \
                    <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span> <span class="ow">and</span> <span class="s1">&#39;p&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">lower</span><span class="p">()):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">particles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Particle statistics requested, but no particles defined. &#39;</span>
                                  <span class="s1">&#39;Run &quot;pack()&quot; first.&#39;</span><span class="p">)</span>
                    <span class="k">return</span>
                <span class="n">part_stats</span> <span class="o">=</span> <span class="n">get_stats_part</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">particles</span><span class="p">,</span> <span class="n">iphase</span><span class="o">=</span><span class="n">iphase</span><span class="p">,</span> <span class="n">ax_max</span><span class="o">=</span><span class="n">ax_max</span><span class="p">,</span>
                                            <span class="n">show_plot</span><span class="o">=</span><span class="n">show_all</span><span class="p">,</span>
                                            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">save_files</span><span class="o">=</span><span class="n">save_files</span><span class="p">)</span>
                <span class="n">stats_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">part_stats</span><span class="p">)</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Partcls&quot;</span><span class="p">)</span>

            <span class="c1"># Analyze and plot statistics of voxel structure in RVE</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> \
                    <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span> <span class="ow">and</span> <span class="s1">&#39;v&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">lower</span><span class="p">()):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Voxel statistics requested, but no voxel mesh defined. &#39;</span>
                                  <span class="s1">&#39;Run &quot;voxelize()&quot; first.&#39;</span><span class="p">)</span>
                    <span class="k">return</span>
                <span class="n">vox_stats</span> <span class="o">=</span> <span class="n">get_stats_vox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">iphase</span><span class="o">=</span><span class="n">iphase</span><span class="p">,</span> <span class="n">ax_max</span><span class="o">=</span><span class="n">ax_max</span><span class="p">,</span>
                                          <span class="n">show_plot</span><span class="o">=</span><span class="n">show_all</span><span class="p">,</span>
                                          <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">save_files</span><span class="o">=</span><span class="n">save_files</span><span class="p">)</span>
                <span class="n">stats_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vox_stats</span><span class="p">)</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Voxels&#39;</span><span class="p">)</span>

            <span class="c1"># Analyze and plot statistics of polyhedral grains in RVE</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> \
                    <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span> <span class="ow">and</span> <span class="s1">&#39;g&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">lower</span><span class="p">()):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Geometry statistics requested, but no polyhedral grains defined. &#39;</span>
                                  <span class="s1">&#39;Run &quot;generate_grains()&quot; first.&#39;</span><span class="p">)</span>
                    <span class="k">return</span>
                <span class="n">grain_stats</span> <span class="o">=</span> <span class="n">get_stats_poly</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="s1">&#39;Grains&#39;</span><span class="p">],</span> <span class="n">iphase</span><span class="o">=</span><span class="n">iphase</span><span class="p">,</span> <span class="n">ax_max</span><span class="o">=</span><span class="n">ax_max</span><span class="p">,</span>
                                             <span class="n">show_plot</span><span class="o">=</span><span class="n">show_all</span><span class="p">,</span> <span class="n">phase_dict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grain_phase_dict</span><span class="p">,</span>
                                             <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">save_files</span><span class="o">=</span><span class="n">save_files</span><span class="p">)</span>
                <span class="n">stats_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">grain_stats</span><span class="p">)</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Grains&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">phases</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Statistical microstructure parameters of phase </span><span class="si">{</span><span class="n">iphase</span><span class="si">}</span><span class="s1"> in RVE&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-------------------------------------------------------&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Statistical microstructure parameters of RVE&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;--------------------------------------------&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Type</span><span class="se">\t</span><span class="s1">| a (m) </span><span class="se">\t</span><span class="s1">| b (m) </span><span class="se">\t</span><span class="s1">| c (m) </span><span class="se">\t</span><span class="s1">| std.dev</span><span class="se">\t</span><span class="s1">| rot.axis</span><span class="se">\t</span><span class="s1">| asp.ratio</span><span class="se">\t</span><span class="s1">| std.dev</span><span class="se">\t</span><span class="s1">|&#39;</span>
                  <span class="sa">f</span><span class="s1">&#39; equ.dia. (m)</span><span class="se">\t</span><span class="s1">| std.dev&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sd</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stats_list</span><span class="p">):</span>
                <span class="n">av_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">sd</span><span class="p">[</span><span class="s1">&#39;a_sig&#39;</span><span class="p">],</span> <span class="n">sd</span><span class="p">[</span><span class="s1">&#39;b_sig&#39;</span><span class="p">],</span> <span class="n">sd</span><span class="p">[</span><span class="s1">&#39;c_sig&#39;</span><span class="p">]])</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="se">\t</span><span class="s1">|  </span><span class="si">{</span><span class="n">sd</span><span class="p">[</span><span class="s2">&quot;a_scale&quot;</span><span class="p">]</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="se">\t</span><span class="s1">|  </span><span class="si">{</span><span class="n">sd</span><span class="p">[</span><span class="s2">&quot;b_scale&quot;</span><span class="p">]</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="se">\t</span><span class="s1">|  </span><span class="si">{</span><span class="n">sd</span><span class="p">[</span><span class="s2">&quot;c_scale&quot;</span><span class="p">]</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="se">\t</span><span class="s1">|  &#39;</span>
                      <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">av_std</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="se">\t</span><span class="s1">|     </span><span class="si">{</span><span class="n">sd</span><span class="p">[</span><span class="s2">&quot;ind_rot&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">   </span><span class="se">\t</span><span class="s1">|  </span><span class="si">{</span><span class="n">sd</span><span class="p">[</span><span class="s2">&quot;ar_scale&quot;</span><span class="p">]</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="se">\t</span><span class="s1">|  </span><span class="si">{</span><span class="n">sd</span><span class="p">[</span><span class="s2">&quot;ar_sig&quot;</span><span class="p">]</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="se">\t</span><span class="s1">|     &#39;</span>
                      <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">sd</span><span class="p">[</span><span class="s2">&quot;eqd_scale&quot;</span><span class="p">]</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> </span><span class="se">\t</span><span class="s1">|  </span><span class="si">{</span><span class="n">sd</span><span class="p">[</span><span class="s2">&quot;eqd_sig&quot;</span><span class="p">]</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rve_stats</span> <span class="o">=</span> <span class="n">stats_list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rve_stats_labels</span> <span class="o">=</span> <span class="n">labels</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plot_output_stats</span><span class="p">(</span><span class="n">stats_list</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">iphase</span><span class="o">=</span><span class="n">iphase</span><span class="p">,</span>
                                    <span class="n">gs_data</span><span class="o">=</span><span class="n">gs_data</span><span class="p">[</span><span class="n">ip</span><span class="p">],</span> <span class="n">gs_param</span><span class="o">=</span><span class="n">gs_param</span><span class="p">[</span><span class="n">ip</span><span class="p">],</span>
                                    <span class="n">ar_data</span><span class="o">=</span><span class="n">ar_data</span><span class="p">[</span><span class="n">ip</span><span class="p">],</span> <span class="n">ar_param</span><span class="o">=</span><span class="n">ar_param</span><span class="p">[</span><span class="n">ip</span><span class="p">],</span>
                                    <span class="n">save_files</span><span class="o">=</span><span class="n">save_files</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="n">silent</span><span class="p">,</span>
                                    <span class="n">enhanced_plot</span><span class="o">=</span><span class="n">enhanced_plot</span><span class="p">)</span>
            <span class="n">flist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">silent</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">flist</span></div>


<div class="viewcode-block" id="Microstructure.plot_stats_init">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.api.Microstructure.plot_stats_init">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_stats_init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">descriptor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gs_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ar_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">porous</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">get_res</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">show_res</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">save_files</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_descriptors</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot initial statistical microstructure descriptors of RVE and optionally return computed descriptors</span>

<span class="sd">        This method analyzes the initial microstructure defined by input descriptors</span>
<span class="sd">        (or the class attribute `self.descriptor`) and plots the distributions of</span>
<span class="sd">        equivalent diameters and aspect ratios. For elongated grains, it prints a</span>
<span class="sd">        summary of input and output statistics. Optionally, statistical descriptors</span>
<span class="sd">        can be returned for further processing.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        descriptor : list of dict, dict, or None, optional</span>
<span class="sd">            Microstructure phase descriptor(s). If None, uses `self.descriptor`.</span>
<span class="sd">        gs_data : list or array-like, optional</span>
<span class="sd">            Grain size data for comparison with initial statistics.</span>
<span class="sd">        ar_data : list or array-like, optional</span>
<span class="sd">            Aspect ratio data for comparison with initial statistics.</span>
<span class="sd">        porous : bool, optional</span>
<span class="sd">            If True, only the first phase is considered (e.g., for porous structures).</span>
<span class="sd">        get_res : bool, optional</span>
<span class="sd">            If True, computes statistical descriptors from the voxelized structure.</span>
<span class="sd">        show_res : bool, optional</span>
<span class="sd">            If True, prints detailed statistical results to the console.</span>
<span class="sd">        save_files : bool, optional</span>
<span class="sd">            If True, saves generated plots to files.</span>
<span class="sd">        silent : bool, optional</span>
<span class="sd">            If True, suppresses console output and returns figures directly.</span>
<span class="sd">        return_descriptors : bool, optional</span>
<span class="sd">            If True, returns computed statistical descriptors along with figures.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        flist : list of matplotlib.figure.Figure</span>
<span class="sd">            List of generated figure objects.</span>
<span class="sd">        descs : list of dict</span>
<span class="sd">            Optional list of computed statistical descriptors if `return_descriptors=True`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Requires voxelized microstructure (`self.mesh`) for computing descriptors.</span>
<span class="sd">        - Computes statistics for equivalent diameter, aspect ratio, principal axes,</span>
<span class="sd">          and rotation axes when applicable.</span>
<span class="sd">        - Can handle multiphase or single-phase microstructures.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Plot initial statistics with default settings</span>
<span class="sd">        &gt;&gt;&gt; rve.plot_stats_init()</span>

<span class="sd">        &gt;&gt;&gt; # Plot only the first phase (porous) and save figures</span>
<span class="sd">        &gt;&gt;&gt; rve.plot_stats_init(porous=True, save_files=True)</span>

<span class="sd">        &gt;&gt;&gt; # Compute descriptors and get figures and descriptor objects</span>
<span class="sd">        &gt;&gt;&gt; figs, descs = rve.plot_stats_init(get_res=True, return_descriptors=True)</span>

<span class="sd">        &gt;&gt;&gt; # Suppress console output and return figure objects</span>
<span class="sd">        &gt;&gt;&gt; figs = rve.plot_stats_init(silent=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">analyze_voxels</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">des</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Compute voxel-based statistical descriptors for a given phase of the RVE</span>

<span class="sd">            This function calculates equivalent diameter, aspect ratio, principal axes, and rotation axis</span>
<span class="sd">            statistics from the voxelized microstructure. It prints input vs output statistics if the phase</span>
<span class="sd">            is elongated and returns formatted arrays for grain size, aspect ratio, and a dictionary of descriptors</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            ip : int</span>
<span class="sd">                Index of the phase to analyze</span>
<span class="sd">            des : dict</span>
<span class="sd">                Descriptor dictionary for the phase containing grain type and target statistics</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            gsp : list</span>
<span class="sd">                Summary of equivalent diameter statistics for plotting</span>
<span class="sd">            arp : list</span>
<span class="sd">                Summary of aspect ratio statistics for plotting</span>
<span class="sd">            statistical_descriptors : dict</span>
<span class="sd">                Detailed statistics including mean, std, min, max of eqd, ar, axes, and rotation axis</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;show_res is True, but no voxels have been defined. Run voxelize first.&#39;</span><span class="p">)</span>
            <span class="n">vox_stats</span> <span class="o">=</span> <span class="n">get_stats_vox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">iphase</span><span class="o">=</span><span class="n">ip</span><span class="p">,</span> <span class="n">show_plot</span><span class="o">=</span><span class="n">show_res</span><span class="p">)</span>
            <span class="n">gsp</span> <span class="o">=</span> <span class="p">[</span><span class="n">vox_stats</span><span class="p">[</span><span class="s1">&#39;eqd_sig&#39;</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">vox_stats</span><span class="p">[</span><span class="s1">&#39;eqd_scale&#39;</span><span class="p">],</span>
                   <span class="nb">min</span><span class="p">(</span><span class="n">vox_stats</span><span class="p">[</span><span class="s1">&#39;eqd&#39;</span><span class="p">]),</span> <span class="nb">max</span><span class="p">(</span><span class="n">vox_stats</span><span class="p">[</span><span class="s1">&#39;eqd&#39;</span><span class="p">])]</span>
            <span class="n">arp</span> <span class="o">=</span> <span class="p">[</span><span class="n">vox_stats</span><span class="p">[</span><span class="s1">&#39;ar_sig&#39;</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">vox_stats</span><span class="p">[</span><span class="s1">&#39;ar_scale&#39;</span><span class="p">],</span>
                   <span class="nb">min</span><span class="p">(</span><span class="n">vox_stats</span><span class="p">[</span><span class="s1">&#39;ar&#39;</span><span class="p">]),</span> <span class="nb">max</span><span class="p">(</span><span class="n">vox_stats</span><span class="p">[</span><span class="s1">&#39;ar&#39;</span><span class="p">])]</span>
            <span class="k">if</span> <span class="s1">&#39;Grain type&#39;</span> <span class="ow">in</span> <span class="n">des</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span> <span class="n">des</span><span class="p">[</span><span class="s1">&#39;Grain type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Elongated&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nel</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Statistical microstructure parameters of phase </span><span class="si">{</span><span class="n">ip</span><span class="si">}</span><span class="s1"> in RVE&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-------------------------------------------------------&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Statistical microstructure parameters of RVE&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;--------------------------------------------&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Type</span><span class="se">\t</span><span class="s1">| a (m) </span><span class="se">\t</span><span class="s1">| b (m) </span><span class="se">\t</span><span class="s1">| c (m) </span><span class="se">\t</span><span class="s1">| std.dev</span><span class="se">\t</span><span class="s1">| rot.axis</span><span class="se">\t</span><span class="s1">| asp.ratio</span><span class="se">\t</span><span class="s1">| std.dev</span><span class="se">\t</span><span class="s1">|&#39;</span>
                      <span class="sa">f</span><span class="s1">&#39; equ.dia. (m)</span><span class="se">\t</span><span class="s1">| std.dev&#39;</span><span class="p">)</span>

                <span class="n">av_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">vox_stats</span><span class="p">[</span><span class="s1">&#39;a_sig&#39;</span><span class="p">],</span> <span class="n">vox_stats</span><span class="p">[</span><span class="s1">&#39;b_sig&#39;</span><span class="p">],</span> <span class="n">vox_stats</span><span class="p">[</span><span class="s1">&#39;c_sig&#39;</span><span class="p">]])</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Input</span><span class="se">\t</span><span class="s1">|  -      </span><span class="se">\t</span><span class="s1">|  -      </span><span class="se">\t</span><span class="s1">|  -      </span><span class="se">\t</span><span class="s1">|   -      </span><span class="se">\t</span><span class="s1">|     -   </span><span class="se">\t</span><span class="s1">|  &#39;</span>
                      <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">des</span><span class="p">[</span><span class="s2">&quot;Aspect ratio&quot;</span><span class="p">][</span><span class="s2">&quot;scale&quot;</span><span class="p">]</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="se">\t</span><span class="s1">|  </span><span class="si">{</span><span class="n">des</span><span class="p">[</span><span class="s2">&quot;Aspect ratio&quot;</span><span class="p">][</span><span class="s2">&quot;sig&quot;</span><span class="p">]</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="se">\t</span><span class="s1">|     &#39;</span>
                      <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">des</span><span class="p">[</span><span class="s2">&quot;Equivalent diameter&quot;</span><span class="p">][</span><span class="s2">&quot;scale&quot;</span><span class="p">]</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> </span><span class="se">\t</span><span class="s1">|  </span><span class="si">{</span><span class="n">des</span><span class="p">[</span><span class="s2">&quot;Equivalent diameter&quot;</span><span class="p">][</span><span class="s2">&quot;sig&quot;</span><span class="p">]</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Output</span><span class="se">\t</span><span class="s1">|  </span><span class="si">{</span><span class="n">vox_stats</span><span class="p">[</span><span class="s2">&quot;a_scale&quot;</span><span class="p">]</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="se">\t</span><span class="s1">|  </span><span class="si">{</span><span class="n">vox_stats</span><span class="p">[</span><span class="s2">&quot;b_scale&quot;</span><span class="p">]</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="se">\t</span><span class="s1">|  &#39;</span>
                      <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">vox_stats</span><span class="p">[</span><span class="s2">&quot;c_scale&quot;</span><span class="p">]</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="se">\t</span><span class="s1">|  </span><span class="si">{</span><span class="n">av_std</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="se">\t</span><span class="s1">|     </span><span class="si">{</span><span class="n">vox_stats</span><span class="p">[</span><span class="s2">&quot;ind_rot&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">   </span><span class="se">\t</span><span class="s1">|  &#39;</span>
                      <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">vox_stats</span><span class="p">[</span><span class="s2">&quot;ar_scale&quot;</span><span class="p">]</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="se">\t</span><span class="s1">|  </span><span class="si">{</span><span class="n">vox_stats</span><span class="p">[</span><span class="s2">&quot;ar_sig&quot;</span><span class="p">]</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="se">\t</span><span class="s1">|     &#39;</span>
                      <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">vox_stats</span><span class="p">[</span><span class="s2">&quot;eqd_scale&quot;</span><span class="p">]</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> </span><span class="se">\t</span><span class="s1">|  </span><span class="si">{</span><span class="n">vox_stats</span><span class="p">[</span><span class="s2">&quot;eqd_sig&quot;</span><span class="p">]</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">statistical_descriptors</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;eqd&#39;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">vox_stats</span><span class="p">[</span><span class="s1">&#39;eqd_scale&#39;</span><span class="p">]),</span>
                        <span class="s1">&#39;std&#39;</span><span class="p">:</span>  <span class="nb">float</span><span class="p">(</span><span class="n">vox_stats</span><span class="p">[</span><span class="s1">&#39;eqd_sig&#39;</span><span class="p">]),</span>
                        <span class="s1">&#39;min&#39;</span><span class="p">:</span>  <span class="nb">float</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">vox_stats</span><span class="p">[</span><span class="s1">&#39;eqd&#39;</span><span class="p">])),</span>
                        <span class="s1">&#39;max&#39;</span><span class="p">:</span>  <span class="nb">float</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">vox_stats</span><span class="p">[</span><span class="s1">&#39;eqd&#39;</span><span class="p">])),</span>
                    <span class="p">},</span>
                    <span class="s1">&#39;ar&#39;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">vox_stats</span><span class="p">[</span><span class="s1">&#39;ar_scale&#39;</span><span class="p">]),</span>
                        <span class="s1">&#39;std&#39;</span><span class="p">:</span>  <span class="nb">float</span><span class="p">(</span><span class="n">vox_stats</span><span class="p">[</span><span class="s1">&#39;ar_sig&#39;</span><span class="p">]),</span>
                        <span class="s1">&#39;min&#39;</span><span class="p">:</span>  <span class="nb">float</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">vox_stats</span><span class="p">[</span><span class="s1">&#39;ar&#39;</span><span class="p">])),</span>
                        <span class="s1">&#39;max&#39;</span><span class="p">:</span>  <span class="nb">float</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">vox_stats</span><span class="p">[</span><span class="s1">&#39;ar&#39;</span><span class="p">])),</span>
                    <span class="p">},</span>
                    <span class="s1">&#39;axes&#39;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">vox_stats</span><span class="p">[</span><span class="s1">&#39;a_scale&#39;</span><span class="p">]),</span>
                        <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">vox_stats</span><span class="p">[</span><span class="s1">&#39;b_scale&#39;</span><span class="p">]),</span>
                        <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">vox_stats</span><span class="p">[</span><span class="s1">&#39;c_scale&#39;</span><span class="p">]),</span>
                        <span class="s1">&#39;a_std&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">vox_stats</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;a_sig&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)),</span>
                        <span class="s1">&#39;b_std&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">vox_stats</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;b_sig&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)),</span>
                        <span class="s1">&#39;c_std&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">vox_stats</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;c_sig&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)),</span>
                    <span class="p">},</span>
                    <span class="s1">&#39;rotation_axis&#39;</span><span class="p">:</span> <span class="n">vox_stats</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;ind_rot&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="p">}</span>
            <span class="k">return</span> <span class="n">gsp</span><span class="p">,</span> <span class="n">arp</span><span class="p">,</span> <span class="n">statistical_descriptors</span>

        <span class="k">if</span> <span class="n">show_res</span><span class="p">:</span> <span class="n">get_res</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">silent</span><span class="p">:</span> <span class="n">show_res</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">descriptor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">descriptor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">descriptor</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span> <span class="n">descriptor</span> <span class="o">=</span> <span class="p">[</span><span class="n">descriptor</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">porous</span><span class="p">:</span> <span class="n">descriptor</span> <span class="o">=</span> <span class="n">descriptor</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">nel</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">descriptor</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">gs_data</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">gs_data</span><span class="p">)</span> <span class="o">==</span> <span class="n">nel</span><span class="p">):</span> <span class="n">gs_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">gs_data</span><span class="p">]</span> <span class="o">*</span> <span class="n">nel</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">ar_data</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">ar_data</span><span class="p">)</span> <span class="o">==</span> <span class="n">nel</span><span class="p">):</span> <span class="n">ar_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">ar_data</span><span class="p">]</span> <span class="o">*</span> <span class="n">nel</span>

        <span class="n">flist</span><span class="p">,</span> <span class="n">descs</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">,</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ip</span><span class="p">,</span> <span class="n">des</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">descriptor</span><span class="p">):</span>
            <span class="n">gsp</span> <span class="o">=</span> <span class="n">arp</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">statistical_descriptors</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">get_res</span><span class="p">:</span>
                <span class="n">gsp</span><span class="p">,</span> <span class="n">arp</span><span class="p">,</span> <span class="n">statistical_descriptors</span> <span class="o">=</span> <span class="n">analyze_voxels</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">des</span><span class="p">)</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plot_init_stats</span><span class="p">(</span><span class="n">des</span><span class="p">,</span> <span class="n">gs_data</span><span class="o">=</span><span class="n">gs_data</span><span class="p">[</span><span class="n">ip</span><span class="p">],</span> <span class="n">ar_data</span><span class="o">=</span><span class="n">ar_data</span><span class="p">[</span><span class="n">ip</span><span class="p">],</span>
                                  <span class="n">gs_param</span><span class="o">=</span><span class="n">gsp</span><span class="p">,</span> <span class="n">ar_param</span><span class="o">=</span><span class="n">arp</span><span class="p">,</span>
                                  <span class="n">save_files</span><span class="o">=</span><span class="n">save_files</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="n">silent</span><span class="p">)</span>
            <span class="n">flist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">return_descriptors</span><span class="p">:</span>
                <span class="n">descs</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;phase&#39;</span><span class="p">:</span> <span class="n">ip</span><span class="p">,</span> <span class="o">**</span><span class="p">(</span><span class="n">statistical_descriptors</span> <span class="ow">or</span> <span class="p">{})})</span>

        <span class="k">if</span> <span class="n">return_descriptors</span> <span class="ow">or</span> <span class="n">silent</span><span class="p">:</span> <span class="k">return</span> <span class="n">flist</span><span class="p">,</span> <span class="n">descs</span></div>


<div class="viewcode-block" id="Microstructure.plot_slice">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.api.Microstructure.plot_slice">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cut</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">dual_phase</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">save_files</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot a 2D slice through the microstructure.</span>

<span class="sd">        The function visualizes a cross-section of the microstructure. If a polygonalized</span>
<span class="sd">        microstructure is available, it will be used as the plotting basis; otherwise,</span>
<span class="sd">        or if `data=&#39;voxels&#39;`, the voxelized microstructure will be plotted. This method</span>
<span class="sd">        internally calls `output_ang` with plotting enabled and file writing disabled.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cut : str, optional</span>
<span class="sd">            The cutting plane of the slice. Options are &#39;xy&#39;, &#39;xz&#39;, or &#39;yz&#39;.</span>
<span class="sd">            Default is &#39;xy&#39;.</span>
<span class="sd">        data : str, optional</span>
<span class="sd">            Data basis for plotting. Options are &#39;voxels&#39; or &#39;poly&#39;. Default is None.</span>
<span class="sd">        pos : str or float, optional</span>
<span class="sd">            Position of the slice, either as an absolute value or as one of</span>
<span class="sd">            &#39;top&#39;, &#39;bottom&#39;, &#39;left&#39;, &#39;right&#39;. Default is None.</span>
<span class="sd">        fname : str, optional</span>
<span class="sd">            Filename to save the figure as a PDF. Default is None.</span>
<span class="sd">        dual_phase : bool, optional</span>
<span class="sd">            If True, enable dual-phase visualization. Default is False.</span>
<span class="sd">        save_files : bool, optional</span>
<span class="sd">            If True, the figure will be saved to disk. Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; micro.plot_slice(cut=&#39;xz&#39;, data=&#39;poly&#39;, pos=&#39;top&#39;, save_files=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_ang</span><span class="p">(</span><span class="n">cut</span><span class="o">=</span><span class="n">cut</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">save_files</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="n">fname</span><span class="p">,</span> <span class="n">dual_phase</span><span class="o">=</span><span class="n">dual_phase</span><span class="p">,</span>
                        <span class="n">save_plot</span><span class="o">=</span><span class="n">save_files</span><span class="p">)</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    --------        Import/Export methods        --------</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Microstructure.write_abq">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.api.Microstructure.write_abq">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_abq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s1">&#39;./&#39;</span><span class="p">,</span> <span class="n">voxel_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">grain_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">dual_phase</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">thermal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ialloy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsdv</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">crystal_plasticity</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                  <span class="n">phase_props</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="o">*</span><span class="p">,</span>
                  <span class="n">boundary_conditions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the Abaqus input deck (.inp) for the generated RVE</span>

<span class="sd">        This method generates an Abaqus input file for the current RVE. It supports</span>
<span class="sd">        voxelized or smoothened meshes, dual-phase materials, crystal plasticity,</span>
<span class="sd">        thermal analysis, custom material properties, and optional boundary conditions.</span>
<span class="sd">        Material definitions and mesh data are automatically handled based on provided</span>
<span class="sd">        arguments or class attributes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes : str or array-like, optional</span>
<span class="sd">            Defines the mesh to write:</span>
<span class="sd">            - &#39;voxels&#39;, &#39;v&#39; : use voxelized mesh</span>
<span class="sd">            - &#39;smooth&#39;, &#39;s&#39; : use smoothened mesh</span>
<span class="sd">            - array-like : explicit nodal coordinates</span>
<span class="sd">            Default is None, automatically selecting available mesh.</span>
<span class="sd">        file : str, optional</span>
<span class="sd">            Filename for the Abaqus input deck. Default is auto-generated.</span>
<span class="sd">        path : str, optional</span>
<span class="sd">            Directory path to save the input deck. Default is &#39;./&#39;.</span>
<span class="sd">        voxel_dict : dict, optional</span>
<span class="sd">            Dictionary with voxel information. Default is `self.mesh.voxel_dict`.</span>
<span class="sd">        grain_dict : dict, optional</span>
<span class="sd">            Dictionary mapping grain IDs to nodes. Default is `self.mesh.grain_dict`.</span>
<span class="sd">        dual_phase : bool, optional</span>
<span class="sd">            If True, generate input for dual-phase materials. Default is False.</span>
<span class="sd">        thermal : bool, optional</span>
<span class="sd">            If True, include thermal material definitions. Default is False.</span>
<span class="sd">        units : str, optional</span>
<span class="sd">            Units for the model, &#39;mm&#39; or &#39;um&#39;. Default is `self.rve.units`.</span>
<span class="sd">        ialloy : list or object, optional</span>
<span class="sd">            Material definitions for each phase. Default is `self.rve.ialloy`.</span>
<span class="sd">        nsdv : int, optional</span>
<span class="sd">            Number of state variables per integration point for crystal plasticity. Default is 200.</span>
<span class="sd">        crystal_plasticity : bool, optional</span>
<span class="sd">            If True, enable crystal plasticity material definitions. Default is False.</span>
<span class="sd">        phase_props : dict, optional</span>
<span class="sd">            Additional phase-specific material properties.</span>
<span class="sd">        boundary_conditions : dict, optional</span>
<span class="sd">            Dictionary specifying boundary conditions to write. Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        file : str</span>
<span class="sd">            Full path to the generated Abaqus input file.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            - If no voxelized or smoothened mesh is available when required.</span>
<span class="sd">            - If invalid `nodes` argument is provided.</span>
<span class="sd">            - If units are not &#39;mm&#39; or &#39;um&#39;.</span>
<span class="sd">            - If the list `ialloy` is longer than the number of phases in the RVE.</span>
<span class="sd">            - If periodic boundary conditions are requested but the RVE is non-periodic.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Automatically selects voxel or smoothened mesh if `nodes` is None.</span>
<span class="sd">        - Handles dual-phase structures and crystal plasticity input.</span>
<span class="sd">        - Writes additional material files if orientations are available and `ialloy` is provided.</span>
<span class="sd">        - Visualization or mesh generation must be performed before calling this function.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Write voxelized RVE input deck with default settings</span>
<span class="sd">        &gt;&gt;&gt; abq_file = rve.write_abq(nodes=&#39;voxels&#39;)</span>

<span class="sd">        &gt;&gt;&gt; # Write smoothened RVE deck for dual-phase material</span>
<span class="sd">        &gt;&gt;&gt; abq_file = rve.write_abq(nodes=&#39;smooth&#39;, dual_phase=True, ialloy=alloy_list)</span>

<span class="sd">        &gt;&gt;&gt; # Include boundary conditions</span>
<span class="sd">        &gt;&gt;&gt; bc = {&#39;ux&#39;: [0, 0.1], &#39;uy&#39;: [0, 0.1]}</span>
<span class="sd">        &gt;&gt;&gt; abq_file = rve.write_abq(nodes=&#39;voxels&#39;, boundary_conditions=bc)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes_smooth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s1">&#39;GBarea&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Warning: No argument &quot;nodes&quot; is given, will write smoothened structure&#39;</span><span class="p">)</span>
                <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes_smooth</span>
                <span class="n">faces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="s1">&#39;GBarea&#39;</span><span class="p">]</span>
                <span class="n">ntag</span> <span class="o">=</span> <span class="s1">&#39;_smooth&#39;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Warning: No argument &quot;nodes&quot; is given, will write voxelized structure&#39;</span><span class="p">)</span>
                <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span>
                <span class="n">faces</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">ntag</span> <span class="o">=</span> <span class="s1">&#39;_voxels&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No information about voxelized microstructure. Run voxelize first.&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">faces</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">ntag</span> <span class="o">=</span> <span class="s1">&#39;_voxels&#39;</span>
        <span class="k">elif</span> <span class="n">nodes</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;smooth&#39;</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes_smooth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s1">&#39;GBarea&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes_smooth</span>
                <span class="n">faces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="s1">&#39;GBarea&#39;</span><span class="p">]</span>  <span class="c1"># use tet elements for smoothened structure</span>
                <span class="n">ntag</span> <span class="o">=</span> <span class="s1">&#39;_smooth&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No information about smoothed microstructure. Run smoothen first.&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">nodes</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;voxels&#39;</span><span class="p">,</span> <span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="s1">&#39;voxel&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span>
                <span class="n">faces</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># use brick elements for voxel structure</span>
                <span class="n">ntag</span> <span class="o">=</span> <span class="s1">&#39;_voxels&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No information about voxelized microstructure. Run voxelize first.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Wrong value for parameter &quot;nodes&quot;. Must be either &quot;smooth&quot; &#39;</span> <span class="o">+</span>
                             <span class="sa">f</span><span class="s1">&#39;or &quot;voxels&quot;, not </span><span class="si">{</span><span class="n">nodes</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">voxel_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">voxel_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">voxel_dict</span>
        <span class="k">if</span> <span class="n">units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">units</span>
        <span class="k">elif</span> <span class="p">(</span><span class="ow">not</span> <span class="n">units</span> <span class="o">==</span> <span class="s1">&#39;mm&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">units</span> <span class="o">==</span> <span class="s1">&#39;um&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Units must be either &quot;mm&quot; or &quot;um&quot;, not </span><span class="si">{</span><span class="n">units</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dual_phase</span><span class="p">:</span>
            <span class="n">nct</span> <span class="o">=</span> <span class="s1">&#39;abq_dual_phase&#39;</span>
            <span class="k">if</span> <span class="n">grain_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">grain_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nphases</span><span class="p">):</span>
                    <span class="n">grain_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">igr</span><span class="p">,</span> <span class="n">ip</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grain_phase_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">grain_dict</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">grain_dict</span><span class="p">[</span><span class="n">ip</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="p">[</span><span class="n">igr</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">grain_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">grain_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span>
            <span class="n">nct</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;abq_px_</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">grain_dict</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">if</span> <span class="n">ialloy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ialloy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">ialloy</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ialloy</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">ialloy</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nphases</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;List of values in ialloy is larger than number of phases in RVE.&#39;</span> <span class="o">+</span>
                             <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ialloy</span><span class="p">)</span><span class="si">}</span><span class="s1"> &gt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nphases</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nphases</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">grpd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grain_phase_dict</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grpd</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;Microstructure&#39;</span><span class="p">:</span>
                <span class="n">file</span> <span class="o">=</span> <span class="n">nct</span> <span class="o">+</span> <span class="n">ntag</span> <span class="o">+</span> <span class="s1">&#39;_geom.inp&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="n">ntag</span> <span class="o">+</span> <span class="s1">&#39;_geom.inp&#39;</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
        <span class="n">periodic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">periodic</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">periodic</span> <span class="ow">and</span> <span class="n">periodicBC</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Periodic boundary conditions cannot be applied to a non-periodic RVE.&quot;</span><span class="p">)</span>

        <span class="n">export2abaqus</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">grain_dict</span><span class="p">,</span> <span class="n">voxel_dict</span><span class="p">,</span>
                      <span class="n">units</span><span class="o">=</span><span class="n">units</span><span class="p">,</span> <span class="n">gb_area</span><span class="o">=</span><span class="n">faces</span><span class="p">,</span>
                      <span class="n">dual_phase</span><span class="o">=</span><span class="n">dual_phase</span><span class="p">,</span>
                      <span class="n">ialloy</span><span class="o">=</span><span class="n">ialloy</span><span class="p">,</span> <span class="n">grain_phase_dict</span><span class="o">=</span><span class="n">grpd</span><span class="p">,</span>
                      <span class="n">thermal</span><span class="o">=</span><span class="n">thermal</span><span class="p">,</span>
                      <span class="n">crystal_plasticity</span> <span class="o">=</span> <span class="n">crystal_plasticity</span><span class="p">,</span>
                      <span class="n">phase_props</span> <span class="o">=</span> <span class="n">phase_props</span><span class="p">,</span> <span class="n">boundary_conditions</span> <span class="o">=</span> <span class="n">boundary_conditions</span><span class="p">)</span>

        <span class="c1"># if orientations exist and ialloy is defined also write material file with Euler angles</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grain_ori_dict</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">ialloy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">writeAbaqusMat</span><span class="p">(</span><span class="n">ialloy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grain_ori_dict</span><span class="p">,</span>
                           <span class="n">file</span><span class="o">=</span><span class="n">file</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;mat.inp&#39;</span><span class="p">,</span>
                           <span class="n">grain_phase_dict</span><span class="o">=</span><span class="n">grpd</span><span class="p">,</span> <span class="n">nsdv</span><span class="o">=</span><span class="n">nsdv</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">file</span></div>


<div class="viewcode-block" id="Microstructure.write_abq_ori">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.api.Microstructure.write_abq_ori">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_abq_ori</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ialloy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ori</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s1">&#39;./&#39;</span><span class="p">,</span> <span class="n">nsdv</span><span class="o">=</span><span class="mi">200</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write Abaqus material input file using grain orientations for crystal plasticity</span>

<span class="sd">        This function generates an Abaqus `.inp` file containing material definitions</span>
<span class="sd">        for crystal plasticity, using the provided grain orientations and material IDs.</span>
<span class="sd">        If `ialloy` or `ori` are not specified, the method uses the RVE&#39;s default values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ialloy : list or object, optional</span>
<span class="sd">            Material identifiers for each phase. Default is `self.rve.ialloy`.</span>
<span class="sd">        ori : dict or array-like, optional</span>
<span class="sd">            Dictionary or array of grain orientations. Default is `self.mesh.grain_ori_dict`.</span>
<span class="sd">        file : str, optional</span>
<span class="sd">            Name of the output Abaqus material file. Default is auto-generated based on RVE name.</span>
<span class="sd">        path : str, optional</span>
<span class="sd">            Directory path where the file will be saved. Default is &#39;./&#39;.</span>
<span class="sd">        nsdv : int, optional</span>
<span class="sd">            Number of state variables per integration point for crystal plasticity. Default is 200.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        file : str</span>
<span class="sd">            Full path to the generated Abaqus material input file.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            - If `ialloy` is not provided and `self.rve.ialloy` is None.</span>
<span class="sd">            - If `ori` is not provided and `self.mesh.grain_ori_dict` is None.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Calls `writeAbaqusMat` internally to generate the material definitions.</span>
<span class="sd">        - Assumes the RVE and grain orientations have been initialized prior to calling.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Write material file using default RVE orientations and material numbers</span>
<span class="sd">        &gt;&gt;&gt; abq_file = rve.write_abq_ori()</span>

<span class="sd">        &gt;&gt;&gt; # Specify custom material IDs and orientations</span>
<span class="sd">        &gt;&gt;&gt; abq_file = rve.write_abq_ori(ialloy=alloy_list, ori=ori_dict, file=&#39;custom_mat.inp&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ialloy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ialloy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">ialloy</span>
            <span class="k">if</span> <span class="n">ialloy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Value of material number in ICAMS CP-UMAT (ialloy) not defined.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ori</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ori</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grain_ori_dict</span>
            <span class="k">if</span> <span class="n">ori</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No orientations present. Run &quot;generate_orientations&quot; first.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;Microstructure&#39;</span><span class="p">:</span>
                <span class="n">file</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;abq_px_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">Ngr</span><span class="si">}</span><span class="s1">_mat.inp&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_mat.inp&#39;</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
        <span class="n">writeAbaqusMat</span><span class="p">(</span><span class="n">ialloy</span><span class="p">,</span> <span class="n">ori</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">file</span><span class="p">,</span> <span class="n">nsdv</span><span class="o">=</span><span class="n">nsdv</span><span class="p">)</span></div>


<div class="viewcode-block" id="Microstructure.output_neper">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.api.Microstructure.output_neper">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">output_neper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write particle position and weight files for Neper tessellation</span>

<span class="sd">        This function generates two text files required for tessellation in Neper:</span>
<span class="sd">        - `sphere_positions.txt` containing the x, y, z coordinates of each particle</span>
<span class="sd">        - `sphere_weights.txt` containing the weight (radius) of each particle</span>

<span class="sd">        The files are written in the current working directory. Each particle in</span>
<span class="sd">        `self.particles` is included in the output.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `self.particles` is None, indicating that particles have not been packed yet.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Requires that particles are initialized via the `pack()` method.</span>
<span class="sd">        - The particle dictionary is built internally but not returned.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Write Neper input files for current particles</span>
<span class="sd">        &gt;&gt;&gt; rve.output_neper()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># write_position_weights(timestep)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">particles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No particle to plot. Run pack first.&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Writing position and weights files for NEPER&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">par_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">pa</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">particles</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pa</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">pa</span><span class="o">.</span><span class="n">z</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">a</span>
            <span class="n">par_dict</span><span class="p">[</span><span class="n">pa</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">a</span><span class="p">]</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;sphere_positions.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fd</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">par_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> </span><span class="si">{1}</span><span class="s1"> </span><span class="si">{2}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">value</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;sphere_weights.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fd</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">par_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;----&gt;DONE!</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Microstructure.output_ang">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.api.Microstructure.output_ang">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">output_ang</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ori</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cut</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">matname</span><span class="o">=</span><span class="s1">&#39;XXXX&#39;</span><span class="p">,</span> <span class="n">save_files</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">dual_phase</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">save_plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert microstructure orientations into a .ang file, optionally plotting a slice</span>

<span class="sd">        This function generates a .ang file mimicking an EBSD map. If polygonalized</span>
<span class="sd">        microstructure is available, it will be used; otherwise, or if `data=&#39;voxels&#39;`,</span>
<span class="sd">        the voxelized microstructure will be exported. If no orientations are provided,</span>
<span class="sd">        each grain receives a random Euler angle. The function can also plot a 2D slice</span>
<span class="sd">        of the orientation map along a specified cutting plane.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ori : array-like of shape (self.Ngr, 3), optional</span>
<span class="sd">            Euler angles of grains. If None, random angles are generated.</span>
<span class="sd">        cut : {&#39;xy&#39;, &#39;xz&#39;, &#39;yz&#39;}, optional</span>
<span class="sd">            Plane along which to take a slice. Default is &#39;xy&#39;.</span>
<span class="sd">        data : {&#39;voxels&#39;, &#39;poly&#39;}, optional</span>
<span class="sd">            Basis for generating the ANG file. Default is None, automatically selected.</span>
<span class="sd">        plot : bool, optional</span>
<span class="sd">            Whether to display a plot of the slice. Default is True.</span>
<span class="sd">        cs : str, optional</span>
<span class="sd">            Crystal symmetry. Default is None.</span>
<span class="sd">        pos : float or str, optional</span>
<span class="sd">            Slice position as a numerical value or one of &#39;top&#39;, &#39;bottom&#39;, &#39;left&#39;, &#39;right&#39;.</span>
<span class="sd">            Default is None (uses top/right edge).</span>
<span class="sd">        fname : str, optional</span>
<span class="sd">            Filename for the output ANG file. Default is generated automatically.</span>
<span class="sd">        matname : str, optional</span>
<span class="sd">            Material name to write in the ANG file. Default is &#39;XXXX&#39;.</span>
<span class="sd">        save_files : bool, optional</span>
<span class="sd">            Whether to save the ANG file. Default is True.</span>
<span class="sd">        dual_phase : bool, optional</span>
<span class="sd">            Whether to output dual-phase information. Default is False.</span>
<span class="sd">        save_plot : bool, optional</span>
<span class="sd">            Whether to save the plot as a PDF. Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fname : str</span>
<span class="sd">            Name of the generated ANG file.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            - If `pos` is not a float or one of &#39;top&#39;, &#39;bottom&#39;, &#39;left&#39;, &#39;right&#39;.</span>
<span class="sd">            - If `cut` is not &#39;xy&#39;, &#39;xz&#39;, or &#39;yz&#39;.</span>
<span class="sd">            - If neither polygonal nor voxel microstructure is available.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Uses Delaunay triangulation to determine which grain each pixel belongs to</span>
<span class="sd">          when exporting polygons.</span>
<span class="sd">        - Slice plotting uses a colormap (default &#39;prism&#39;) and includes optional</span>
<span class="sd">          dual-phase coloring.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Export an XY slice with default settings</span>
<span class="sd">        &gt;&gt;&gt; fname = rve.output_ang(cut=&#39;xy&#39;)</span>

<span class="sd">        &gt;&gt;&gt; # Export a slice using voxel data and a specific Euler angles array</span>
<span class="sd">        &gt;&gt;&gt; fname = rve.output_ang(ori=euler_array, data=&#39;voxels&#39;, cut=&#39;xz&#39;, pos=10)</span>

<span class="sd">        &gt;&gt;&gt; # Plot and save the slice as PDF</span>
<span class="sd">        &gt;&gt;&gt; fname = rve.output_ang(save_plot=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ori</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="n">ori</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">val</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">ori</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
        <span class="n">cut</span> <span class="o">=</span> <span class="n">cut</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">botlist</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">,</span> <span class="s1">&#39;bot&#39;</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;l&#39;</span><span class="p">]</span>
        <span class="n">toplist</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">cut</span> <span class="o">==</span> <span class="s1">&#39;xy&#39;</span><span class="p">:</span>
            <span class="n">sizeX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">sizeY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">(</span><span class="n">sx</span><span class="p">,</span> <span class="n">sy</span><span class="p">,</span> <span class="n">sz</span><span class="p">)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">iy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">toplist</span><span class="p">:</span>
                <span class="n">iz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">dim</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">botlist</span><span class="p">:</span>
                <span class="n">iz</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">float</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
                <span class="n">iz</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pos</span> <span class="o">/</span> <span class="n">sz</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;&quot;pos&quot; must be either float or &quot;top&quot;, &quot;bottom&quot;, &quot;left&quot; or &quot;right&quot;&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">iz</span> <span class="o">*</span> <span class="n">sz</span><span class="p">)</span>
            <span class="n">xl</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;x ($\mu$m)&#39;</span>
            <span class="n">yl</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;y ($\mu$m)&#39;</span>
            <span class="n">title</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;XY slice at z=</span><span class="si">{}</span><span class="s1"> $\mu$m&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">iz</span> <span class="o">*</span> <span class="n">sz</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">cut</span> <span class="o">==</span> <span class="s1">&#39;xz&#39;</span><span class="p">:</span>
            <span class="n">sizeX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">sizeY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">vox_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
            <span class="n">sx</span> <span class="o">=</span> <span class="n">vox_res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">sy</span> <span class="o">=</span> <span class="n">vox_res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">sz</span> <span class="o">=</span> <span class="n">vox_res</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">iy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">dim</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">toplist</span><span class="p">:</span>
                <span class="n">iz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">botlist</span><span class="p">:</span>
                <span class="n">iz</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">float</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
                <span class="n">iz</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pos</span> <span class="o">/</span> <span class="n">sy</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;&quot;pos&quot; must be either float or &quot;top&quot;, &quot;bottom&quot;, &quot;left&quot; or &quot;right&quot;&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">iz</span> <span class="o">*</span> <span class="n">sz</span><span class="p">)</span>
            <span class="n">xl</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;x ($\mu$m)&#39;</span>
            <span class="n">yl</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;z ($\mu$m)&#39;</span>
            <span class="n">title</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;XZ slice at y=</span><span class="si">{}</span><span class="s1"> $\mu$m&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">iz</span> <span class="o">*</span> <span class="n">sz</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">cut</span> <span class="o">==</span> <span class="s1">&#39;yz&#39;</span><span class="p">:</span>
            <span class="n">sizeX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">sizeY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">vox_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
            <span class="n">sx</span> <span class="o">=</span> <span class="n">vox_res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">sy</span> <span class="o">=</span> <span class="n">vox_res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">sz</span> <span class="o">=</span> <span class="n">vox_res</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">iy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">dim</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">toplist</span><span class="p">:</span>
                <span class="n">iz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">botlist</span><span class="p">:</span>
                <span class="n">iz</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">float</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
                <span class="n">iz</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pos</span> <span class="o">/</span> <span class="n">sx</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;&quot;pos&quot; must be either float or &quot;top&quot;, &quot;bottom&quot;, &quot;left&quot; or &quot;right&quot;&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">iz</span> <span class="o">*</span> <span class="n">sz</span><span class="p">)</span>
            <span class="n">xl</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;y ($\mu$m)&#39;</span>
            <span class="n">yl</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;z ($\mu$m)&#39;</span>
            <span class="n">title</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;YZ slice at x=</span><span class="si">{}</span><span class="s1"> $\mu$m&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">iz</span> <span class="o">*</span> <span class="n">sz</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;&quot;cut&quot; must bei either &quot;xy&quot;, &quot;xz&quot; or &quot;yz&quot;.&#39;</span><span class="p">)</span>
        <span class="c1"># ANG file header</span>
        <span class="n">head</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;# TEM_PIXperUM          1.000000</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;# x-star                0.000000</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;# y-star                0.000000</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;# z-star                0.000000</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;# WorkingDistance       0.000000</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;#</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;# Phase 0</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;# MaterialName  	</span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">matname</span><span class="p">),</span>
                <span class="s1">&#39;# Formula</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;# Info</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;# Symmetry              m-3m</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;# LatticeConstants       4.050 4.050 4.050  90.000  90.000  90.000</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;# NumberFamilies        0</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;# ElasticConstants 	0.000000 0.000000 0.000000 0.000000 0.000000 0.000000</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;# ElasticConstants 	0.000000 0.000000 0.000000 0.000000 0.000000 0.000000</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;# ElasticConstants 	0.000000 0.000000 0.000000 0.000000 0.000000 0.000000</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;# ElasticConstants 	0.000000 0.000000 0.000000 0.000000 0.000000 0.000000</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;# ElasticConstants 	0.000000 0.000000 0.000000 0.000000 0.000000 0.000000</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;# ElasticConstants 	0.000000 0.000000 0.000000 0.000000 0.000000 0.000000</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;# Categories0 0 0 0 0</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;# </span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;# GRID: SqrGrid</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;# XSTEP: </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">sx</span><span class="p">,</span> <span class="mi">6</span><span class="p">)),</span>
                <span class="s1">&#39;# YSTEP: </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">sy</span><span class="p">,</span> <span class="mi">6</span><span class="p">)),</span>
                <span class="s1">&#39;# NCOLS_ODD: </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ix</span><span class="p">),</span>
                <span class="s1">&#39;# NCOLS_EVEN: </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ix</span><span class="p">),</span>
                <span class="s1">&#39;# NROWS: </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iy</span><span class="p">),</span>
                <span class="s1">&#39;#</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;# OPERATOR: 	Administrator</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;#</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;# SAMPLEID:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;#</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;# SCANID:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;#</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="p">]</span>

        <span class="c1"># determine whether polygons or voxels shall be exported</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;Grains&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">data</span> <span class="o">=</span> <span class="s1">&#39;poly&#39;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">voxels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Neither polygons nor voxels for grains are present.</span><span class="se">\</span>
<span class="s1">                                 </span><span class="se">\n</span><span class="s1">Run voxelize and generate_grains first.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="s1">&#39;voxels&#39;</span>
        <span class="k">elif</span> <span class="n">data</span> <span class="o">!=</span> <span class="s1">&#39;voxels&#39;</span> <span class="ow">and</span> <span class="n">data</span> <span class="o">!=</span> <span class="s1">&#39;poly&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;&quot;data&quot; must be either &quot;voxels&quot; or &quot;poly&quot;.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">data</span> <span class="o">==</span> <span class="s1">&#39;voxels&#39;</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">+=</span> <span class="s1">&#39; (Voxels)&#39;</span>
            <span class="k">if</span> <span class="n">cut</span> <span class="o">==</span> <span class="s1">&#39;xy&#39;</span><span class="p">:</span>
                <span class="n">g_slice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grains</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">iz</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">cut</span> <span class="o">==</span> <span class="s1">&#39;xz&#39;</span><span class="p">:</span>
                <span class="n">g_slice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grains</span><span class="p">[:,</span> <span class="n">iz</span><span class="p">,</span> <span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">g_slice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grains</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dual_phase</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cut</span> <span class="o">==</span> <span class="s1">&#39;xy&#39;</span><span class="p">:</span>
                    <span class="n">g_slice_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">phases</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">iz</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">cut</span> <span class="o">==</span> <span class="s1">&#39;xz&#39;</span><span class="p">:</span>
                    <span class="n">g_slice_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">phases</span><span class="p">[:,</span> <span class="n">iz</span><span class="p">,</span> <span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">g_slice_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">+=</span> <span class="s1">&#39; (Polygons)&#39;</span>
            <span class="n">xv</span><span class="p">,</span> <span class="n">yv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">ix</span> <span class="o">*</span> <span class="n">sx</span><span class="p">,</span> <span class="n">iy</span> <span class="o">*</span> <span class="n">sy</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
            <span class="n">grain_slice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">iy</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cut</span> <span class="o">==</span> <span class="s1">&#39;xy&#39;</span><span class="p">:</span>
                <span class="n">mesh_slice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xv</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">yv</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">grain_slice</span> <span class="o">*</span> <span class="n">iz</span> <span class="o">*</span> <span class="n">sz</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
            <span class="k">elif</span> <span class="n">cut</span> <span class="o">==</span> <span class="s1">&#39;xz&#39;</span><span class="p">:</span>
                <span class="n">mesh_slice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xv</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">grain_slice</span> <span class="o">*</span> <span class="n">iz</span> <span class="o">*</span> <span class="n">sz</span><span class="p">,</span> <span class="n">yv</span><span class="o">.</span><span class="n">flatten</span><span class="p">()])</span><span class="o">.</span><span class="n">T</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mesh_slice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">grain_slice</span> <span class="o">*</span> <span class="n">iz</span> <span class="o">*</span> <span class="n">sz</span><span class="p">,</span> <span class="n">xv</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">yv</span><span class="o">.</span><span class="n">flatten</span><span class="p">()])</span><span class="o">.</span><span class="n">T</span>
            <span class="n">grain_slice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">iy</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">igr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="s1">&#39;Grains&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">pts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="s1">&#39;Grains&#39;</span><span class="p">][</span><span class="n">igr</span><span class="p">][</span><span class="s1">&#39;Points&#39;</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">tri</span> <span class="o">=</span> <span class="n">Delaunay</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">tri</span><span class="o">.</span><span class="n">find_simplex</span><span class="p">(</span><span class="n">mesh_slice</span><span class="p">)</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">grain_slice</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">igr</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;An unexpected exception occurred: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Grain #</span><span class="si">{}</span><span class="s1"> has no convex hull (Nvertices: </span><span class="si">{}</span><span class="s1">)&#39;</span>
                                  <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">igr</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">pts</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">grain_slice</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">grain_slice</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Incomplete slicing for </span><span class="si">{}</span><span class="s1"> pixels in </span><span class="si">{}</span><span class="s1"> slice at </span><span class="si">{}</span><span class="s1">.&#39;</span>
                              <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">),</span> <span class="n">cut</span><span class="p">,</span> <span class="n">pos</span><span class="p">))</span>
            <span class="n">g_slice</span> <span class="o">=</span> <span class="n">grain_slice</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">xv</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">save_files</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ori</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ori</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Ngr</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
                <span class="n">ori</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ngr</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                <span class="n">ori</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ngr</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                <span class="n">ori</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ngr</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="c1"># write data to ang file</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">_slice_</span><span class="si">{1}</span><span class="s1">_</span><span class="si">{2}</span><span class="s1">.ang&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cut</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">pos</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">iy</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ix</span><span class="p">:</span>
                        <span class="n">p1</span> <span class="o">=</span> <span class="n">ori</span><span class="p">[</span><span class="n">g_slice</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                        <span class="n">P</span> <span class="o">=</span> <span class="n">ori</span><span class="p">[</span><span class="n">g_slice</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="n">p2</span> <span class="o">=</span> <span class="n">ori</span><span class="p">[</span><span class="n">g_slice</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;  </span><span class="si">{0}</span><span class="s1">  </span><span class="si">{1}</span><span class="s1">  </span><span class="si">{2}</span><span class="s1">  </span><span class="si">{3}</span><span class="s1">  </span><span class="si">{4}</span><span class="s1">   0.0  0.000  0   1  0.000</span><span class="se">\n</span><span class="s1">&#39;</span>
                                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="nb">round</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="nb">round</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
                                        <span class="nb">round</span><span class="p">(</span><span class="n">sizeX</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="n">sx</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="nb">round</span><span class="p">(</span><span class="n">sizeY</span> <span class="o">-</span> <span class="n">j</span> <span class="o">*</span> <span class="n">sy</span><span class="p">,</span> <span class="mi">5</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="c1"># plot grains on slice</span>
            <span class="c1"># cmap = plt.cm.get_cmap(&#39;gist_rainbow&#39;)</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;prism&#39;</span><span class="p">)</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">g_slice</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span>
                      <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">sizeX</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sizeY</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xlabel</span><span class="o">=</span><span class="n">xl</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="n">yl</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">save_plot</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.pdf&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;pdf&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">dual_phase</span><span class="p">:</span>
                <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">g_slice_phase</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span>
                          <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">sizeX</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sizeY</span><span class="p">])</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xlabel</span><span class="o">=</span><span class="n">xl</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="n">yl</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">save_plot</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.pdf&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;pdf&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">fname</span></div>


<div class="viewcode-block" id="Microstructure.write_stl">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.api.Microstructure.write_stl">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_stl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="s1">&#39;grains&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s1">&#39;./&#39;</span><span class="p">,</span>
                  <span class="n">phases</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">phase_num</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Export grains or particles as STL files representing convex polyhedra</span>

<span class="sd">        This function writes STL files with triangular facets for grains or particles.</span>
<span class="sd">        Each facet is written in standard STL ASCII format:</span>

<span class="sd">        ```</span>
<span class="sd">        solid name</span>
<span class="sd">          facet normal n1 n2 n3</span>
<span class="sd">            outer loop</span>
<span class="sd">              vertex p1x p1y p1z</span>
<span class="sd">              vertex p2x p2y p2z</span>
<span class="sd">              vertex p3x p3y p3z</span>
<span class="sd">            endloop</span>
<span class="sd">          endfacet</span>
<span class="sd">        endsolid name</span>
<span class="sd">        ```</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : {&#39;grains&#39;, &#39;particles&#39;}, optional</span>
<span class="sd">            Determines whether to export grains or particles. Default is &#39;grains&#39;.</span>
<span class="sd">        file : str, optional</span>
<span class="sd">            Filename for the STL file. Default is generated from `self.name`.</span>
<span class="sd">        path : str, optional</span>
<span class="sd">            Directory to save the STL file. Default is &#39;./&#39;.</span>
<span class="sd">        phases : bool, optional</span>
<span class="sd">            If True, export only grains of a specific phase. Default is False.</span>
<span class="sd">        phase_num : int, optional</span>
<span class="sd">            Phase number to export if `phases=True`. Required in that case.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            - If `phases=True` but `phase_num` is not provided.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Facet normals are automatically computed using cross products of vertices.</span>
<span class="sd">        - Acute or irregular facets trigger warnings.</span>
<span class="sd">        - For particle export, each particle must have a valid inner polyhedron.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Export all grains to STL</span>
<span class="sd">        &gt;&gt;&gt; rve.write_stl()</span>

<span class="sd">        &gt;&gt;&gt; # Export particles to STL</span>
<span class="sd">        &gt;&gt;&gt; rve.write_stl(data=&#39;particles&#39;)</span>

<span class="sd">        &gt;&gt;&gt; # Export only phase 1 grains</span>
<span class="sd">        &gt;&gt;&gt; rve.write_stl(phases=True, phase_num=1)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">write_facet</span><span class="p">(</span><span class="n">nv</span><span class="p">,</span> <span class="n">pts</span><span class="p">,</span> <span class="n">ft</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Write a single triangular facet to the STL file with a normalized normal vector</span>

<span class="sd">            Checks for degenerate or nearly zero-length normals and issues warnings</span>
<span class="sd">            if the facet is acute or irregular. Writes the facet in ASCII STL format.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            nv : ndarray</span>
<span class="sd">                Initial normal vector of the facet.</span>
<span class="sd">            pts : ndarray</span>
<span class="sd">                3x3 array of vertex coordinates defining the facet.</span>
<span class="sd">            ft : int</span>
<span class="sd">                Facet index, used for logging warnings.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">nv</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1.e-5</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Acute facet detected. Facet: </span><span class="si">{</span><span class="n">ft</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">nv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">nv</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1.e-5</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Irregular facet detected. Facet: </span><span class="si">{</span><span class="n">ft</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">nv</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">nv</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot; facet normal </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nv</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot; outer loop</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;   vertex </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;   vertex </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;   vertex </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;  endloop</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot; endfacet</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">write_grains</span><span class="p">():</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Write all grain facets of the microstructure to the STL file</span>

<span class="sd">            Iterates over all facets defined in `self.geometry[&#39;Facets&#39;]`, computes</span>
<span class="sd">            the facet normal, and calls `write_facet` to output each triangular facet.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">for</span> <span class="n">ft</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="s1">&#39;Facets&#39;</span><span class="p">]:</span>
                <span class="n">pts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="s1">&#39;Points&#39;</span><span class="p">][</span><span class="n">ft</span><span class="p">]</span>
                <span class="n">nv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># facet normal</span>
                <span class="n">write_facet</span><span class="p">(</span><span class="n">nv</span><span class="p">,</span> <span class="n">pts</span><span class="p">,</span> <span class="n">ft</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">write_phases</span><span class="p">(</span><span class="n">ip</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Write facets of grains belonging to a specific phase to the STL file</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            ip : int</span>
<span class="sd">                Phase number for which the grain facets should be exported.</span>

<span class="sd">            Notes</span>
<span class="sd">            -----</span>
<span class="sd">            Iterates over all grains in `self.geometry[&#39;Grains&#39;]` and writes only</span>
<span class="sd">            the facets of grains whose &#39;Phase&#39; matches `ip`. Each facet is output</span>
<span class="sd">            using the `write_facet` function.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">for</span> <span class="n">grain</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="s1">&#39;Grains&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">grain</span><span class="p">[</span><span class="s1">&#39;Phase&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">ip</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">ft</span> <span class="ow">in</span> <span class="n">grain</span><span class="p">[</span><span class="s1">&#39;Simplices&#39;</span><span class="p">]:</span>
                        <span class="n">pts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="s1">&#39;Points&#39;</span><span class="p">][</span><span class="n">ft</span><span class="p">]</span>
                        <span class="n">nv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># facet normal</span>
                        <span class="n">write_facet</span><span class="p">(</span><span class="n">nv</span><span class="p">,</span> <span class="n">pts</span><span class="p">,</span> <span class="n">ft</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">write_particles</span><span class="p">():</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Write facets of all particle convex hulls to the STL file</span>

<span class="sd">            Notes</span>
<span class="sd">            -----</span>
<span class="sd">            Iterates over all particles in `self.particles` and exports each facet</span>
<span class="sd">            from the particle&#39;s inner convex hull using the `write_facet` function.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">for</span> <span class="n">pa</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">particles</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ft</span> <span class="ow">in</span> <span class="n">pa</span><span class="o">.</span><span class="n">inner</span><span class="o">.</span><span class="n">convex_hull</span><span class="p">:</span>
                    <span class="n">pts</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">inner</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">ft</span><span class="p">]</span>
                    <span class="n">nv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># facet normal</span>
                    <span class="n">write_facet</span><span class="p">(</span><span class="n">nv</span><span class="p">,</span> <span class="n">pts</span><span class="p">,</span> <span class="n">ft</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;Microstructure&#39;</span><span class="p">:</span>
                <span class="n">file</span> <span class="o">=</span> <span class="s1">&#39;px_</span><span class="si">{}</span><span class="s1">grains.stl&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ngr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;.stl&#39;</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;solid </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">data</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;particles&#39;</span><span class="p">,</span> <span class="s1">&#39;pa&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">inner</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Particles don&#39;t contain inner polyhedron, cannot write STL file.&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">pa</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">particles</span><span class="p">:</span>
                        <span class="n">pa</span><span class="o">.</span><span class="n">sync_poly</span><span class="p">()</span>
                    <span class="n">write_particles</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">phases</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">phase_num</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Phase-specific output requested, but no phase number specified.&#39;</span><span class="p">)</span>
                    <span class="n">write_phases</span><span class="p">(</span><span class="n">phase_num</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">write_grains</span><span class="p">()</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;endsolid</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span></div>


<div class="viewcode-block" id="Microstructure.write_centers">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.api.Microstructure.write_centers">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_centers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s1">&#39;./&#39;</span><span class="p">,</span> <span class="n">grains</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the center positions of grains to a CSV file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file : str, optional</span>
<span class="sd">            Filename for the CSV file. Default is auto-generated based on `self.name`.</span>
<span class="sd">        path : str, optional</span>
<span class="sd">            Directory path to save the CSV file. Default is &#39;./&#39;.</span>
<span class="sd">        grains : dict, optional</span>
<span class="sd">            Dictionary of grain data. Default is `self.geometry[&#39;Grains&#39;]`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Each line in the CSV file corresponds to a grain center in the format: x, y, z.</span>
<span class="sd">        - Polyhedral grains without simplices are skipped.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;Microstructure&#39;</span><span class="p">:</span>
                <span class="n">file</span> <span class="o">=</span> <span class="s1">&#39;px_</span><span class="si">{}</span><span class="s1">grains_centroid.csv&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ngr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_centroid.csv&#39;</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">grains</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">grains</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="s1">&#39;Grains&#39;</span><span class="p">]</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">gr</span> <span class="ow">in</span> <span class="n">grains</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="c1"># if polyhedral grain has no simplices, center should not be written!!!</span>
                <span class="n">ctr</span> <span class="o">=</span> <span class="n">gr</span><span class="p">[</span><span class="s1">&#39;Center&#39;</span><span class="p">]</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ctr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ctr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ctr</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">return</span></div>


<div class="viewcode-block" id="Microstructure.write_ori">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.api.Microstructure.write_ori">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_ori</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s1">&#39;./&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write grain orientations (Euler angles) to a CSV file</span>

<span class="sd">        This method exports the orientations of grains in the microstructure. If no angles</span>
<span class="sd">        are provided, the method uses the stored grain orientations from the mesh. The CSV</span>
<span class="sd">        file contains one row per grain with three values representing the Euler angles</span>
<span class="sd">        (phi1, Phi, phi2).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        angles : array-like of shape (N, 3), optional</span>
<span class="sd">            Euler angles for each grain. If None, the stored orientations are used.</span>
<span class="sd">        file : str, optional</span>
<span class="sd">            Name of the output CSV file. If None, a default name based on the microstructure</span>
<span class="sd">            name and number of grains is used.</span>
<span class="sd">        path : str, optional</span>
<span class="sd">            Directory path where the CSV file will be saved. Default is &#39;./&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            Full path to the generated CSV file.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `angles` is None and no grain orientations are stored in `self.mesh.grain_ori_dict`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Each row in the CSV corresponds to one grain.</span>
<span class="sd">        - Values are written in the order: phi1, Phi, phi2 (in radians).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Export stored orientations to default file</span>
<span class="sd">        &gt;&gt;&gt; rve.write_ori()</span>

<span class="sd">        &gt;&gt;&gt; # Export provided orientations to a specific file</span>
<span class="sd">        &gt;&gt;&gt; rve.write_ori(angles=my_angles, file=&#39;grain_orientations.csv&#39;, path=&#39;./data&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;Microstructure&#39;</span><span class="p">:</span>
                <span class="n">file</span> <span class="o">=</span> <span class="s1">&#39;px_</span><span class="si">{}</span><span class="s1">grains_ori.csv&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ngr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_ori.csv&#39;</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">angles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grain_ori_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No grain orientations given or stored.&#39;</span><span class="p">)</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grain_ori_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ori</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ori</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ori</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ori</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">return</span></div>


<div class="viewcode-block" id="Microstructure.write_voxels">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.api.Microstructure.write_voxels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_voxels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">script_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s1">&#39;./&#39;</span><span class="p">,</span>
                     <span class="n">mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">system</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write voxel structure of the microstructure to a JSON file</span>

<span class="sd">        This function exports the voxel-based representation of the microstructure,</span>
<span class="sd">        including grain numbers, optional orientations, and mesh data. Metadata such</span>
<span class="sd">        as owner, system information, and script name are included.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        angles : np.ndarray, optional</span>
<span class="sd">            Array of Euler angles for grain orientations. If None, stored orientations</span>
<span class="sd">            are used if available. Default is None.</span>
<span class="sd">        script_name : str, optional</span>
<span class="sd">            Name of the script used to generate the microstructure. Default is the</span>
<span class="sd">            current script file.</span>
<span class="sd">        file : str, optional</span>
<span class="sd">            Name of the output JSON file. Default is based on microstructure name and</span>
<span class="sd">            number of grains.</span>
<span class="sd">        path : str, optional</span>
<span class="sd">            Directory path to save the JSON file. Default is current directory &#39;./&#39;.</span>
<span class="sd">        mesh : bool, optional</span>
<span class="sd">            Whether to include mesh nodes and voxel connectivity in the output. Default</span>
<span class="sd">            is True.</span>
<span class="sd">        source : Any, optional</span>
<span class="sd">            Optional input or source information to include in the JSON metadata.</span>
<span class="sd">        system : bool, optional</span>
<span class="sd">            Whether to include system information in the JSON metadata. Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            The function writes a JSON file and does not return any value.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">import</span><span class="w"> </span><span class="nn">platform</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">getpass</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">date</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">kanapy</span><span class="w"> </span><span class="kn">import</span> <span class="n">__version__</span>

        <span class="k">if</span> <span class="n">script_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">script_name</span> <span class="o">=</span> <span class="vm">__file__</span>
        <span class="k">if</span> <span class="n">file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;Microstructure&#39;</span><span class="p">:</span>
                <span class="n">file</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;px_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">Ngr</span><span class="si">}</span><span class="s1">grains_voxels.json&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_voxels.json&#39;</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Writing voxel information of microstructure to </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
        <span class="c1"># metadata</span>
        <span class="n">today</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">date</span><span class="o">.</span><span class="n">today</span><span class="p">())</span>  <span class="c1"># date</span>
        <span class="n">owner</span> <span class="o">=</span> <span class="n">getpass</span><span class="o">.</span><span class="n">getuser</span><span class="p">()</span>  <span class="c1"># username</span>
        <span class="n">sys_info</span> <span class="o">=</span> <span class="n">platform</span><span class="o">.</span><span class="n">uname</span><span class="p">()</span>  <span class="c1"># system information</span>
        <span class="c1"># output dict</span>
        <span class="n">structure</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;Info&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;Owner&quot;</span><span class="p">:</span> <span class="n">owner</span><span class="p">,</span>
                <span class="s2">&quot;Institution&quot;</span><span class="p">:</span> <span class="s2">&quot;ICAMS, Ruhr University Bochum, Germany&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Date&quot;</span><span class="p">:</span> <span class="n">today</span><span class="p">,</span>
                <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Voxels of microstructure&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Method&quot;</span><span class="p">:</span> <span class="s2">&quot;Synthetic microstructure generator Kanapy&quot;</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="s2">&quot;Model&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;Creator&quot;</span><span class="p">:</span> <span class="s2">&quot;kanapy&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Version&quot;</span><span class="p">:</span> <span class="n">__version__</span><span class="p">,</span>
                <span class="s2">&quot;Repository&quot;</span><span class="p">:</span> <span class="s2">&quot;https://github.com/ICAMS/Kanapy.git&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Input&quot;</span><span class="p">:</span> <span class="n">source</span><span class="p">,</span>
                <span class="s2">&quot;Script&quot;</span><span class="p">:</span> <span class="n">script_name</span><span class="p">,</span>
                <span class="s2">&quot;Material&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="s2">&quot;Phase_names&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">phase_names</span><span class="p">,</span>
                <span class="s2">&quot;Size&quot;</span><span class="p">:</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">size</span><span class="p">],</span>
                <span class="s2">&quot;Periodicity&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">periodic</span><span class="p">),</span>
                <span class="s2">&quot;Units&quot;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;Length&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">units</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">},</span>
            <span class="s2">&quot;Data&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s1">&#39;Grain numbers per voxel&#39;</span><span class="p">,</span>
                <span class="s2">&quot;Type&quot;</span><span class="p">:</span> <span class="s1">&#39;int&#39;</span><span class="p">,</span>
                <span class="s2">&quot;Shape&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span>
                <span class="s2">&quot;Order&quot;</span><span class="p">:</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span>
                <span class="s2">&quot;Values&quot;</span><span class="p">:</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grains</span><span class="o">.</span><span class="n">flatten</span><span class="p">()],</span>
            <span class="p">},</span>
            <span class="s2">&quot;Grains&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Grain-related data&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Orientation&quot;</span><span class="p">:</span> <span class="s2">&quot;Euler-Bunge angle&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Phase&quot;</span><span class="p">:</span> <span class="s2">&quot;Phase number&quot;</span>
            <span class="p">},</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">system</span><span class="p">:</span>
            <span class="n">structure</span><span class="p">[</span><span class="s2">&quot;Info&quot;</span><span class="p">][</span><span class="s2">&quot;System&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;sysname&quot;</span><span class="p">:</span> <span class="n">sys_info</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="s2">&quot;nodename&quot;</span><span class="p">:</span> <span class="n">sys_info</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="s2">&quot;release&quot;</span><span class="p">:</span> <span class="n">sys_info</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="s2">&quot;version&quot;</span><span class="p">:</span> <span class="n">sys_info</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                <span class="s2">&quot;machine&quot;</span><span class="p">:</span> <span class="n">sys_info</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
            <span class="p">}</span>
        <span class="k">for</span> <span class="n">igr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">structure</span><span class="p">[</span><span class="s2">&quot;Grains&quot;</span><span class="p">][</span><span class="nb">int</span><span class="p">(</span><span class="n">igr</span><span class="p">)]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;Phase&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grain_phase_dict</span><span class="p">[</span><span class="n">igr</span><span class="p">])</span>
            <span class="p">}</span>
        <span class="k">if</span> <span class="n">angles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grain_ori_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;No angles for grains are given. Writing only geometry of RVE.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">igr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grain_ori_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">structure</span><span class="p">[</span><span class="s2">&quot;Grains&quot;</span><span class="p">][</span><span class="n">igr</span><span class="p">][</span><span class="s2">&quot;Orientation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grain_ori_dict</span><span class="p">[</span><span class="n">igr</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">igr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">structure</span><span class="p">[</span><span class="s2">&quot;Grains&quot;</span><span class="p">][</span><span class="n">igr</span><span class="p">][</span><span class="s2">&quot;Orientation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">if</span> <span class="n">mesh</span><span class="p">:</span>
            <span class="n">structure</span><span class="p">[</span><span class="s1">&#39;Mesh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;Nodes&quot;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s1">&#39;Nodal coordinates&#39;</span><span class="p">,</span>
                    <span class="s2">&quot;Type&quot;</span><span class="p">:</span> <span class="s1">&#39;float&#39;</span><span class="p">,</span>
                    <span class="s2">&quot;Shape&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                    <span class="s2">&quot;Values&quot;</span><span class="p">:</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">],</span>
                <span class="p">},</span>
                <span class="s2">&quot;Voxels&quot;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s1">&#39;Node list per voxel&#39;</span><span class="p">,</span>
                    <span class="s2">&quot;Type&quot;</span><span class="p">:</span> <span class="s1">&#39;int&#39;</span><span class="p">,</span>
                    <span class="s2">&quot;Shape&quot;</span><span class="p">:</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">voxel_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="mi">8</span><span class="p">),</span>
                    <span class="s2">&quot;Values&quot;</span><span class="p">:</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">voxel_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()],</span>
                <span class="p">}</span>
            <span class="p">}</span>

        <span class="c1"># write file</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
            <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span>
        <span class="k">return</span></div>


<div class="viewcode-block" id="Microstructure.write_dataSchema">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.api.Microstructure.write_dataSchema">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_dataSchema</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                         <span class="n">user_metadata</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">boundary_condition</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">phases</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">interactive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                         <span class="n">structured</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                         <span class="n">ialloy</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                         <span class="n">length_unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;m&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a JSON-compatible data schema containing user, system, and job-specific elements</span>

<span class="sd">        This function builds a comprehensive data dictionary for a microstructure simulation,</span>
<span class="sd">        including metadata, boundary conditions, phase information, voxel and grain data.</span>
<span class="sd">        It supports interactive prompts for missing information, structured/unstructured meshes,</span>
<span class="sd">        and unit scaling.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        user_metadata : dict, optional</span>
<span class="sd">            Prefilled metadata fields; required if interactive=False. Default is None.</span>
<span class="sd">        boundary_condition : dict, optional</span>
<span class="sd">            Dictionary specifying mechanical or thermal boundary conditions. Default is None.</span>
<span class="sd">        phases : dict or list of dicts, optional</span>
<span class="sd">            Phase-specific information; if None, default material library and ialloy are used.</span>
<span class="sd">        interactive : bool, optional</span>
<span class="sd">            If True, prompt user for missing information. Default is True.</span>
<span class="sd">        structured : bool, optional</span>
<span class="sd">            Whether the mesh is structured. Default is True.</span>
<span class="sd">        ialloy : int, optional</span>
<span class="sd">            Alloy index for selecting material properties from the built-in library. Default is 1.</span>
<span class="sd">        length_unit : str, optional</span>
<span class="sd">            Unit for length scaling; either &#39;m&#39; or &#39;mm&#39;. Default is &#39;m&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            A nested dictionary containing the complete data schema for the simulation.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If interactive=False and required metadata fields or boundary conditions are missing,</span>
<span class="sd">            or if length_unit is invalid</span>
<span class="sd">        TypeError</span>
<span class="sd">            If `phases` is not a dict or a list of dicts when provided</span>
<span class="sd">        &quot;&quot;&quot;</span>


        <span class="c1"># interpret length_unit argument</span>
        <span class="k">if</span> <span class="n">length_unit</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
            <span class="n">length_scale</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">elif</span> <span class="n">length_unit</span> <span class="o">==</span> <span class="s1">&#39;mm&#39;</span><span class="p">:</span>
            <span class="n">length_scale</span> <span class="o">=</span> <span class="mf">1e-3</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;length_unit must be &#39;m&#39; or &#39;mm&#39;&quot;</span><span class="p">)</span>

        <span class="c1"># Material library definitions (pulled from mod_alloys.f)</span>
        <span class="n">material_library</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">1</span><span class="p">:</span> <span class="p">{</span>  <span class="c1"># Aluminum</span>
                <span class="s1">&#39;ialloy&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                <span class="s1">&#39;material_identifier&#39;</span><span class="p">:</span> <span class="s1">&#39;Aluminum&#39;</span><span class="p">,</span>
                <span class="s1">&#39;elastic_model_name&#39;</span><span class="p">:</span> <span class="s1">&#39;Anisotropic Elasticity&#39;</span><span class="p">,</span>
                <span class="s1">&#39;elastic_parameters&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;C11&#39;</span><span class="p">:</span> <span class="mf">247000.0</span><span class="p">,</span> <span class="s1">&#39;C12&#39;</span><span class="p">:</span> <span class="mf">147000.0</span><span class="p">,</span> <span class="s1">&#39;C44&#39;</span><span class="p">:</span> <span class="mf">125000.0</span>
                <span class="p">},</span>
                <span class="s1">&#39;plastic_model_name&#39;</span><span class="p">:</span> <span class="s1">&#39;Crystal Plasticity&#39;</span><span class="p">,</span>
                <span class="s1">&#39;plastic_parameters&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;reference_shear_rate&#39;</span><span class="p">:</span> <span class="mf">1e-6</span><span class="p">,</span>  <span class="c1"># shrt0</span>
                    <span class="s1">&#39;initial_critical_resolved_shear_stress&#39;</span><span class="p">:</span> <span class="mf">20.0</span><span class="p">,</span>  <span class="c1"># crss0</span>
                    <span class="s1">&#39;saturated_slip_resistance&#39;</span><span class="p">:</span> <span class="mf">1500.0</span><span class="p">,</span>  <span class="c1"># crsss</span>
                    <span class="s1">&#39;strain_rate_sensitivity_exponent&#39;</span><span class="p">:</span> <span class="mf">20.0</span><span class="p">,</span>  <span class="c1"># pwfl</span>
                    <span class="s1">&#39;reference_hardening_rate&#39;</span><span class="p">:</span> <span class="mf">60.0</span><span class="p">,</span>  <span class="c1"># hdrt0</span>
                    <span class="s1">&#39;hardening_exponent&#39;</span><span class="p">:</span> <span class="mf">2.25</span>  <span class="c1"># pwhd</span>
                <span class="p">}</span>
            <span class="p">},</span>
            <span class="mi">2</span><span class="p">:</span> <span class="p">{</span>  <span class="c1"># Copper</span>
                <span class="s1">&#39;ialloy&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
                <span class="s1">&#39;material_identifier&#39;</span><span class="p">:</span> <span class="s1">&#39;Copper&#39;</span><span class="p">,</span>
                <span class="s1">&#39;elastic_model_name&#39;</span><span class="p">:</span> <span class="s1">&#39;Anisotropic Elasticity&#39;</span><span class="p">,</span>
                <span class="s1">&#39;elastic_parameters&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;C11&#39;</span><span class="p">:</span> <span class="mf">170000.0</span><span class="p">,</span> <span class="s1">&#39;C12&#39;</span><span class="p">:</span> <span class="mf">124000.0</span><span class="p">,</span> <span class="s1">&#39;C44&#39;</span><span class="p">:</span> <span class="mf">75000.0</span>
                <span class="p">},</span>
                <span class="s1">&#39;plastic_model_name&#39;</span><span class="p">:</span> <span class="s1">&#39;Crystal Plasticity&#39;</span><span class="p">,</span>
                <span class="s1">&#39;plastic_parameters&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;reference_shear_rate&#39;</span><span class="p">:</span> <span class="mf">0.001</span><span class="p">,</span>  <span class="c1"># shrt0</span>
                    <span class="s1">&#39;initial_critical_resolved_shear_stress&#39;</span><span class="p">:</span> <span class="mf">16.0</span><span class="p">,</span>  <span class="c1"># crss0</span>
                    <span class="s1">&#39;saturated_slip_resistance&#39;</span><span class="p">:</span> <span class="mf">148.0</span><span class="p">,</span>  <span class="c1"># crsss</span>
                    <span class="s1">&#39;strain_rate_sensitivity_exponent&#39;</span><span class="p">:</span> <span class="mf">83.0</span><span class="p">,</span>  <span class="c1"># pwfl</span>
                    <span class="s1">&#39;reference_hardening_rate&#39;</span><span class="p">:</span> <span class="mf">250.0</span><span class="p">,</span>  <span class="c1"># hdrt0</span>
                    <span class="s1">&#39;hardening_exponent&#39;</span><span class="p">:</span> <span class="mf">2.25</span>  <span class="c1"># pwhd</span>
                <span class="p">}</span>
            <span class="p">},</span>
            <span class="mi">3</span><span class="p">:</span> <span class="p">{</span>  <span class="c1"># Ferrite</span>
                <span class="s1">&#39;ialloy&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
                <span class="s1">&#39;material_identifier&#39;</span><span class="p">:</span> <span class="s1">&#39;Ferrite&#39;</span><span class="p">,</span>
                <span class="s1">&#39;elastic_model_name&#39;</span><span class="p">:</span> <span class="s1">&#39;Anisotropic Elasticity&#39;</span><span class="p">,</span>
                <span class="s1">&#39;elastic_parameters&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;C11&#39;</span><span class="p">:</span> <span class="mf">230000.0</span><span class="p">,</span> <span class="s1">&#39;C12&#39;</span><span class="p">:</span> <span class="mf">135000.0</span><span class="p">,</span> <span class="s1">&#39;C44&#39;</span><span class="p">:</span> <span class="mf">116000.0</span>
                <span class="p">},</span>
                <span class="s1">&#39;plastic_model_name&#39;</span><span class="p">:</span> <span class="s1">&#39;Crystal Plasticity&#39;</span><span class="p">,</span>
                <span class="s1">&#39;plastic_parameters&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;reference_shear_rate&#39;</span><span class="p">:</span> <span class="mf">1e-6</span><span class="p">,</span>
                    <span class="s1">&#39;initial_critical_resolved_shear_stress&#39;</span><span class="p">:</span> <span class="mf">25.0</span><span class="p">,</span>
                    <span class="s1">&#39;saturated_slip_resistance&#39;</span><span class="p">:</span> <span class="mf">1600.0</span><span class="p">,</span>
                    <span class="s1">&#39;strain_rate_sensitivity_exponent&#39;</span><span class="p">:</span> <span class="mf">18.0</span><span class="p">,</span>
                    <span class="s1">&#39;reference_hardening_rate&#39;</span><span class="p">:</span> <span class="mf">70.0</span><span class="p">,</span>
                    <span class="s1">&#39;hardening_exponent&#39;</span><span class="p">:</span> <span class="mf">2.0</span>
                <span class="p">}</span>
            <span class="p">},</span>
            <span class="mi">4</span><span class="p">:</span> <span class="p">{</span>  <span class="c1"># Austenite</span>
                <span class="s1">&#39;ialloy&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
                <span class="s1">&#39;material_identifier&#39;</span><span class="p">:</span> <span class="s1">&#39;Austenite&#39;</span><span class="p">,</span>
                <span class="s1">&#39;elastic_model_name&#39;</span><span class="p">:</span> <span class="s1">&#39;Anisotropic Elasticity&#39;</span><span class="p">,</span>
                <span class="s1">&#39;elastic_parameters&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;C11&#39;</span><span class="p">:</span> <span class="mf">190000.0</span><span class="p">,</span> <span class="s1">&#39;C12&#39;</span><span class="p">:</span> <span class="mf">130000.0</span><span class="p">,</span> <span class="s1">&#39;C44&#39;</span><span class="p">:</span> <span class="mf">115000.0</span>
                <span class="p">},</span>
                <span class="s1">&#39;plastic_model_name&#39;</span><span class="p">:</span> <span class="s1">&#39;Crystal Plasticity&#39;</span><span class="p">,</span>
                <span class="s1">&#39;plastic_parameters&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;reference_shear_rate&#39;</span><span class="p">:</span> <span class="mf">1e-6</span><span class="p">,</span>
                    <span class="s1">&#39;initial_critical_resolved_shear_stress&#39;</span><span class="p">:</span> <span class="mf">15.0</span><span class="p">,</span>
                    <span class="s1">&#39;saturated_slip_resistance&#39;</span><span class="p">:</span> <span class="mf">1400.0</span><span class="p">,</span>
                    <span class="s1">&#39;strain_rate_sensitivity_exponent&#39;</span><span class="p">:</span> <span class="mf">22.0</span><span class="p">,</span>
                    <span class="s1">&#39;reference_hardening_rate&#39;</span><span class="p">:</span> <span class="mf">65.0</span><span class="p">,</span>
                    <span class="s1">&#39;hardening_exponent&#39;</span><span class="p">:</span> <span class="mf">2.2</span>
                <span class="p">}</span>
            <span class="p">},</span>
            <span class="mi">5</span><span class="p">:</span> <span class="p">{</span>  <span class="c1"># Superalloy</span>
                <span class="s1">&#39;ialloy&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
                <span class="s1">&#39;material_identifier&#39;</span><span class="p">:</span> <span class="s1">&#39;Superalloy&#39;</span><span class="p">,</span>
                <span class="s1">&#39;elastic_model_name&#39;</span><span class="p">:</span> <span class="s1">&#39;Anisotropic Elasticity&#39;</span><span class="p">,</span>
                <span class="s1">&#39;elastic_parameters&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;C11&#39;</span><span class="p">:</span> <span class="mf">260000.0</span><span class="p">,</span> <span class="s1">&#39;C12&#39;</span><span class="p">:</span> <span class="mf">150000.0</span><span class="p">,</span> <span class="s1">&#39;C44&#39;</span><span class="p">:</span> <span class="mf">120000.0</span>
                <span class="p">},</span>
                <span class="s1">&#39;plastic_model_name&#39;</span><span class="p">:</span> <span class="s1">&#39;Crystal Plasticity&#39;</span><span class="p">,</span>
                <span class="s1">&#39;plastic_parameters&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;reference_shear_rate&#39;</span><span class="p">:</span> <span class="mf">1e-6</span><span class="p">,</span>
                    <span class="s1">&#39;initial_critical_resolved_shear_stress&#39;</span><span class="p">:</span> <span class="mf">30.0</span><span class="p">,</span>
                    <span class="s1">&#39;saturated_slip_resistance&#39;</span><span class="p">:</span> <span class="mf">1700.0</span><span class="p">,</span>
                    <span class="s1">&#39;strain_rate_sensitivity_exponent&#39;</span><span class="p">:</span> <span class="mf">25.0</span><span class="p">,</span>
                    <span class="s1">&#39;reference_hardening_rate&#39;</span><span class="p">:</span> <span class="mf">80.0</span><span class="p">,</span>
                    <span class="s1">&#39;hardening_exponent&#39;</span><span class="p">:</span> <span class="mf">2.8</span>
                <span class="p">}</span>
            <span class="p">},</span>
            <span class="mi">6</span><span class="p">:</span> <span class="p">{</span>  <span class="c1"># Nickel</span>
                <span class="s1">&#39;ialloy&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
                <span class="s1">&#39;material_identifier&#39;</span><span class="p">:</span> <span class="s1">&#39;Nickel&#39;</span><span class="p">,</span>
                <span class="s1">&#39;elastic_model_name&#39;</span><span class="p">:</span> <span class="s1">&#39;Anisotropic Elasticity&#39;</span><span class="p">,</span>
                <span class="s1">&#39;elastic_parameters&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;C11&#39;</span><span class="p">:</span> <span class="mf">246000.0</span><span class="p">,</span> <span class="s1">&#39;C12&#39;</span><span class="p">:</span> <span class="mf">147000.0</span><span class="p">,</span> <span class="s1">&#39;C44&#39;</span><span class="p">:</span> <span class="mf">124000.0</span>
                <span class="p">},</span>
                <span class="s1">&#39;plastic_model_name&#39;</span><span class="p">:</span> <span class="s1">&#39;Crystal Plasticity&#39;</span><span class="p">,</span>
                <span class="s1">&#39;plastic_parameters&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;reference_shear_rate&#39;</span><span class="p">:</span> <span class="mf">1e-6</span><span class="p">,</span>
                    <span class="s1">&#39;initial_critical_resolved_shear_stress&#39;</span><span class="p">:</span> <span class="mf">18.0</span><span class="p">,</span>
                    <span class="s1">&#39;saturated_slip_resistance&#39;</span><span class="p">:</span> <span class="mf">1450.0</span><span class="p">,</span>
                    <span class="s1">&#39;strain_rate_sensitivity_exponent&#39;</span><span class="p">:</span> <span class="mf">20.0</span><span class="p">,</span>
                    <span class="s1">&#39;reference_hardening_rate&#39;</span><span class="p">:</span> <span class="mf">75.0</span><span class="p">,</span>
                    <span class="s1">&#39;hardening_exponent&#39;</span><span class="p">:</span> <span class="mf">2.4</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1"># Define required fields</span>
        <span class="n">required_fields</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s1">&#39;identifier&#39;</span><span class="p">,</span> <span class="s1">&#39;title&#39;</span><span class="p">,</span>
            <span class="s1">&#39;creator&#39;</span><span class="p">,</span> <span class="s1">&#39;creator_ORCID&#39;</span><span class="p">,</span> <span class="s1">&#39;creator_affiliation&#39;</span><span class="p">,</span> <span class="s1">&#39;creator_institute&#39;</span><span class="p">,</span> <span class="s1">&#39;creator_group&#39;</span><span class="p">,</span>
            <span class="s1">&#39;contributor&#39;</span><span class="p">,</span> <span class="s1">&#39;contributor_ORCID&#39;</span><span class="p">,</span> <span class="s1">&#39;contributor_affiliation&#39;</span><span class="p">,</span> <span class="s1">&#39;contributor_institute&#39;</span><span class="p">,</span> <span class="s1">&#39;contributor_group&#39;</span><span class="p">,</span>
            <span class="s1">&#39;date&#39;</span><span class="p">,</span> <span class="s1">&#39;shared_with&#39;</span><span class="p">,</span> <span class="s1">&#39;description&#39;</span><span class="p">,</span> <span class="s1">&#39;rights&#39;</span><span class="p">,</span> <span class="s1">&#39;rights_holder&#39;</span><span class="p">,</span><span class="s1">&#39;funder_name&#39;</span><span class="p">,</span> <span class="s1">&#39;fund_identifier&#39;</span><span class="p">,</span>
            <span class="s1">&#39;publisher&#39;</span><span class="p">,</span> <span class="s1">&#39;relation&#39;</span><span class="p">,</span> <span class="s1">&#39;keywords&#39;</span>
        <span class="p">]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">prompt_list</span><span class="p">(</span><span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Prompt the user to enter a comma-separated list of values</span>

<span class="sd">            This function requests user input for a given field name and splits</span>
<span class="sd">            the input string into a list of stripped strings. Returns an empty</span>
<span class="sd">            list if the input is blank.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            field_name : str</span>
<span class="sd">                Name of the field to prompt the user for</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            list of str</span>
<span class="sd">                List of values entered by the user, with leading/trailing whitespace removed</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Enter comma-separated </span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="s2">: &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vals</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)]</span> <span class="k">if</span> <span class="n">vals</span> <span class="k">else</span> <span class="p">[]</span>

        <span class="c1"># Gather metadata</span>
        <span class="k">if</span> <span class="n">interactive</span> <span class="ow">and</span> <span class="n">user_metadata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">use</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="c1"># identifier</span>
            <span class="n">ident</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;Identifier (leave blank to auto-generate): &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ident</span><span class="p">:</span>
                <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">utcnow</span><span class="p">()</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span>
                <span class="n">ident</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha256</span><span class="p">(</span><span class="n">now</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()[:</span><span class="mi">8</span><span class="p">]</span>
            <span class="n">use</span><span class="p">[</span><span class="s1">&#39;identifier&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ident</span>
            <span class="n">use</span><span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;Title: &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="c1"># creator fields</span>
            <span class="n">use</span><span class="p">[</span><span class="s1">&#39;creator&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prompt_list</span><span class="p">(</span><span class="s1">&#39;creator names (e.g. Last, First)&#39;</span><span class="p">)</span>
            <span class="n">use</span><span class="p">[</span><span class="s1">&#39;creator_ORCID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prompt_list</span><span class="p">(</span><span class="s1">&#39;creator ORCID(s)&#39;</span><span class="p">)</span>
            <span class="n">use</span><span class="p">[</span><span class="s1">&#39;creator_affiliation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prompt_list</span><span class="p">(</span><span class="s1">&#39;creator affiliations&#39;</span><span class="p">)</span>
            <span class="n">use</span><span class="p">[</span><span class="s1">&#39;creator_institute&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prompt_list</span><span class="p">(</span><span class="s1">&#39;creator institutes&#39;</span><span class="p">)</span>
            <span class="n">use</span><span class="p">[</span><span class="s1">&#39;creator_group&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prompt_list</span><span class="p">(</span><span class="s1">&#39;creator groups&#39;</span><span class="p">)</span>
            <span class="c1"># contributor fields</span>
            <span class="n">use</span><span class="p">[</span><span class="s1">&#39;contributor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prompt_list</span><span class="p">(</span><span class="s1">&#39;contributor names&#39;</span><span class="p">)</span>
            <span class="n">use</span><span class="p">[</span><span class="s1">&#39;contributor_ORCID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prompt_list</span><span class="p">(</span><span class="s1">&#39;contributor ORCID(s)&#39;</span><span class="p">)</span>
            <span class="n">use</span><span class="p">[</span><span class="s1">&#39;contributor_affiliation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prompt_list</span><span class="p">(</span><span class="s1">&#39;contributor affiliations&#39;</span><span class="p">)</span>
            <span class="n">use</span><span class="p">[</span><span class="s1">&#39;contributor_institute&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prompt_list</span><span class="p">(</span><span class="s1">&#39;contributor institutes&#39;</span><span class="p">)</span>
            <span class="n">use</span><span class="p">[</span><span class="s1">&#39;contributor_group&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prompt_list</span><span class="p">(</span><span class="s1">&#39;contributor groups&#39;</span><span class="p">)</span>

            <span class="n">use</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;Date (YYYY-MM-DD): &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="ow">or</span> <span class="n">datetime</span><span class="o">.</span><span class="n">utcnow</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="c1"># shared_with</span>
            <span class="n">shared</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Enter shared_with access entries. Valid types: c, u, g, all. Blank to stop.&quot;</span><span class="p">)</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">atype</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;  access_type: &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">atype</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">shared</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;access_type&#39;</span><span class="p">:</span> <span class="n">atype</span><span class="p">})</span>
            <span class="n">use</span><span class="p">[</span><span class="s1">&#39;shared_with&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">shared</span>
            <span class="n">use</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;Description: &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">use</span><span class="p">[</span><span class="s1">&#39;rights&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;Rights (e.g. Creative Commons Attribution 4.0 International): &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">use</span><span class="p">[</span><span class="s1">&#39;rights_holder&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prompt_list</span><span class="p">(</span><span class="s1">&#39;rights_holder&#39;</span><span class="p">)</span>
            <span class="c1"># other fields</span>
            <span class="n">use</span><span class="p">[</span><span class="s1">&#39;funder_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;Funder name: &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">use</span><span class="p">[</span><span class="s1">&#39;fund_identifier&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;Fund identifier: &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">use</span><span class="p">[</span><span class="s1">&#39;publisher&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;Publisher: &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">use</span><span class="p">[</span><span class="s1">&#39;relation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prompt_list</span><span class="p">(</span><span class="s1">&#39;relation (DOI or URL)&#39;</span><span class="p">)</span>
            <span class="n">use</span><span class="p">[</span><span class="s1">&#39;keywords&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prompt_list</span><span class="p">(</span><span class="s1">&#39;keywords&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">user_metadata</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;user_metadata must be provided when interactive is False.&quot;</span><span class="p">)</span>
            <span class="n">use</span> <span class="o">=</span> <span class="n">user_metadata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># Validate presence of required fields</span>
            <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">required_fields</span> <span class="k">if</span> <span class="n">f</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">use</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">missing</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Missing required metadata fields: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">missing</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">ig</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;RVE_size&#39;</span><span class="p">:</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">*</span> <span class="n">length_scale</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">size</span><span class="p">],</span>
            <span class="s1">&#39;RVE_continuity&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">periodic</span><span class="p">,</span>
            <span class="s1">&#39;discretization_type&#39;</span><span class="p">:</span> <span class="s1">&#39;Structured&#39;</span> <span class="k">if</span> <span class="n">structured</span> <span class="k">else</span> <span class="s1">&#39;Unstructured&#39;</span><span class="p">,</span>
            <span class="s1">&#39;discretization_unit_size&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="nb">float</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="o">*</span> <span class="n">length_scale</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">dim</span><span class="p">)],</span>
            <span class="s1">&#39;discretization_count&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nvox</span><span class="p">),</span>
            <span class="s1">&#39;global_rotation_convention&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(),</span>
            <span class="s1">&#39;Origin&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;software&#39;</span><span class="p">:</span> <span class="s1">&#39;kanapy&#39;</span><span class="p">,</span>
                <span class="s1">&#39;software_version&#39;</span><span class="p">:</span> <span class="n">pkg_version</span><span class="p">(</span><span class="s1">&#39;kanapy&#39;</span><span class="p">),</span>
                <span class="s1">&#39;system&#39;</span><span class="p">:</span> <span class="n">platform</span><span class="o">.</span><span class="n">system</span><span class="p">(),</span>
                <span class="s1">&#39;system_version&#39;</span><span class="p">:</span> <span class="n">platform</span><span class="o">.</span><span class="n">version</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">#  Show vertexdiagram for BC reference </span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># locate the package root, two levels up from this file</span>
            <span class="n">script_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span>
            <span class="n">project_root</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">script_dir</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">pardir</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">pardir</span><span class="p">))</span>
            <span class="n">img_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">project_root</span><span class="p">,</span> <span class="s1">&#39;docs&#39;</span><span class="p">,</span> <span class="s1">&#39;figs&#39;</span><span class="p">,</span> <span class="s1">&#39;RVE&#39;</span><span class="p">,</span> <span class="s1">&#39;Vertices.png&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">img_path</span><span class="p">):</span>
                <span class="c1"># first try with Pillow</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="kn">from</span><span class="w"> </span><span class="nn">PIL</span><span class="w"> </span><span class="kn">import</span> <span class="n">Image</span>
                    <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">img_path</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
                <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                    <span class="c1"># fallback to the system browser/viewer</span>
                    <span class="kn">import</span><span class="w"> </span><span class="nn">webbrowser</span>
                    <span class="n">webbrowser</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;file://</span><span class="si">{</span><span class="n">img_path</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">FileNotFoundError</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Warning] Unable to open Vertices.png: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Boundary conditions</span>
        <span class="k">if</span> <span class="n">boundary_condition</span><span class="p">:</span>
            <span class="c1"># Ensure &#39;type&#39; is present</span>
            <span class="k">if</span> <span class="s1">&#39;mechanical_BC&#39;</span> <span class="ow">in</span> <span class="n">boundary_condition</span><span class="p">:</span>
                <span class="c1"># Determine mechanical vs thermal by key presence</span>
                <span class="n">mech_list</span> <span class="o">=</span> <span class="n">boundary_condition</span><span class="p">[</span><span class="s1">&#39;mechanical_BC&#39;</span><span class="p">]</span>
                <span class="c1"># Normalize to list</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mech_list</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">mech_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">mech_list</span><span class="p">]</span>
                <span class="n">job_bc</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mechanical_BC&#39;</span><span class="p">:</span> <span class="n">mech_list</span><span class="p">}</span>
            <span class="k">elif</span> <span class="s1">&#39;thermal_BC&#39;</span> <span class="ow">in</span> <span class="n">boundary_condition</span><span class="p">:</span>
                <span class="n">th_list</span> <span class="o">=</span> <span class="n">boundary_condition</span><span class="p">[</span><span class="s1">&#39;thermal_BC&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">th_list</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">th_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">th_list</span><span class="p">]</span>
                <span class="n">job_bc</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;thermal_BC&#39;</span><span class="p">:</span> <span class="n">th_list</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># fallback if wrong keys provided</span>
                <span class="k">if</span> <span class="n">interactive</span><span class="p">:</span>
                    <span class="c1"># ask user which type to populate</span>
                    <span class="n">bc_choice</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;Boundary condition key not found. Enter &#39;mechanical&#39; or &#39;thermal&#39;: &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">bc_choice</span> <span class="o">==</span> <span class="s1">&#39;mechanical&#39;</span><span class="p">:</span>
                        <span class="n">job_bc</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mechanical_BC&#39;</span><span class="p">:</span> <span class="p">[]}</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">job_bc</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;thermal_BC&#39;</span><span class="p">:</span> <span class="p">{}}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;boundary_condition dict must include &#39;mechanical_BC&#39; or &#39;thermal_BC&#39; key when interactive=False.&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">interactive</span><span class="p">:</span> <span class="c1"># Interactive entry of multiple mechanical BCs</span>
            <span class="n">mech_entries</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">bc_type</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;Boundary condition type (&#39;mechanical&#39; or &#39;thermal&#39;): &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">bc_type</span> <span class="o">==</span> <span class="s1">&#39;mechanical&#39;</span><span class="p">:</span>
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Define a mechanical BC (leave vertex_list blank to stop):&quot;</span><span class="p">)</span>
                    <span class="n">vertex_list</span> <span class="o">=</span> <span class="n">prompt_list</span><span class="p">(</span><span class="s1">&#39;vertex_list&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">vertex_list</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="n">constraints</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;Constraints xyz (e.g. &#39;free,fixed,loaded&#39;): &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
                    <span class="n">loading_type</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;Loading type (force/displacement/stress/strain/none): &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                    <span class="n">loading_mode</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;Loading mode (static/cyclic/monotonic/intermittent): &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                    <span class="c1"># count how many of those constraints are loaded:</span>
                    <span class="n">num</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">constraints</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;loaded&#39;</span><span class="p">)</span>
                    <span class="n">loads</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Load entry #</span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>
                        <span class="n">mag</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s2">&quot;  magnitude: &quot;</span><span class="p">))</span>
                        <span class="n">freq</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s2">&quot;  frequency: &quot;</span><span class="p">))</span>
                        <span class="n">dur</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s2">&quot;  duration: &quot;</span><span class="p">))</span>
                        <span class="n">R</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s2">&quot;  R: &quot;</span><span class="p">))</span>
                        <span class="n">loads</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;magnitude&#39;</span><span class="p">:</span> <span class="n">mag</span><span class="p">,</span> <span class="s1">&#39;frequency&#39;</span><span class="p">:</span> <span class="n">freq</span><span class="p">,</span> <span class="s1">&#39;duration&#39;</span><span class="p">:</span> <span class="n">dur</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">:</span> <span class="n">R</span><span class="p">})</span>
                    <span class="n">mech_entries</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                        <span class="s1">&#39;vertex_list&#39;</span><span class="p">:</span> <span class="n">vertex_list</span><span class="p">,</span>
                        <span class="s1">&#39;constraints&#39;</span><span class="p">:</span> <span class="n">constraints</span><span class="p">,</span>
                        <span class="s1">&#39;loading_type&#39;</span><span class="p">:</span> <span class="n">loading_type</span><span class="p">,</span>
                        <span class="s1">&#39;loading_mode&#39;</span><span class="p">:</span> <span class="n">loading_mode</span><span class="p">,</span>
                        <span class="s1">&#39;applied_load&#39;</span><span class="p">:</span> <span class="n">loads</span>
                    <span class="p">})</span>
                <span class="n">job_bc</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mechanical_BC&#39;</span><span class="p">:</span> <span class="n">mech_entries</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">job_bc</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;thermal_BC&#39;</span><span class="p">:</span> <span class="p">{}}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">job_bc</span> <span class="o">=</span> <span class="p">{}</span>


        <span class="c1"># Phase data</span>
        <span class="n">phase_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">phases</span><span class="p">:</span>  <span class="c1"># user provided a dict or list of dicts</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">phases</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">phase_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">phases</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">phases</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">phase_list</span> <span class="o">=</span> <span class="n">phases</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`phases` must be a dict or list of dicts.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># fallback: use ialloy + material_library</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ialloy</span> <span class="ow">or</span> <span class="n">ialloy</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">material_library</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">interactive</span><span class="p">:</span>
                    <span class="n">ialloy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Choose ialloy from </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">material_library</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">: &quot;</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;No phases provided and invalid ialloy. &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Valid ialloy values: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">material_library</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nphases</span><span class="p">):</span>
                <span class="n">phase_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">phase_names</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">vf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="o">.</span><span class="n">phase_vf</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">material_library</span><span class="p">[</span><span class="n">ialloy</span><span class="p">]</span>
                <span class="n">pe</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="s1">&#39;elastic_parameters&#39;</span><span class="p">]</span>
                <span class="n">pp</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="s1">&#39;plastic_parameters&#39;</span><span class="p">]</span>

                <span class="n">phase_entry</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">idx</span><span class="p">,</span>
                    <span class="s2">&quot;phase_identifier&quot;</span><span class="p">:</span> <span class="n">phase_name</span><span class="p">,</span>
                    <span class="s2">&quot;constitutive_model&quot;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="s2">&quot;$schema&quot;</span><span class="p">:</span> <span class="s2">&quot;http://json-schema.org/draft-04/schema#&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;elastic_model_name&quot;</span><span class="p">:</span> <span class="n">mat</span><span class="p">[</span><span class="s1">&#39;elastic_model_name&#39;</span><span class="p">],</span>
                        <span class="s2">&quot;elastic_parameters&quot;</span><span class="p">:</span> <span class="n">pe</span><span class="p">,</span>
                        <span class="s2">&quot;plastic_model_name&quot;</span><span class="p">:</span> <span class="n">mat</span><span class="p">[</span><span class="s1">&#39;plastic_model_name&#39;</span><span class="p">],</span>
                        <span class="s2">&quot;plastic_parameters&quot;</span><span class="p">:</span> <span class="n">pp</span>
                    <span class="p">},</span>
                    <span class="s2">&quot;microstructural_information&quot;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="s2">&quot;phase_volume_fraction&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">vf</span><span class="p">),</span>
                        <span class="s2">&quot;grain_count&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ngrains</span><span class="p">[</span><span class="n">idx</span><span class="p">]),</span>
                        <span class="s2">&quot;texture_type&quot;</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;texture&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                        <span class="s2">&quot;lattice_structure&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="n">phase_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">phase_entry</span><span class="p">)</span>

        <span class="c1">#  pull Mesh + RVE into locals </span>
        <span class="n">grain_phase_dict</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;grain_phase_dict&#39;</span><span class="p">,</span> <span class="p">{})</span> <span class="ow">or</span> <span class="p">{}</span> <span class="c1"># {gid: phase_id}</span>
        <span class="n">grain_ori_dict</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;grain_ori_dict&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># can be None ({gid: [euler]})</span>
        <span class="n">vox_center_dict</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;vox_center_dict&#39;</span><span class="p">,</span> <span class="p">{})</span> <span class="ow">or</span> <span class="p">{}</span> <span class="c1"># {vid: (x,y,z)}</span>
        <span class="n">grain_to_voxels</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;grain_dict&#39;</span><span class="p">,</span> <span class="p">{})</span> <span class="ow">or</span> <span class="p">{}</span> <span class="c1"># {gid: [vid,]}</span>
        <span class="n">rve_size</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="c1"># e.g. [20.0,20.0,20.0]</span>
        <span class="n">rve_dim</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rve</span><span class="p">,</span> <span class="s1">&#39;dim&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="ow">or</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># # e.g. [10,10,10] (avoid /0)</span>

        <span class="c1"># Is orientation available?</span>
        <span class="n">include_orientation</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grain_ori_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">grain_ori_dict</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="c1">#  compute onevoxel volume </span>
        <span class="n">unit_sizes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rve_size</span><span class="p">,</span> <span class="n">rve_dim</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">unit_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">float</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="o">*</span> <span class="n">length_scale</span> <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">unit_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>

        <span class="n">voxel_volume</span> <span class="o">=</span> <span class="p">(</span><span class="n">unit_sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unit_sizes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">0.0</span><span class="p">)</span> \
                       <span class="o">*</span> <span class="p">(</span><span class="n">unit_sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unit_sizes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="mf">0.0</span><span class="p">)</span> \
                       <span class="o">*</span> <span class="p">(</span><span class="n">unit_sizes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unit_sizes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="k">else</span> <span class="mf">0.0</span><span class="p">)</span>

        <span class="c1"># grid size per axis</span>
        <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nz</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">rve_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">rve_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">rve_dim</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="c1"># infer origin from centers if available: origin = min(center) - 0.5*unit</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vox_center_dict</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span> <span class="n">length_scale</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">vox_center_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
            <span class="n">ys</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span> <span class="n">length_scale</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">vox_center_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
            <span class="n">zs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span> <span class="n">length_scale</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">vox_center_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
            <span class="n">ox</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="k">if</span> <span class="n">xs</span> <span class="k">else</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">unit_sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">oy</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span> <span class="k">if</span> <span class="n">ys</span> <span class="k">else</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">unit_sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">oz</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">zs</span><span class="p">)</span> <span class="k">if</span> <span class="n">zs</span> <span class="k">else</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">unit_sizes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ox</span> <span class="o">=</span> <span class="n">oy</span> <span class="o">=</span> <span class="n">oz</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="p">[</span><span class="n">ox</span><span class="p">,</span> <span class="n">oy</span><span class="p">,</span> <span class="n">oz</span><span class="p">]</span>

        <span class="c1">#  precompute voxelgrain lookup </span>
        <span class="n">voxel_to_grain</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">vid</span><span class="p">:</span> <span class="n">gid</span>
            <span class="k">for</span> <span class="n">gid</span><span class="p">,</span> <span class="n">vids</span> <span class="ow">in</span> <span class="n">grain_to_voxels</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">vid</span> <span class="ow">in</span> <span class="n">vids</span>
        <span class="p">}</span>
        <span class="c1">#  build time0 grain dict </span>
        <span class="n">grains_t0</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">gid</span> <span class="ow">in</span> <span class="n">grain_phase_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;grain_id&quot;</span><span class="p">:</span> <span class="n">gid</span><span class="p">,</span>
                <span class="s2">&quot;phase_id&quot;</span><span class="p">:</span> <span class="n">grain_phase_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">gid</span><span class="p">),</span>
                <span class="s2">&quot;grain_volume&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">grain_to_voxels</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">gid</span><span class="p">,</span> <span class="p">[]))</span> <span class="o">*</span> <span class="n">voxel_volume</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">include_orientation</span><span class="p">:</span>
                <span class="n">ori</span> <span class="o">=</span> <span class="n">grain_ori_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">gid</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ori</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">entry</span><span class="p">[</span><span class="s2">&quot;orientation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ori</span><span class="p">)</span>
            <span class="n">grains_t0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
        <span class="n">grains_t0_sorted</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">grains_t0</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;grain_id&quot;</span><span class="p">]))</span>

        <span class="c1">#  Build time0 voxel dictionary </span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_coord_to_index_1based</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Convert a coordinate to a 1-based voxel index</span>

<span class="sd">            This function computes the voxel index corresponding to a coordinate `c`,</span>
<span class="sd">            given the origin `o` and voxel size `d`. The result is rounded and adjusted</span>
<span class="sd">            to be 1-based, robust to small floating-point errors.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            c : float</span>
<span class="sd">                Coordinate value</span>
<span class="sd">            o : float</span>
<span class="sd">                Origin coordinate of the voxel grid</span>
<span class="sd">            d : float</span>
<span class="sd">                Size of a voxel along the corresponding axis</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            int</span>
<span class="sd">                1-based voxel index corresponding to the coordinate</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># i = round((c - o)/d + 0.5), robust to tiny float noise</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="nb">float</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="nb">float</span><span class="p">(</span><span class="n">o</span><span class="p">))</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">))</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_clamp</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Clamp a value between a lower and upper bound</span>

<span class="sd">            This function ensures that the input value `v` lies within the range</span>
<span class="sd">            [`lo`, `hi`]. Values below `lo` are set to `lo`, and values above `hi`</span>
<span class="sd">            are set to `hi`.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            v : float</span>
<span class="sd">                Value to be clamped</span>
<span class="sd">            lo : float</span>
<span class="sd">                Lower bound</span>
<span class="sd">            hi : float</span>
<span class="sd">                Upper bound</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            float</span>
<span class="sd">                The clamped value within the specified bounds</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>

        <span class="n">voxels_t0</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">vid</span><span class="p">,</span> <span class="n">gid</span> <span class="ow">in</span> <span class="n">voxel_to_grain</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span> <span class="o">=</span> <span class="n">vox_center_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">vid</span><span class="p">,</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
            <span class="n">centroid</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">cx</span><span class="p">)</span> <span class="o">*</span> <span class="n">length_scale</span><span class="p">,</span>
                        <span class="nb">float</span><span class="p">(</span><span class="n">cy</span><span class="p">)</span> <span class="o">*</span> <span class="n">length_scale</span><span class="p">,</span>
                        <span class="nb">float</span><span class="p">(</span><span class="n">cz</span><span class="p">)</span> <span class="o">*</span> <span class="n">length_scale</span><span class="p">]</span>

            <span class="c1"># Compute 1-based voxel indices from centers</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="n">_coord_to_index_1based</span><span class="p">(</span><span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">unit_sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">iy</span> <span class="o">=</span> <span class="n">_coord_to_index_1based</span><span class="p">(</span><span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">origin</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">unit_sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">iz</span> <span class="o">=</span> <span class="n">_coord_to_index_1based</span><span class="p">(</span><span class="n">centroid</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">origin</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">unit_sizes</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

            <span class="c1"># Clamp to valid range [1..N*]</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="n">_clamp</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">)</span>
            <span class="n">iy</span> <span class="o">=</span> <span class="n">_clamp</span><span class="p">(</span><span class="n">iy</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Ny</span><span class="p">)</span>
            <span class="n">iz</span> <span class="o">=</span> <span class="n">_clamp</span><span class="p">(</span><span class="n">iz</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Nz</span><span class="p">)</span>


            <span class="n">entry</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;voxel_id&quot;</span><span class="p">:</span> <span class="n">vid</span><span class="p">,</span>
                <span class="s2">&quot;grain_id&quot;</span><span class="p">:</span> <span class="n">gid</span><span class="p">,</span>
                <span class="s2">&quot;centroid_coordinates&quot;</span><span class="p">:</span> <span class="n">centroid</span><span class="p">,</span> <span class="c1"># scaled for output</span>
                <span class="s2">&quot;voxel_index&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iz</span><span class="p">],</span> <span class="c1"># 1-based indices</span>
                <span class="s2">&quot;voxel_volume&quot;</span><span class="p">:</span> <span class="n">voxel_volume</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">include_orientation</span><span class="p">:</span>
                <span class="n">ori</span> <span class="o">=</span> <span class="n">grain_ori_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">gid</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ori</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">entry</span><span class="p">[</span><span class="s2">&quot;orientation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ori</span><span class="p">)</span>
            <span class="n">voxels_t0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
        <span class="n">voxels_t0_sorted</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">voxels_t0</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;voxel_id&quot;</span><span class="p">]))</span>

        <span class="c1">#  wrap under the timestep keys </span>
        <span class="n">time_steps</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">{</span>   <span class="s2">&quot;time&quot;</span>  <span class="p">:</span> <span class="mi">0</span>        <span class="p">,</span>
                <span class="s2">&quot;grains&quot;</span><span class="p">:</span> <span class="n">grains_t0_sorted</span><span class="p">,</span>
                <span class="s2">&quot;voxels&quot;</span><span class="p">:</span> <span class="n">voxels_t0_sorted</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="c1"># etc</span>
        <span class="p">]</span>



        <span class="c1"># Assemble final structure with placeholders</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="o">**</span><span class="n">use</span><span class="p">,</span>                   <span class="c1"># expand user-specific dict entries directly</span>
            <span class="s1">&#39;software&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;software_version&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;system&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;system_version&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;processor_specifications&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;input_path&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;results_path&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
            <span class="o">**</span><span class="n">ig</span><span class="p">,</span>                    <span class="c1"># expand initial geometry dict entries directly</span>
            <span class="s1">&#39;global_temperature&#39;</span><span class="p">:</span> <span class="mi">298</span><span class="p">,</span>
            <span class="o">**</span><span class="n">job_bc</span><span class="p">,</span>                 <span class="c1"># expand boundary condition dict entries directly</span>
            <span class="s1">&#39;phases&#39;</span><span class="p">:</span><span class="n">phase_list</span><span class="p">,</span>
            <span class="s1">&#39;microstructure_evolution&#39;</span><span class="p">:</span>  <span class="n">time_steps</span>  <span class="c1"># Time-level storage: time-frame data of voxels and grains</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">data</span></div>






<div class="viewcode-block" id="Microstructure.pckl">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.api.Microstructure.pckl">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">pckl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s1">&#39;./&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the microstructure into a pickle file</span>

<span class="sd">        This function serializes the microstructure object using pickle, allowing</span>
<span class="sd">        complex structures to be stored and later reloaded.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file : str, optional</span>
<span class="sd">            File name for the pickled microstructure. If None, the filename defaults</span>
<span class="sd">            to the microstructure name plus &#39;.pckl&#39;.</span>
<span class="sd">        path : str, optional</span>
<span class="sd">            Directory path to save the pickle file. Default is current directory &#39;./&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">pickle</span>

        <span class="k">if</span> <span class="n">file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;Microstructure&#39;</span><span class="p">:</span>
                <span class="n">file</span> <span class="o">=</span> <span class="s1">&#39;px_</span><span class="si">{}</span><span class="s1">grains_microstructure.pckl&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ngr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_microstructure.pckl&#39;</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>
        <span class="k">return</span></div>


<div class="viewcode-block" id="Microstructure.import_particles">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.api.Microstructure.import_particles">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">import_particles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s1">&#39;./&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Import particle data from a dump file</span>

<span class="sd">        This function reads particle information from a specified dump file and</span>
<span class="sd">        stores it in the microstructure object, updating the simulation box and</span>
<span class="sd">        particle list.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file : str</span>
<span class="sd">            Name of the input dump file containing particle data</span>
<span class="sd">        path : str, optional</span>
<span class="sd">            Directory path where the dump file is located. Default is current directory &#39;./&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            Updates the object&#39;s simbox and particles attributes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simbox</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">particles</span> <span class="o">=</span> <span class="n">read_dump</span><span class="p">(</span><span class="n">file</span><span class="p">)</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    --------        legacy methods        --------</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Microstructure.init_stats">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.api.Microstructure.init_stats">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">init_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">descriptor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gs_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ar_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">porous</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">save_files</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Legacy function that redirects to plot_stats_init</span>

<span class="sd">        This function is deprecated and serves as a wrapper for `plot_stats_init`.</span>
<span class="sd">        A warning is logged advising users to use `plot_stats_init` directly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        descriptor : Any, optional</span>
<span class="sd">            Descriptor data passed to `plot_stats_init`. Default is None.</span>
<span class="sd">        gs_data : Any, optional</span>
<span class="sd">            Grain size data passed to `plot_stats_init`. Default is None.</span>
<span class="sd">        ar_data : Any, optional</span>
<span class="sd">            Aspect ratio data passed to `plot_stats_init`. Default is None.</span>
<span class="sd">        porous : bool, optional</span>
<span class="sd">            Deprecated parameter, ignored. Default is False.</span>
<span class="sd">        save_files : bool, optional</span>
<span class="sd">            Whether to save generated statistics files. Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            Calls `plot_stats_init` and does not return any value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;&quot;init_stats&quot; is a legacy function and will be depracted, please use &quot;plot_stats_init()&quot;.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_stats_init</span><span class="p">(</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">gs_data</span><span class="o">=</span><span class="n">gs_data</span><span class="p">,</span> <span class="n">ar_data</span><span class="o">=</span><span class="n">ar_data</span><span class="p">,</span> <span class="n">save_files</span><span class="o">=</span><span class="n">save_files</span><span class="p">)</span></div>


<div class="viewcode-block" id="Microstructure.output_abq">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.api.Microstructure.output_abq">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">output_abq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">voxel_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">grain_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">faces</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">dual_phase</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">thermal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Legacy function that redirects to write_abq</span>

<span class="sd">        This function is deprecated and serves as a wrapper for `write_abq`.</span>
<span class="sd">        Warnings are logged advising users to use `write_abq` directly. The `faces`</span>
<span class="sd">        parameter is determined automatically if provided.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes : array-like, optional</span>
<span class="sd">            Nodal coordinates to include in the output. Default is None.</span>
<span class="sd">        name : str, optional</span>
<span class="sd">            File name for the Abaqus input file. Default is None.</span>
<span class="sd">        voxel_dict : dict, optional</span>
<span class="sd">            Voxel connectivity information. Default is None.</span>
<span class="sd">        grain_dict : dict, optional</span>
<span class="sd">            Grain-to-voxel mapping. Default is None.</span>
<span class="sd">        faces : Any, optional</span>
<span class="sd">            Deprecated parameter, automatically determined. Default is None.</span>
<span class="sd">        dual_phase : bool, optional</span>
<span class="sd">            Whether to include dual-phase data. Default is False.</span>
<span class="sd">        thermal : bool, optional</span>
<span class="sd">            Whether to include thermal data. Default is False.</span>
<span class="sd">        units : dict, optional</span>
<span class="sd">            Dictionary of units for the Abaqus model. Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            Calls `write_abq` and does not return any value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;&quot;output_abq&quot; is a legacy function and will be depracted, please use &quot;write_abq()&quot;.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">faces</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Parameter &quot;faces&quot; will be determined automatically.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_abq</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">voxel_dict</span><span class="o">=</span><span class="n">voxel_dict</span><span class="p">,</span> <span class="n">grain_dict</span><span class="o">=</span><span class="n">grain_dict</span><span class="p">,</span>
                       <span class="n">dual_phase</span><span class="o">=</span><span class="n">dual_phase</span><span class="p">,</span> <span class="n">thermal</span><span class="o">=</span><span class="n">thermal</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="n">units</span><span class="p">)</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright This work is published under a CC BY-SA 4.0 license.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>