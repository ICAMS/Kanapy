

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>kanapy.core.voxelization &mdash; kanapy 6.5.3.post1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=53ab5b41"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            kanapy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../applications.html">Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../method.html">Modeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kanapy.html">Code documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../history.html">History</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">kanapy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">kanapy.core.voxelization</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for kanapy.core.voxelization</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">copy</span><span class="w"> </span><span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">ConvexHull</span>


<div class="viewcode-block" id="points_in_convexHull">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.voxelization.points_in_convexHull">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">points_in_convexHull</span><span class="p">(</span><span class="n">Points</span><span class="p">,</span> <span class="n">hull</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine whether the given array of points lie inside the convex hull</span>

<span class="sd">    Checks if each point in `Points` is inside or outside the convex hull defined</span>
<span class="sd">    by `hull`. Returns a boolean array with True for points inside the hull and False otherwise.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Points : ndarray, shape (N_points, dim)</span>
<span class="sd">        Array of points to be tested</span>
<span class="sd">    hull : scipy.spatial.ConvexHull</span>
<span class="sd">        Convex hull object representing an ellipsoid or other shape</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray, shape (N_points,)</span>
<span class="sd">        Boolean array indicating whether each point is inside the convex hull</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    https://stackoverflow.com/questions/21698630/how-can-i-find-if-a-point-lies-inside-or-outside-of-convexhull</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">hull</span><span class="o">.</span><span class="n">equations</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">hull</span><span class="o">.</span><span class="n">equations</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">((</span><span class="n">A</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">Points</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">Points</span><span class="p">))),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>



<div class="viewcode-block" id="assign_voxels_to_ellipsoid">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.voxelization.assign_voxels_to_ellipsoid">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">assign_voxels_to_ellipsoid</span><span class="p">(</span><span class="n">cooDict</span><span class="p">,</span> <span class="n">Ellipsoids</span><span class="p">,</span> <span class="n">voxel_dict</span><span class="p">,</span> <span class="n">vf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assign voxels to each ellipsoid based on spatial position and shared nodes</span>

<span class="sd">    Iteratively grows each ellipsoid and assigns voxels whose centers lie</span>
<span class="sd">    within the ellipsoid&#39;s convex hull. Voxels are additionally checked</span>
<span class="sd">    to share at least 4 nodes with existing voxels of the ellipsoid to</span>
<span class="sd">    ensure connectivity.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cooDict : dict</span>
<span class="sd">        Voxel dictionary containing voxel IDs as keys and center coordinates</span>
<span class="sd">        as values</span>
<span class="sd">    Ellipsoids : list</span>
<span class="sd">        List of ellipsoid objects from the packing routine. Each object must</span>
<span class="sd">        support `.a`, `.b`, `.c` attributes and `.surfacePointsGen()` and `.get_pos()` methods</span>
<span class="sd">    voxel_dict : dict</span>
<span class="sd">        Element dictionary containing voxel IDs as keys and lists of nodal</span>
<span class="sd">        connectivity as values</span>
<span class="sd">    vf_target : float, optional</span>
<span class="sd">        Target volume fraction of particles to be assigned (default is 1.0)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    Assigning voxels to grains&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">vf_target</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">vf_target</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="n">vf_target</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="c1"># All the voxel centers as numpy 2D array and voxel ids</span>
    <span class="n">test_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">cooDict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="n">Nvox</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">test_ids</span><span class="p">)</span>
    <span class="n">test_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">cooDict</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

    <span class="c1"># scale factor for defining ellipsoid growth for each stage of while loop</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">remaining_voxels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">cooDict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="n">assigned_voxels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">vf_cur</span> <span class="o">=</span> <span class="mf">0.</span>

    <span class="c1"># Initialize a tqdm progress bar to the Number of voxels in the domain</span>
    <span class="n">pbar</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">remaining_voxels</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">ellipsoid</span> <span class="ow">in</span> <span class="n">Ellipsoids</span><span class="p">:</span>
        <span class="n">ellipsoid</span><span class="o">.</span><span class="n">inside_voxels</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">while</span> <span class="n">vf_cur</span> <span class="o">&lt;</span> <span class="n">vf_target</span><span class="p">:</span>
        <span class="c1"># call the growth value for the ellipsoids</span>
        <span class="n">scale</span> <span class="o">+=</span> <span class="mf">0.1</span>
        <span class="k">for</span> <span class="n">ellipsoid</span> <span class="ow">in</span> <span class="n">Ellipsoids</span><span class="p">:</span>
            <span class="c1"># scale ellipsoid dimensions by the growth factor and generate surface points</span>
            <span class="n">ellipsoid</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">c</span>
            <span class="n">surface_points</span> <span class="o">=</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">surfacePointsGen</span><span class="p">()</span>
            <span class="c1"># Find the new surface points of the ellipsoid at their final position</span>
            <span class="n">new_surfPts</span> <span class="o">=</span> <span class="n">surface_points</span> <span class="o">+</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">get_pos</span><span class="p">()</span>

            <span class="c1"># create a convex hull from the surface points</span>
            <span class="n">hull</span> <span class="o">=</span> <span class="n">ConvexHull</span><span class="p">(</span><span class="n">new_surfPts</span><span class="p">,</span> <span class="n">incremental</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1"># Find the bounding box extrema along x, y, and z</span>
            <span class="n">bbox_xmin</span><span class="p">,</span> <span class="n">bbox_xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">new_surfPts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">new_surfPts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">bbox_ymin</span><span class="p">,</span> <span class="n">bbox_ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">new_surfPts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">new_surfPts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">bbox_zmin</span><span class="p">,</span> <span class="n">bbox_zmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">new_surfPts</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">new_surfPts</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>

            <span class="c1"># Find the numpy indices of all voxels within the bounding box</span>
            <span class="n">in_bbox_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">test_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">bbox_xmin</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">test_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">bbox_xmax</span><span class="p">)</span>
                                   <span class="o">&amp;</span> <span class="p">(</span><span class="n">test_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">bbox_ymin</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">test_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">bbox_ymax</span><span class="p">)</span>
                                   <span class="o">&amp;</span> <span class="p">(</span><span class="n">test_points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">bbox_zmin</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">test_points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">bbox_zmax</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># extract the actual voxel ids and coordinates from the reduced numpy indices</span>
            <span class="n">bbox_testids</span> <span class="o">=</span> <span class="n">test_ids</span><span class="p">[</span><span class="n">in_bbox_idx</span><span class="p">]</span>  <span class="c1"># voxels ids</span>
            <span class="n">bbox_testPts</span> <span class="o">=</span> <span class="n">test_points</span><span class="p">[</span><span class="n">in_bbox_idx</span><span class="p">]</span>  <span class="c1"># coordinates</span>

            <span class="c1"># check if the extracted points are within the hull</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">points_in_convexHull</span><span class="p">(</span><span class="n">bbox_testPts</span><span class="p">,</span> <span class="n">hull</span><span class="p">)</span>

            <span class="c1"># Extract the voxel ids inside the hull</span>
            <span class="n">inside_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">bbox_testids</span><span class="p">[</span><span class="n">results</span><span class="p">])</span>

            <span class="c1"># Check if the newly found voxels share at least 4 nodes with</span>
            <span class="c1"># ellipsoid nodes</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">):</span>
                <span class="c1"># Extract single instance of all nodes currently belonging</span>
                <span class="c1"># to the ellipsoid</span>
                <span class="n">all_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">voxel_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">inside_voxels</span><span class="p">]</span>
                <span class="n">merged_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">all_nodes</span><span class="p">))</span>
                <span class="n">ell_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">merged_nodes</span><span class="p">)</span>

                <span class="c1"># Extract single instance of all nodes currently to be tested</span>
                <span class="n">nids</span> <span class="o">=</span> <span class="p">[</span><span class="n">voxel_dict</span><span class="p">[</span><span class="n">vid</span><span class="p">]</span> <span class="k">for</span> <span class="n">vid</span> <span class="ow">in</span> <span class="n">inside_ids</span><span class="p">]</span>
                <span class="n">m_nids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">nids</span><span class="p">))</span>
                <span class="n">e_nids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">m_nids</span><span class="p">)</span>

                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="c1"># Find the common nodes</span>
                    <span class="n">common_nodes</span> <span class="o">=</span> <span class="n">ell_nodes</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">e_nids</span><span class="p">)</span>

                    <span class="c1"># If there are no nodes in the ellipsoid</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">ell_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">ellipsoid</span><span class="o">.</span><span class="n">inside_voxels</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">inside_ids</span><span class="p">)</span>
                        <span class="n">assigned_voxels</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">inside_ids</span><span class="p">))</span>
                        <span class="k">break</span>

                    <span class="c1"># If there are more than 4 common nodes</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_nodes</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>

                        <span class="c1"># Find the voxels that have these common nodes</span>
                        <span class="n">int_assigned</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                        <span class="k">for</span> <span class="n">vid</span> <span class="ow">in</span> <span class="n">inside_ids</span><span class="p">:</span>
                            <span class="n">nds</span> <span class="o">=</span> <span class="n">voxel_dict</span><span class="p">[</span><span class="n">vid</span><span class="p">]</span>

                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ell_nodes</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">nds</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
                                <span class="n">int_assigned</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">vid</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">continue</span>

                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">int_assigned</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="c1"># update the ellipsoid instance and assigned set</span>
                            <span class="n">ellipsoid</span><span class="o">.</span><span class="n">inside_voxels</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">int_assigned</span><span class="p">))</span>
                            <span class="n">assigned_voxels</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">int_assigned</span><span class="p">)</span>

                            <span class="c1"># Remove them and test again</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">int_assigned</span><span class="p">:</span>
                                <span class="n">inside_ids</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span>
                                    <span class="n">i</span><span class="p">)</span>  <span class="c1"># Remove the assigned voxel from the list</span>

                                <span class="n">nds</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">voxel_dict</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                                <span class="n">ell_nodes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">nds</span><span class="p">)</span>  <span class="c1"># Update the actual ellipsoid node list</span>
                                <span class="n">e_nids</span> <span class="o">-=</span> <span class="n">nds</span>  <span class="c1"># update the current node list (testing)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">break</span>

                    <span class="c1"># If there are no common nodes</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">break</span>

                <span class="c1"># scale ellipsoid dimensions back to original by the growth factor</span>
                <span class="n">ellipsoid</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> \
                    <span class="n">ellipsoid</span><span class="o">.</span><span class="n">a</span> <span class="o">/</span> <span class="n">scale</span><span class="p">,</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">b</span> <span class="o">/</span> <span class="n">scale</span><span class="p">,</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">c</span> <span class="o">/</span> <span class="n">scale</span>

                <span class="k">continue</span>

                <span class="c1"># If scale == 1.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Each voxel should share at least 4 nodes with the remaining voxels</span>
                <span class="k">for</span> <span class="n">vid</span> <span class="ow">in</span> <span class="n">inside_ids</span><span class="p">:</span>
                    <span class="n">nds</span> <span class="o">=</span> <span class="n">voxel_dict</span><span class="p">[</span><span class="n">vid</span><span class="p">]</span>

                    <span class="n">rem_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inside_ids</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">vid</span><span class="p">]</span>
                    <span class="n">all_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">voxel_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rem_ids</span><span class="p">]</span>
                    <span class="n">merged_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">all_nodes</span><span class="p">))</span>
                    <span class="n">rem_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">merged_nodes</span><span class="p">)</span>

                    <span class="n">common_nodes</span> <span class="o">=</span> <span class="n">rem_nodes</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">nds</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_nodes</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
                        <span class="c1"># update the ellipsoid instance and assigned set</span>
                        <span class="n">ellipsoid</span><span class="o">.</span><span class="n">inside_voxels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vid</span><span class="p">)</span>
                        <span class="n">assigned_voxels</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">vid</span><span class="p">)</span>

        <span class="c1"># find the remaining voxels</span>
        <span class="n">remaining_voxels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">cooDict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">-</span> <span class="n">assigned_voxels</span>

        <span class="c1"># Reassign at the end of each growth cycle</span>
        <span class="n">reassign_shared_voxels</span><span class="p">(</span><span class="n">cooDict</span><span class="p">,</span> <span class="n">Ellipsoids</span><span class="p">,</span> <span class="n">voxel_dict</span><span class="p">)</span>

        <span class="c1"># Update the test_points and ids to remaining voxels</span>
        <span class="n">test_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">remaining_voxels</span><span class="p">))</span>
        <span class="n">test_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cooDict</span><span class="p">[</span><span class="n">pt_id</span><span class="p">]</span> <span class="k">for</span> <span class="n">pt_id</span> <span class="ow">in</span> <span class="n">test_ids</span><span class="p">])</span>

        <span class="c1"># Reset the progress bar to &#39;0&#39; and update it and then refresh the view again</span>
        <span class="n">pbar</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">assigned_voxels</span><span class="p">))</span>
        <span class="n">pbar</span><span class="o">.</span><span class="n">refresh</span><span class="p">()</span>

        <span class="c1"># Calculate volume fraction of assigned voxels</span>
        <span class="n">vf_cur</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">assigned_voxels</span><span class="p">)</span> <span class="o">/</span> <span class="n">Nvox</span>

    <span class="n">pbar</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>  <span class="c1"># Close the progress bar</span>
    <span class="k">return</span></div>



<div class="viewcode-block" id="reassign_shared_voxels">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.voxelization.reassign_shared_voxels">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">reassign_shared_voxels</span><span class="p">(</span><span class="n">cooDict</span><span class="p">,</span> <span class="n">Ellipsoids</span><span class="p">,</span> <span class="n">voxel_dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reassign shared voxels among ellipsoids to the most appropriate ellipsoid based on node overlap</span>
<span class="sd">    and proximity to ellipsoid centers</span>

<span class="sd">    This function identifies voxels that are contained within multiple ellipsoids and resolves</span>
<span class="sd">    conflicts by:</span>
<span class="sd">    1. Removing the shared voxel from all ellipsoids initially.</span>
<span class="sd">    2. Assigning the voxel to the ellipsoid with the largest number of shared nodes.</span>
<span class="sd">    3. If multiple ellipsoids have the same node overlap, assigning the voxel to the closest</span>
<span class="sd">       ellipsoid based on center distance.</span>
<span class="sd">    4. If still tied, assigning to the ellipsoid with the smallest volume.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cooDict : dict</span>
<span class="sd">        Dictionary mapping voxel IDs to their coordinates in 3D space.</span>
<span class="sd">        Example: {voxel_id: [x, y, z], ...}</span>
<span class="sd">    Ellipsoids : list</span>
<span class="sd">        List of ellipsoid objects from the packing routine. Each ellipsoid must have attributes:</span>
<span class="sd">        - `inside_voxels` (list of voxel IDs contained in the ellipsoid)</span>
<span class="sd">        - `id` (unique identifier)</span>
<span class="sd">        - `get_pos()` method returning the ellipsoid center coordinates as [x, y, z]</span>
<span class="sd">        - `get_volume()` method returning the ellipsoid volume</span>
<span class="sd">    voxel_dict : dict</span>
<span class="sd">        Dictionary mapping voxel IDs to the node IDs that define the voxel.</span>
<span class="sd">        Example: {voxel_id: [node1, node2, ...], ...}</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The reassignment loop has a maximum of 5 cycles to avoid infinite loops in edge cases.</span>
<span class="sd">    - A voxel is assigned to an ellipsoid only if it has at least 4 nodes in common with it.</span>
<span class="sd">    - Distance calculations assume Cartesian coordinates.</span>
<span class="sd">    - The function can handle ties in node overlap by considering proximity and volume.</span>
<span class="sd">    - Modifies `inside_voxels` lists of ellipsoids in place.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Find all combination of ellipsoids to check for shared voxels</span>
    <span class="n">combis</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">Ellipsoids</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

    <span class="c1"># Create a dictionary for linking voxels and their containing ellipsoids</span>
    <span class="n">vox_ellDict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">cb</span> <span class="ow">in</span> <span class="n">combis</span><span class="p">:</span>
        <span class="n">shared_voxels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">cb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">inside_voxels</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">cb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">inside_voxels</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">shared_voxels</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">vox</span> <span class="ow">in</span> <span class="n">shared_voxels</span><span class="p">:</span>
                <span class="n">vox_ellDict</span><span class="p">[</span><span class="n">vox</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span>

    <span class="n">assigned_voxel</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">vox_ellDict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">vox</span><span class="p">,</span> <span class="n">ells</span> <span class="ow">in</span> <span class="n">vox_ellDict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Remove the shared voxel for all the ellipsoids containing it</span>
            <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">ells</span><span class="p">:</span>
                <span class="n">el</span><span class="o">.</span><span class="n">inside_voxels</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">vox</span><span class="p">)</span>

    <span class="n">shared_voxels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">vox_ellDict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">ncyc</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">shared_voxels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ncyc</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">vox</span><span class="p">,</span> <span class="n">ells</span> <span class="ow">in</span> <span class="n">vox_ellDict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">vox</span> <span class="ow">in</span> <span class="n">shared_voxels</span><span class="p">:</span>
                <span class="n">ells</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ells</span><span class="p">)</span>
                <span class="n">nids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">voxel_dict</span><span class="p">[</span><span class="n">vox</span><span class="p">])</span>
                <span class="n">common_nodes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="n">len_common_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

                <span class="k">for</span> <span class="n">ellipsoid</span> <span class="ow">in</span> <span class="n">ells</span><span class="p">:</span>
                    <span class="n">all_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">voxel_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">inside_voxels</span><span class="p">]</span>
                    <span class="n">merged_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">all_nodes</span><span class="p">))</span>
                    <span class="n">ell_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">merged_nodes</span><span class="p">)</span>
                    <span class="n">common_nodes</span><span class="p">[</span><span class="n">ellipsoid</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">ell_nodes</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">nids</span><span class="p">)</span>
                    <span class="n">len_common_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">common_nodes</span><span class="p">[</span><span class="n">ellipsoid</span><span class="o">.</span><span class="n">id</span><span class="p">]))</span>

                <span class="n">loc_common_nodes_max</span> <span class="o">=</span> \
                    <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">len_common_nodes</span><span class="p">)</span>
                     <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="nb">max</span><span class="p">(</span><span class="n">len_common_nodes</span><span class="p">)]</span>

                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">len_common_nodes</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">max</span><span class="p">(</span><span class="n">len_common_nodes</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">loc_common_nodes_max</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">assigned_voxel</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vox</span><span class="p">)</span>
                        <span class="n">shared_voxels</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">vox</span><span class="p">)</span>
                        <span class="n">ells</span><span class="p">[</span><span class="n">loc_common_nodes_max</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">inside_voxels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vox</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ells</span> <span class="o">=</span> <span class="p">[</span><span class="n">ells</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">loc_common_nodes_max</span><span class="p">]</span>
                        <span class="n">vox_coord</span> <span class="o">=</span> <span class="n">cooDict</span><span class="p">[</span><span class="n">vox</span><span class="p">]</span>  <span class="c1"># Get the voxel position</span>
                        <span class="n">ells_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">el</span><span class="o">.</span><span class="n">get_pos</span><span class="p">()</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">ells</span><span class="p">])</span>  <span class="c1"># Get the ellipsoids positions</span>

                        <span class="c1"># Distance b/w points along three axes</span>
                        <span class="n">XDiff</span> <span class="o">=</span> <span class="n">vox_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">ells_pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># &#39;x&#39;-axis</span>
                        <span class="n">YDiff</span> <span class="o">=</span> <span class="n">vox_coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ells_pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># &#39;y&#39;-axis</span>
                        <span class="n">ZDiff</span> <span class="o">=</span> <span class="n">vox_coord</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">ells_pos</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>  <span class="c1"># &#39;z&#39;-axis</span>

                        <span class="c1"># Find the distance from the 1st ellipsoid</span>
                        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">XDiff</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">YDiff</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">ZDiff</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

                        <span class="n">clo_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dist</span> <span class="o">==</span> <span class="n">dist</span><span class="o">.</span><span class="n">min</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># closest ellipsoid index</span>
                        <span class="n">clo_ells</span> <span class="o">=</span> <span class="p">[</span><span class="n">ells</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">clo_loc</span><span class="p">]</span>  <span class="c1"># closest ellipsoids</span>

                        <span class="c1"># If &#39;1&#39; closest ellipsoid: assign voxel to it        </span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clo_ells</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">clo_ells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">inside_voxels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vox</span><span class="p">)</span>
                        <span class="c1"># Else: Determine the smallest and assign to it</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">clo_vol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ce</span><span class="o">.</span><span class="n">get_volume</span><span class="p">()</span> <span class="k">for</span> <span class="n">ce</span> <span class="ow">in</span> <span class="n">clo_ells</span><span class="p">])</span>  <span class="c1"># Determine the volumes</span>
                            <span class="n">small_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">clo_vol</span> <span class="o">==</span> <span class="n">clo_vol</span><span class="o">.</span><span class="n">min</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Smallest ellipsoid index</span>
                            <span class="c1"># small_ells = [ells[loc] for loc in clo_loc]           # Smallest ellipsoids</span>

                            <span class="c1"># assign to the smallest one regardless how many are of the same volume</span>
                            <span class="c1"># small_ells[0].inside_voxels.append(vox)</span>
                            <span class="n">clo_ells</span><span class="p">[</span><span class="n">small_loc</span><span class="p">]</span><span class="o">.</span><span class="n">inside_voxels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vox</span><span class="p">)</span>
                        <span class="n">assigned_voxel</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vox</span><span class="p">)</span>
                        <span class="n">shared_voxels</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">vox</span><span class="p">)</span>
        <span class="n">ncyc</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span></div>



<div class="viewcode-block" id="voxelizationRoutine">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.voxelization.voxelizationRoutine">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">voxelizationRoutine</span><span class="p">(</span><span class="n">Ellipsoids</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">nphases</span><span class="p">,</span> <span class="n">prec_vf</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform voxelization of a microstructure defined by ellipsoids and mesh.</span>

<span class="sd">    This function controls the voxelization process by calling several subroutines:</span>
<span class="sd">    - :meth:`kanapy.input_output.read_dump`</span>
<span class="sd">    - :meth:`create_voxels`</span>
<span class="sd">    - :meth:`assign_voxels_to_ellipsoid`</span>
<span class="sd">    - :meth:`reassign_shared_voxels`</span>

<span class="sd">    Depending on whether ellipsoids have inner polygons, it either assigns voxels</span>
<span class="sd">    directly to ellipsoids or uses polygon-based voxel assignment.</span>

<span class="sd">    The function also generates:</span>
<span class="sd">    - `mesh.grains`: array of voxelized structure with grain IDs</span>
<span class="sd">    - `mesh.phases`: array of voxelized structure with phase numbers</span>
<span class="sd">    - `mesh.grain_dict`: dictionary mapping grain IDs to voxel IDs</span>
<span class="sd">    - `mesh.grain_phase_dict`: dictionary mapping grain IDs to phase numbers</span>
<span class="sd">    - `mesh.ngrains_phase`: count of grains per phase</span>
<span class="sd">    - `mesh.prec_vf_voxels`: current volume fraction if `prec_vf` is provided</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Ellipsoids : list</span>
<span class="sd">        List of ellipsoid objects representing grains. Each ellipsoid should have:</span>
<span class="sd">        - `inside_voxels` (list of voxel IDs)</span>
<span class="sd">        - `duplicate` (ID of original ellipsoid if duplicated, else None)</span>
<span class="sd">        - `inner` (optional polygon object)</span>
<span class="sd">        - `phasenum` (phase number)</span>
<span class="sd">        - `get_pos()` and `create_poly()` methods.</span>
<span class="sd">    mesh : object</span>
<span class="sd">        Mesh object containing voxel information, including:</span>
<span class="sd">        - `vox_center_dict` (voxel centers)</span>
<span class="sd">        - `voxel_dict` (voxel-to-node mapping)</span>
<span class="sd">        - `nvox` (number of voxels)</span>
<span class="sd">        - `dim` (mesh dimensions)</span>
<span class="sd">    nphases : int</span>
<span class="sd">        Number of phases in the RVE.</span>
<span class="sd">    prec_vf : float, optional</span>
<span class="sd">        Target volume fraction for precipitates/porosity. Defaults to `None` (fully filled RVE).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Voxels shared by multiple ellipsoids are resolved using `reassign_shared_voxels`.</span>
<span class="sd">    - Voxels not assigned to any grain are either assigned to neighbors or set to phase 1.</span>
<span class="sd">    - If `prec_vf` &lt; 1.0, empty voxels are treated as dispersed phase (precipitates/porosity).</span>
<span class="sd">    - The function modifies the `mesh` object in place.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mesh</span>
<span class="sd">        The input mesh object with updated voxelized grain and phase information.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">ell2vox</span><span class="p">():</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assign voxels to ellipsoids and update the mesh&#39;s grain dictionary</span>

<span class="sd">        This helper function performs the following steps:</span>
<span class="sd">        1. Calls `assign_voxels_to_ellipsoid` to assign voxels based on ellipsoid positions and target volume fraction</span>
<span class="sd">        2. For each ellipsoid:</span>
<span class="sd">           - If it contains voxels:</span>
<span class="sd">               - If the ellipsoid is a duplicate, its voxels are added to the original ellipsoid&#39;s entry in `mesh.grain_dict`</span>
<span class="sd">               - Otherwise, the ellipsoid is added as a new entry in `mesh.grain_dict`</span>
<span class="sd">           - If it contains no voxels, logs a debug message indicating the grain could not be voxelized</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Modifies `mesh.grain_dict` in place</span>
<span class="sd">        - Assumes `Ellipsoids` and `mesh` are accessible in the enclosing scope</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">assign_voxels_to_ellipsoid</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vox_center_dict</span><span class="p">,</span> <span class="n">Ellipsoids</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">voxel_dict</span><span class="p">,</span> <span class="n">vf_target</span><span class="o">=</span><span class="n">prec_vf</span><span class="p">)</span>
        <span class="c1"># Create element sets</span>
        <span class="k">for</span> <span class="n">ellipsoid</span> <span class="ow">in</span> <span class="n">Ellipsoids</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">inside_voxels</span><span class="p">:</span>
                <span class="c1"># If the ellipsoid is a duplicate add the voxels to the original ellipsoid</span>
                <span class="k">if</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">duplicate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">iel</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ellipsoid</span><span class="o">.</span><span class="n">duplicate</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">iel</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="p">:</span>
                        <span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="p">[</span><span class="n">iel</span><span class="p">]</span> <span class="o">=</span> \
                            <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span> <span class="k">for</span> <span class="n">iv</span> <span class="ow">in</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">inside_voxels</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="p">[</span><span class="n">iel</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                            <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span> <span class="k">for</span> <span class="n">iv</span> <span class="ow">in</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">inside_voxels</span><span class="p">])</span>
                <span class="c1"># Else it is the original ellipsoid</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">ellipsoid</span><span class="o">.</span><span class="n">id</span><span class="p">)]</span> <span class="o">=</span> \
                        <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span> <span class="k">for</span> <span class="n">iv</span> <span class="ow">in</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">inside_voxels</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If ellipsoid doesn&#39;t contain any voxel inside</span>
                <span class="c1"># grain should be removed from list!!!</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;        Grain </span><span class="si">{0}</span><span class="s1"> is not voxelized, as particle </span><span class="si">{0}</span><span class="s1"> overlap condition is inadmissible&#39;</span>
                              <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ellipsoid</span><span class="o">.</span><span class="n">id</span><span class="p">))</span>
                <span class="c1"># sys.exit(0)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">poly2vox</span><span class="p">():</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assign voxels to ellipsoids based on inner polygon geometry</span>

<span class="sd">        This helper function performs the following steps:</span>
<span class="sd">        1. For each ellipsoid:</span>
<span class="sd">           - If it is a duplicate, create its polygon from the original ellipsoid</span>
<span class="sd">           - Synchronize the polygon using `sync_poly`</span>
<span class="sd">           - Search for voxel centers inside the polygon</span>
<span class="sd">               - If the voxel is already assigned to another grain, compare distances to the centers</span>
<span class="sd">                 and reassign if the current ellipsoid is closer</span>
<span class="sd">               - Otherwise, assign the voxel to the current ellipsoid</span>
<span class="sd">        2. Update `mesh.grain_dict` with assigned voxels for each grain</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Modifies `mesh.grain_dict` and `inside_voxels` of ellipsoids in place</span>
<span class="sd">        - Assumes `Ellipsoids` and `mesh` are accessible in the enclosing scope</span>
<span class="sd">        - Keeps track of assigned voxels to avoid duplicate assignments</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">assigned_vox</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">pa</span> <span class="ow">in</span> <span class="n">Ellipsoids</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pa</span><span class="o">.</span><span class="n">duplicate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">gid</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">duplicate</span>
                <span class="n">pa</span><span class="o">.</span><span class="n">inner</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">create_poly</span><span class="p">(</span><span class="n">Ellipsoids</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span><span class="o">.</span><span class="n">inner</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gid</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">id</span>
            <span class="n">pa</span><span class="o">.</span><span class="n">sync_poly</span><span class="p">()</span>
            <span class="n">vox</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># search for voxel centers inside the polygon</span>
            <span class="k">for</span> <span class="n">iv</span><span class="p">,</span> <span class="n">ctr</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vox_center_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">pa</span><span class="o">.</span><span class="n">inner</span><span class="o">.</span><span class="n">find_simplex</span><span class="p">(</span><span class="n">ctr</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">iv</span> <span class="ow">in</span> <span class="n">assigned_vox</span><span class="p">:</span>
                        <span class="c1"># voxel has already been assigned to different grain.</span>
                        <span class="c1"># check nearest center and re-assign if necessary</span>
                        <span class="n">dst1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">ctr</span> <span class="o">-</span> <span class="n">pa</span><span class="o">.</span><span class="n">get_pos</span><span class="p">())</span>
                        <span class="k">for</span> <span class="n">igr</span><span class="p">,</span> <span class="n">vlist</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="k">if</span> <span class="n">iv</span> <span class="ow">in</span> <span class="n">vlist</span><span class="p">:</span>
                                <span class="n">dst2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">ctr</span> <span class="o">-</span> <span class="n">Ellipsoids</span><span class="p">[</span><span class="n">igr</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_pos</span><span class="p">())</span>
                                <span class="k">if</span> <span class="n">dst1</span> <span class="o">&lt;</span> <span class="n">dst2</span><span class="p">:</span>
                                    <span class="n">vox</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span>
                                    <span class="n">pa</span><span class="o">.</span><span class="n">inside_voxels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span>
                                    <span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="p">[</span><span class="n">igr</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span>
                                    <span class="n">Ellipsoids</span><span class="p">[</span><span class="n">igr</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">inside_voxels</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span>
                                <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">assigned_vox</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span>
                        <span class="n">vox</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span>
                        <span class="n">pa</span><span class="o">.</span><span class="n">inside_voxels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">gid</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span> <span class="o">=</span> <span class="n">vox</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Starting RVE voxelization&#39;</span><span class="p">)</span>

    <span class="c1"># Find the voxels belonging to each grain by growing ellipsoid each time</span>
    <span class="k">if</span> <span class="n">prec_vf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">prec_vf</span> <span class="o">=</span> <span class="mf">1.</span>

    <span class="c1"># decide if voxels shall be assigned to ellipsoids or inner polygons</span>
    <span class="k">if</span> <span class="n">Ellipsoids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">inner</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ell2vox</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">poly2vox</span><span class="p">()</span>

    <span class="c1"># generate array of voxelized structure with grain IDs</span>
    <span class="c1"># if fill_factor &lt; 1.0, empty voxels will have grain ID 0</span>
    <span class="n">gr_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">nvox</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">igr</span><span class="p">,</span> <span class="n">vlist</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">vlist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vlist</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">gr_arr</span><span class="p">[</span><span class="n">vlist</span><span class="p">]</span> <span class="o">=</span> <span class="n">igr</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">gr_arr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># some voxels have not been assigned to grains, check is assignment is required</span>
        <span class="k">if</span> <span class="n">prec_vf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">iv</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">:</span>
                <span class="n">gr_arr</span><span class="p">[</span><span class="n">iv</span><span class="p">]</span> <span class="o">=</span> <span class="n">gr_arr</span><span class="p">[</span><span class="n">iv</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># assign voxel to neighbor grain</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Warning: Assigned voxel </span><span class="si">{</span><span class="n">iv</span><span class="si">}</span><span class="s1"> to grain </span><span class="si">{</span><span class="n">gr_arr</span><span class="p">[</span><span class="n">iv</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
    <span class="n">mesh</span><span class="o">.</span><span class="n">grains</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">gr_arr</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>


    <span class="c1"># generate array of voxelized structure with phase numbers</span>
    <span class="c1"># and dict of phase numbers for each grain</span>
    <span class="c1"># empty voxels will get phase number 1 and be assigned to grain with key 0</span>
    <span class="n">ph_arr</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">nvox</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">mesh</span><span class="o">.</span><span class="n">grain_phase_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">mesh</span><span class="o">.</span><span class="n">ngrains_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nphases</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">igr</span><span class="p">,</span> <span class="n">vlist</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">vlist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vlist</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">ip</span> <span class="o">=</span> <span class="n">Ellipsoids</span><span class="p">[</span><span class="n">igr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">phasenum</span>
        <span class="n">ph_arr</span><span class="p">[</span><span class="n">vlist</span><span class="p">]</span> <span class="o">=</span> <span class="n">ip</span>
        <span class="n">mesh</span><span class="o">.</span><span class="n">grain_phase_dict</span><span class="p">[</span><span class="n">igr</span><span class="p">]</span> <span class="o">=</span> <span class="n">ip</span>
        <span class="n">mesh</span><span class="o">.</span><span class="n">ngrains_phase</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">ph_arr</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ph_arr</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># assign phase 1 to empty voxels</span>
    <span class="n">mesh</span><span class="o">.</span><span class="n">phases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ph_arr</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
    <span class="n">vf_cur</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">/</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nvox</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Completed RVE voxelization&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">prec_vf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">prec_vf</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Dispersed phase (precipitates/porosity):&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Volume fraction in voxelized grains: </span><span class="si">{</span><span class="n">vf_cur</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Target volume fraction = </span><span class="si">{</span><span class="n">prec_vf</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">mesh</span><span class="o">.</span><span class="n">prec_vf_voxels</span> <span class="o">=</span> <span class="n">vf_cur</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Grain with key &quot;0&quot; already exists. Should be reserved for matrix phase in structures &#39;</span> <span class="o">+</span>
                             <span class="s1">&#39;with precipitates or porosity. Cannot continue with precipitate simulation.&#39;</span><span class="p">)</span>
        <span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">mesh</span><span class="o">.</span><span class="n">grain_phase_dict</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">mesh</span><span class="o">.</span><span class="n">ngrains_phase</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">vf_cur</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;WARNING: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span><span class="si">}</span><span class="s1"> voxels have not been assigned to grains.&#39;</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Try to assign empty voxels to neighbor grain&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mesh</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright This work is published under a CC BY-SA 4.0 license.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>