

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>kanapy.core.voxelization &mdash; kanapy 6.5.3.post1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=53ab5b41"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            kanapy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../applications.html">Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../method.html">Modeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kanapy.html">Code documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../history.html">History</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">kanapy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">kanapy.core.voxelization</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for kanapy.core.voxelization</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">copy</span><span class="w"> </span><span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">ConvexHull</span>


<div class="viewcode-block" id="points_in_convexHull">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.voxelization.points_in_convexHull">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">points_in_convexHull</span><span class="p">(</span><span class="n">Points</span><span class="p">,</span> <span class="n">hull</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines whether the given array of points lie inside the convex hull or outside.        </span>

<span class="sd">    :param Points: Array of points to be tested whether they lie inside the hull or not. </span>
<span class="sd">    :type Points: numpy array</span>
<span class="sd">    :param hull: Ellipsoid represented by a convex hull created from its outer surface points.  </span>
<span class="sd">    :type hull: Scipy&#39;s :obj:`ConvexHull` object</span>

<span class="sd">    :returns: Boolean values representing the status. If inside: **True**, else **False**</span>
<span class="sd">    :rtype: numpy array</span>

<span class="sd">    .. seealso::</span>
<span class="sd">       https://stackoverflow.com/questions/21698630/how-can-i-find-if-a-point-lies-inside-or-outside-of-convexhull</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">hull</span><span class="o">.</span><span class="n">equations</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">hull</span><span class="o">.</span><span class="n">equations</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">((</span><span class="n">A</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">Points</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">Points</span><span class="p">))),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>



<div class="viewcode-block" id="assign_voxels_to_ellipsoid">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.voxelization.assign_voxels_to_ellipsoid">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">assign_voxels_to_ellipsoid</span><span class="p">(</span><span class="n">cooDict</span><span class="p">,</span> <span class="n">Ellipsoids</span><span class="p">,</span> <span class="n">voxel_dict</span><span class="p">,</span> <span class="n">vf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines voxels belonging to each ellipsoid    </span>

<span class="sd">    :param cooDict: Voxel dictionary containing voxel IDs and center coordinates. </span>
<span class="sd">    :type cooDict: Python dictionary</span>
<span class="sd">    :param Ellipsoids: Ellipsoids from the packing routine.</span>
<span class="sd">    :type Ellipsoids: list</span>
<span class="sd">    :param voxel_dict: Element dictionary containing element IDs and nodal connectivities.</span>
<span class="sd">    :type voxel_dict: Python dictionary</span>
<span class="sd">    :param vf_target: target value for volume fraction of particles (optional, default: None)</span>
<span class="sd">    :type: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    Assigning voxels to grains&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">vf_target</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">vf_target</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="n">vf_target</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="c1"># All the voxel centers as numpy 2D array and voxel ids</span>
    <span class="n">test_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">cooDict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="n">Nvox</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">test_ids</span><span class="p">)</span>
    <span class="n">test_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">cooDict</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

    <span class="c1"># scale factor for defining ellipsoid growth for each stage of while loop</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">remaining_voxels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">cooDict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="n">assigned_voxels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">vf_cur</span> <span class="o">=</span> <span class="mf">0.</span>

    <span class="c1"># Initialize a tqdm progress bar to the Number of voxels in the domain</span>
    <span class="n">pbar</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">remaining_voxels</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">ellipsoid</span> <span class="ow">in</span> <span class="n">Ellipsoids</span><span class="p">:</span>
        <span class="n">ellipsoid</span><span class="o">.</span><span class="n">inside_voxels</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">while</span> <span class="n">vf_cur</span> <span class="o">&lt;</span> <span class="n">vf_target</span><span class="p">:</span>
        <span class="c1"># call the growth value for the ellipsoids</span>
        <span class="n">scale</span> <span class="o">+=</span> <span class="mf">0.1</span>
        <span class="k">for</span> <span class="n">ellipsoid</span> <span class="ow">in</span> <span class="n">Ellipsoids</span><span class="p">:</span>
            <span class="c1"># scale ellipsoid dimensions by the growth factor and generate surface points</span>
            <span class="n">ellipsoid</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">c</span>
            <span class="n">surface_points</span> <span class="o">=</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">surfacePointsGen</span><span class="p">()</span>
            <span class="c1"># Find the new surface points of the ellipsoid at their final position</span>
            <span class="n">new_surfPts</span> <span class="o">=</span> <span class="n">surface_points</span> <span class="o">+</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">get_pos</span><span class="p">()</span>

            <span class="c1"># create a convex hull from the surface points</span>
            <span class="n">hull</span> <span class="o">=</span> <span class="n">ConvexHull</span><span class="p">(</span><span class="n">new_surfPts</span><span class="p">,</span> <span class="n">incremental</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1"># Find the bounding box extrema along x, y, and z</span>
            <span class="n">bbox_xmin</span><span class="p">,</span> <span class="n">bbox_xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">new_surfPts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">new_surfPts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">bbox_ymin</span><span class="p">,</span> <span class="n">bbox_ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">new_surfPts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">new_surfPts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">bbox_zmin</span><span class="p">,</span> <span class="n">bbox_zmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">new_surfPts</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">new_surfPts</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>

            <span class="c1"># Find the numpy indices of all voxels within the bounding box</span>
            <span class="n">in_bbox_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">test_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">bbox_xmin</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">test_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">bbox_xmax</span><span class="p">)</span>
                                   <span class="o">&amp;</span> <span class="p">(</span><span class="n">test_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">bbox_ymin</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">test_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">bbox_ymax</span><span class="p">)</span>
                                   <span class="o">&amp;</span> <span class="p">(</span><span class="n">test_points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">bbox_zmin</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">test_points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">bbox_zmax</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># extract the actual voxel ids and coordinates from the reduced numpy indices</span>
            <span class="n">bbox_testids</span> <span class="o">=</span> <span class="n">test_ids</span><span class="p">[</span><span class="n">in_bbox_idx</span><span class="p">]</span>  <span class="c1"># voxels ids</span>
            <span class="n">bbox_testPts</span> <span class="o">=</span> <span class="n">test_points</span><span class="p">[</span><span class="n">in_bbox_idx</span><span class="p">]</span>  <span class="c1"># coordinates</span>

            <span class="c1"># check if the extracted points are within the hull</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">points_in_convexHull</span><span class="p">(</span><span class="n">bbox_testPts</span><span class="p">,</span> <span class="n">hull</span><span class="p">)</span>

            <span class="c1"># Extract the voxel ids inside the hull</span>
            <span class="n">inside_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">bbox_testids</span><span class="p">[</span><span class="n">results</span><span class="p">])</span>

            <span class="c1"># Check if the newly found voxels share at least 4 nodes with</span>
            <span class="c1"># ellipsoid nodes</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">):</span>
                <span class="c1"># Extract single instance of all nodes currently belonging</span>
                <span class="c1"># to the ellipsoid</span>
                <span class="n">all_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">voxel_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">inside_voxels</span><span class="p">]</span>
                <span class="n">merged_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">all_nodes</span><span class="p">))</span>
                <span class="n">ell_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">merged_nodes</span><span class="p">)</span>

                <span class="c1"># Extract single instance of all nodes currently to be tested</span>
                <span class="n">nids</span> <span class="o">=</span> <span class="p">[</span><span class="n">voxel_dict</span><span class="p">[</span><span class="n">vid</span><span class="p">]</span> <span class="k">for</span> <span class="n">vid</span> <span class="ow">in</span> <span class="n">inside_ids</span><span class="p">]</span>
                <span class="n">m_nids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">nids</span><span class="p">))</span>
                <span class="n">e_nids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">m_nids</span><span class="p">)</span>

                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="c1"># Find the common nodes</span>
                    <span class="n">common_nodes</span> <span class="o">=</span> <span class="n">ell_nodes</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">e_nids</span><span class="p">)</span>

                    <span class="c1"># If there are no nodes in the ellipsoid</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">ell_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">ellipsoid</span><span class="o">.</span><span class="n">inside_voxels</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">inside_ids</span><span class="p">)</span>
                        <span class="n">assigned_voxels</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">inside_ids</span><span class="p">))</span>
                        <span class="k">break</span>

                    <span class="c1"># If there are more than 4 common nodes</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_nodes</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>

                        <span class="c1"># Find the voxels that have these common nodes</span>
                        <span class="n">int_assigned</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                        <span class="k">for</span> <span class="n">vid</span> <span class="ow">in</span> <span class="n">inside_ids</span><span class="p">:</span>
                            <span class="n">nds</span> <span class="o">=</span> <span class="n">voxel_dict</span><span class="p">[</span><span class="n">vid</span><span class="p">]</span>

                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ell_nodes</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">nds</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
                                <span class="n">int_assigned</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">vid</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">continue</span>

                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">int_assigned</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="c1"># update the ellipsoid instance and assigned set</span>
                            <span class="n">ellipsoid</span><span class="o">.</span><span class="n">inside_voxels</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">int_assigned</span><span class="p">))</span>
                            <span class="n">assigned_voxels</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">int_assigned</span><span class="p">)</span>

                            <span class="c1"># Remove them and test again</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">int_assigned</span><span class="p">:</span>
                                <span class="n">inside_ids</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span>
                                    <span class="n">i</span><span class="p">)</span>  <span class="c1"># Remove the assigned voxel from the list</span>

                                <span class="n">nds</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">voxel_dict</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                                <span class="n">ell_nodes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">nds</span><span class="p">)</span>  <span class="c1"># Update the actual ellipsoid node list</span>
                                <span class="n">e_nids</span> <span class="o">-=</span> <span class="n">nds</span>  <span class="c1"># update the current node list (testing)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">break</span>

                    <span class="c1"># If there are no common nodes</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">break</span>

                <span class="c1"># scale ellipsoid dimensions back to original by the growth factor</span>
                <span class="n">ellipsoid</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> \
                    <span class="n">ellipsoid</span><span class="o">.</span><span class="n">a</span> <span class="o">/</span> <span class="n">scale</span><span class="p">,</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">b</span> <span class="o">/</span> <span class="n">scale</span><span class="p">,</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">c</span> <span class="o">/</span> <span class="n">scale</span>

                <span class="k">continue</span>

                <span class="c1"># If scale == 1.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Each voxel should share at least 4 nodes with the remaining voxels</span>
                <span class="k">for</span> <span class="n">vid</span> <span class="ow">in</span> <span class="n">inside_ids</span><span class="p">:</span>
                    <span class="n">nds</span> <span class="o">=</span> <span class="n">voxel_dict</span><span class="p">[</span><span class="n">vid</span><span class="p">]</span>

                    <span class="n">rem_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inside_ids</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">vid</span><span class="p">]</span>
                    <span class="n">all_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">voxel_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rem_ids</span><span class="p">]</span>
                    <span class="n">merged_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">all_nodes</span><span class="p">))</span>
                    <span class="n">rem_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">merged_nodes</span><span class="p">)</span>

                    <span class="n">common_nodes</span> <span class="o">=</span> <span class="n">rem_nodes</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">nds</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_nodes</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
                        <span class="c1"># update the ellipsoid instance and assigned set</span>
                        <span class="n">ellipsoid</span><span class="o">.</span><span class="n">inside_voxels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vid</span><span class="p">)</span>
                        <span class="n">assigned_voxels</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">vid</span><span class="p">)</span>

        <span class="c1"># find the remaining voxels</span>
        <span class="n">remaining_voxels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">cooDict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">-</span> <span class="n">assigned_voxels</span>

        <span class="c1"># Reassign at the end of each growth cycle</span>
        <span class="n">reassign_shared_voxels</span><span class="p">(</span><span class="n">cooDict</span><span class="p">,</span> <span class="n">Ellipsoids</span><span class="p">,</span> <span class="n">voxel_dict</span><span class="p">)</span>

        <span class="c1"># Update the test_points and ids to remaining voxels</span>
        <span class="n">test_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">remaining_voxels</span><span class="p">))</span>
        <span class="n">test_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cooDict</span><span class="p">[</span><span class="n">pt_id</span><span class="p">]</span> <span class="k">for</span> <span class="n">pt_id</span> <span class="ow">in</span> <span class="n">test_ids</span><span class="p">])</span>

        <span class="c1"># Reset the progress bar to &#39;0&#39; and update it and then refresh the view again</span>
        <span class="n">pbar</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">assigned_voxels</span><span class="p">))</span>
        <span class="n">pbar</span><span class="o">.</span><span class="n">refresh</span><span class="p">()</span>

        <span class="c1"># Calculate volume fraction of assigned voxels</span>
        <span class="n">vf_cur</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">assigned_voxels</span><span class="p">)</span> <span class="o">/</span> <span class="n">Nvox</span>

    <span class="n">pbar</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>  <span class="c1"># Close the progress bar</span>
    <span class="k">return</span></div>



<div class="viewcode-block" id="reassign_shared_voxels">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.voxelization.reassign_shared_voxels">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">reassign_shared_voxels</span><span class="p">(</span><span class="n">cooDict</span><span class="p">,</span> <span class="n">Ellipsoids</span><span class="p">,</span> <span class="n">voxel_dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assigns shared voxels between ellipsoids to the ellipsoid with the closest center.</span>

<span class="sd">    :param cooDict: Voxel dictionary containing voxel IDs and center coordinates. </span>
<span class="sd">    :type cooDict: Python dictionary            </span>
<span class="sd">    :param Ellipsoids: Ellipsoids from the packing routine.</span>
<span class="sd">    :type Ellipsoids: list</span>
<span class="sd">    :param voxel_dict: Dictionary of element definitions</span>
<span class="sd">    :type voxel_dict: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Find all combination of ellipsoids to check for shared voxels</span>
    <span class="n">combis</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">Ellipsoids</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

    <span class="c1"># Create a dictionary for linking voxels and their containing ellipsoids</span>
    <span class="n">vox_ellDict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">cb</span> <span class="ow">in</span> <span class="n">combis</span><span class="p">:</span>
        <span class="n">shared_voxels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">cb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">inside_voxels</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">cb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">inside_voxels</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">shared_voxels</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">vox</span> <span class="ow">in</span> <span class="n">shared_voxels</span><span class="p">:</span>
                <span class="n">vox_ellDict</span><span class="p">[</span><span class="n">vox</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span>

    <span class="n">assigned_voxel</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">vox_ellDict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">vox</span><span class="p">,</span> <span class="n">ells</span> <span class="ow">in</span> <span class="n">vox_ellDict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Remove the shared voxel for all the ellipsoids containing it</span>
            <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">ells</span><span class="p">:</span>
                <span class="n">el</span><span class="o">.</span><span class="n">inside_voxels</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">vox</span><span class="p">)</span>

    <span class="n">shared_voxels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">vox_ellDict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">ncyc</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">shared_voxels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ncyc</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">vox</span><span class="p">,</span> <span class="n">ells</span> <span class="ow">in</span> <span class="n">vox_ellDict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">vox</span> <span class="ow">in</span> <span class="n">shared_voxels</span><span class="p">:</span>
                <span class="n">ells</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ells</span><span class="p">)</span>
                <span class="n">nids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">voxel_dict</span><span class="p">[</span><span class="n">vox</span><span class="p">])</span>
                <span class="n">common_nodes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="n">len_common_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

                <span class="k">for</span> <span class="n">ellipsoid</span> <span class="ow">in</span> <span class="n">ells</span><span class="p">:</span>
                    <span class="n">all_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">voxel_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">inside_voxels</span><span class="p">]</span>
                    <span class="n">merged_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">all_nodes</span><span class="p">))</span>
                    <span class="n">ell_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">merged_nodes</span><span class="p">)</span>
                    <span class="n">common_nodes</span><span class="p">[</span><span class="n">ellipsoid</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">ell_nodes</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">nids</span><span class="p">)</span>
                    <span class="n">len_common_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">common_nodes</span><span class="p">[</span><span class="n">ellipsoid</span><span class="o">.</span><span class="n">id</span><span class="p">]))</span>

                <span class="n">loc_common_nodes_max</span> <span class="o">=</span> \
                    <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">len_common_nodes</span><span class="p">)</span>
                     <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="nb">max</span><span class="p">(</span><span class="n">len_common_nodes</span><span class="p">)]</span>

                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">len_common_nodes</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">max</span><span class="p">(</span><span class="n">len_common_nodes</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">loc_common_nodes_max</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">assigned_voxel</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vox</span><span class="p">)</span>
                        <span class="n">shared_voxels</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">vox</span><span class="p">)</span>
                        <span class="n">ells</span><span class="p">[</span><span class="n">loc_common_nodes_max</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">inside_voxels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vox</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ells</span> <span class="o">=</span> <span class="p">[</span><span class="n">ells</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">loc_common_nodes_max</span><span class="p">]</span>
                        <span class="n">vox_coord</span> <span class="o">=</span> <span class="n">cooDict</span><span class="p">[</span><span class="n">vox</span><span class="p">]</span>  <span class="c1"># Get the voxel position</span>
                        <span class="n">ells_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">el</span><span class="o">.</span><span class="n">get_pos</span><span class="p">()</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">ells</span><span class="p">])</span>  <span class="c1"># Get the ellipsoids positions</span>

                        <span class="c1"># Distance b/w points along three axes</span>
                        <span class="n">XDiff</span> <span class="o">=</span> <span class="n">vox_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">ells_pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># &#39;x&#39;-axis</span>
                        <span class="n">YDiff</span> <span class="o">=</span> <span class="n">vox_coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ells_pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># &#39;y&#39;-axis</span>
                        <span class="n">ZDiff</span> <span class="o">=</span> <span class="n">vox_coord</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">ells_pos</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>  <span class="c1"># &#39;z&#39;-axis</span>

                        <span class="c1"># Find the distance from the 1st ellipsoid</span>
                        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">XDiff</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">YDiff</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">ZDiff</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

                        <span class="n">clo_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dist</span> <span class="o">==</span> <span class="n">dist</span><span class="o">.</span><span class="n">min</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># closest ellipsoid index</span>
                        <span class="n">clo_ells</span> <span class="o">=</span> <span class="p">[</span><span class="n">ells</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">clo_loc</span><span class="p">]</span>  <span class="c1"># closest ellipsoids</span>

                        <span class="c1"># If &#39;1&#39; closest ellipsoid: assign voxel to it        </span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clo_ells</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">clo_ells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">inside_voxels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vox</span><span class="p">)</span>
                        <span class="c1"># Else: Determine the smallest and assign to it</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">clo_vol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ce</span><span class="o">.</span><span class="n">get_volume</span><span class="p">()</span> <span class="k">for</span> <span class="n">ce</span> <span class="ow">in</span> <span class="n">clo_ells</span><span class="p">])</span>  <span class="c1"># Determine the volumes</span>
                            <span class="n">small_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">clo_vol</span> <span class="o">==</span> <span class="n">clo_vol</span><span class="o">.</span><span class="n">min</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Smallest ellipsoid index</span>
                            <span class="c1"># small_ells = [ells[loc] for loc in clo_loc]           # Smallest ellipsoids</span>

                            <span class="c1"># assign to the smallest one regardless how many are of the same volume</span>
                            <span class="c1"># small_ells[0].inside_voxels.append(vox)</span>
                            <span class="n">clo_ells</span><span class="p">[</span><span class="n">small_loc</span><span class="p">]</span><span class="o">.</span><span class="n">inside_voxels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vox</span><span class="p">)</span>
                        <span class="n">assigned_voxel</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vox</span><span class="p">)</span>
                        <span class="n">shared_voxels</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">vox</span><span class="p">)</span>
        <span class="n">ncyc</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span></div>



<div class="viewcode-block" id="voxelizationRoutine">
<a class="viewcode-back" href="../../../kanapy.html#kanapy.core.voxelization.voxelizationRoutine">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">voxelizationRoutine</span><span class="p">(</span><span class="n">Ellipsoids</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">nphases</span><span class="p">,</span> <span class="n">prec_vf</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The main function that controls the voxelization routine using: :meth:`kanapy.input_output.read_dump`,</span>
<span class="sd">    :meth:`create_voxels`, :meth:`assign_voxels_to_ellipsoid`, :meth:`reassign_shared_voxels`</span>
<span class="sd">    </span>
<span class="sd">    .. note:: 1. The RVE attributes such as RVE (Simulation domain) size, the number of voxels and the voxel resolution </span>
<span class="sd">                 is read by loading the JSON file that is generated by :meth:`kanapy.input_output.read_dump`.</span>
<span class="sd">              2. The following dictionaries are written as json files into a folder in the current working directory.</span>

<span class="sd">                * Node list containing coordinates.</span>
<span class="sd">                * Element dictionary containing element ID and nodal connectivities.</span>
<span class="sd">                * Element set dictionary containing element set ID and group of </span>
<span class="sd">                  elements each representing a grain of the RVE.                                 </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">ell2vox</span><span class="p">():</span>
        <span class="n">assign_voxels_to_ellipsoid</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vox_center_dict</span><span class="p">,</span> <span class="n">Ellipsoids</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">voxel_dict</span><span class="p">,</span> <span class="n">vf_target</span><span class="o">=</span><span class="n">prec_vf</span><span class="p">)</span>
        <span class="c1"># Create element sets</span>
        <span class="k">for</span> <span class="n">ellipsoid</span> <span class="ow">in</span> <span class="n">Ellipsoids</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">inside_voxels</span><span class="p">:</span>
                <span class="c1"># If the ellipsoid is a duplicate add the voxels to the original ellipsoid</span>
                <span class="k">if</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">duplicate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">iel</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ellipsoid</span><span class="o">.</span><span class="n">duplicate</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">iel</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="p">:</span>
                        <span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="p">[</span><span class="n">iel</span><span class="p">]</span> <span class="o">=</span> \
                            <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span> <span class="k">for</span> <span class="n">iv</span> <span class="ow">in</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">inside_voxels</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="p">[</span><span class="n">iel</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                            <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span> <span class="k">for</span> <span class="n">iv</span> <span class="ow">in</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">inside_voxels</span><span class="p">])</span>
                <span class="c1"># Else it is the original ellipsoid</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">ellipsoid</span><span class="o">.</span><span class="n">id</span><span class="p">)]</span> <span class="o">=</span> \
                        <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span> <span class="k">for</span> <span class="n">iv</span> <span class="ow">in</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">inside_voxels</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If ellipsoid doesn&#39;t contain any voxel inside</span>
                <span class="c1"># grain should be removed from list!!!</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;        Grain </span><span class="si">{0}</span><span class="s1"> is not voxelized, as particle </span><span class="si">{0}</span><span class="s1"> overlap condition is inadmissible&#39;</span>
                              <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ellipsoid</span><span class="o">.</span><span class="n">id</span><span class="p">))</span>
                <span class="c1"># sys.exit(0)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">poly2vox</span><span class="p">():</span>
        <span class="n">assigned_vox</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">pa</span> <span class="ow">in</span> <span class="n">Ellipsoids</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pa</span><span class="o">.</span><span class="n">duplicate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">gid</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">duplicate</span>
                <span class="n">pa</span><span class="o">.</span><span class="n">inner</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">create_poly</span><span class="p">(</span><span class="n">Ellipsoids</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span><span class="o">.</span><span class="n">inner</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gid</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">id</span>
            <span class="n">pa</span><span class="o">.</span><span class="n">sync_poly</span><span class="p">()</span>
            <span class="n">vox</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># search for voxel centers inside the polygon</span>
            <span class="k">for</span> <span class="n">iv</span><span class="p">,</span> <span class="n">ctr</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vox_center_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">pa</span><span class="o">.</span><span class="n">inner</span><span class="o">.</span><span class="n">find_simplex</span><span class="p">(</span><span class="n">ctr</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">iv</span> <span class="ow">in</span> <span class="n">assigned_vox</span><span class="p">:</span>
                        <span class="c1"># voxel has already been assigned to different grain.</span>
                        <span class="c1"># check nearest center and re-assign if necessary</span>
                        <span class="n">dst1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">ctr</span> <span class="o">-</span> <span class="n">pa</span><span class="o">.</span><span class="n">get_pos</span><span class="p">())</span>
                        <span class="k">for</span> <span class="n">igr</span><span class="p">,</span> <span class="n">vlist</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="k">if</span> <span class="n">iv</span> <span class="ow">in</span> <span class="n">vlist</span><span class="p">:</span>
                                <span class="n">dst2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">ctr</span> <span class="o">-</span> <span class="n">Ellipsoids</span><span class="p">[</span><span class="n">igr</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_pos</span><span class="p">())</span>
                                <span class="k">if</span> <span class="n">dst1</span> <span class="o">&lt;</span> <span class="n">dst2</span><span class="p">:</span>
                                    <span class="n">vox</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span>
                                    <span class="n">pa</span><span class="o">.</span><span class="n">inside_voxels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span>
                                    <span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="p">[</span><span class="n">igr</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span>
                                    <span class="n">Ellipsoids</span><span class="p">[</span><span class="n">igr</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">inside_voxels</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span>
                                <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">assigned_vox</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span>
                        <span class="n">vox</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span>
                        <span class="n">pa</span><span class="o">.</span><span class="n">inside_voxels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">gid</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span> <span class="o">=</span> <span class="n">vox</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Starting RVE voxelization&#39;</span><span class="p">)</span>

    <span class="c1"># Find the voxels belonging to each grain by growing ellipsoid each time</span>
    <span class="k">if</span> <span class="n">prec_vf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">prec_vf</span> <span class="o">=</span> <span class="mf">1.</span>

    <span class="c1"># decide if voxels shall be assigned to ellipsoids or inner polygons</span>
    <span class="k">if</span> <span class="n">Ellipsoids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">inner</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ell2vox</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">poly2vox</span><span class="p">()</span>

    <span class="c1"># generate array of voxelized structure with grain IDs</span>
    <span class="c1"># if fill_factor &lt; 1.0, empty voxels will have grain ID 0</span>
    <span class="n">gr_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">nvox</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">igr</span><span class="p">,</span> <span class="n">vlist</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">vlist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vlist</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">gr_arr</span><span class="p">[</span><span class="n">vlist</span><span class="p">]</span> <span class="o">=</span> <span class="n">igr</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">gr_arr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># some voxels have not been assigned to grains, check is assignment is required</span>
        <span class="k">if</span> <span class="n">prec_vf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">iv</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">:</span>
                <span class="n">gr_arr</span><span class="p">[</span><span class="n">iv</span><span class="p">]</span> <span class="o">=</span> <span class="n">gr_arr</span><span class="p">[</span><span class="n">iv</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># assign voxel to neighbor grain</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Warning: Assigned voxel </span><span class="si">{</span><span class="n">iv</span><span class="si">}</span><span class="s1"> to grain </span><span class="si">{</span><span class="n">gr_arr</span><span class="p">[</span><span class="n">iv</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
    <span class="n">mesh</span><span class="o">.</span><span class="n">grains</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">gr_arr</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>


    <span class="c1"># generate array of voxelized structure with phase numbers</span>
    <span class="c1"># and dict of phase numbers for each grain</span>
    <span class="c1"># empty voxels will get phase number 1 and be assigned to grain with key 0</span>
    <span class="n">ph_arr</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">nvox</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">mesh</span><span class="o">.</span><span class="n">grain_phase_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">mesh</span><span class="o">.</span><span class="n">ngrains_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nphases</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">igr</span><span class="p">,</span> <span class="n">vlist</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">vlist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vlist</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">ip</span> <span class="o">=</span> <span class="n">Ellipsoids</span><span class="p">[</span><span class="n">igr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">phasenum</span>
        <span class="n">ph_arr</span><span class="p">[</span><span class="n">vlist</span><span class="p">]</span> <span class="o">=</span> <span class="n">ip</span>
        <span class="n">mesh</span><span class="o">.</span><span class="n">grain_phase_dict</span><span class="p">[</span><span class="n">igr</span><span class="p">]</span> <span class="o">=</span> <span class="n">ip</span>
        <span class="n">mesh</span><span class="o">.</span><span class="n">ngrains_phase</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">ph_arr</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ph_arr</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># assign phase 1 to empty voxels</span>
    <span class="n">mesh</span><span class="o">.</span><span class="n">phases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ph_arr</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
    <span class="n">vf_cur</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">/</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nvox</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Completed RVE voxelization&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">prec_vf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">prec_vf</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Dispersed phase (precipitates/porosity):&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Volume fraction in voxelized grains: </span><span class="si">{</span><span class="n">vf_cur</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Target volume fraction = </span><span class="si">{</span><span class="n">prec_vf</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">mesh</span><span class="o">.</span><span class="n">prec_vf_voxels</span> <span class="o">=</span> <span class="n">vf_cur</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Grain with key &quot;0&quot; already exists. Should be reserved for matrix phase in structures &#39;</span> <span class="o">+</span>
                             <span class="s1">&#39;with precipitates or porosity. Cannot continue with precipitate simulation.&#39;</span><span class="p">)</span>
        <span class="n">mesh</span><span class="o">.</span><span class="n">grain_dict</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">mesh</span><span class="o">.</span><span class="n">grain_phase_dict</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">mesh</span><span class="o">.</span><span class="n">ngrains_phase</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">vf_cur</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;WARNING: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span><span class="si">}</span><span class="s1"> voxels have not been assigned to grains.&#39;</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Try to assign empty voxels to neighbor grain&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mesh</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright This work is published under a CC BY-SA 4.0 license.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>