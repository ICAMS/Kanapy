

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>kanapy.texture &mdash; kanapy 6.5.3.post1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=53ab5b41"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            kanapy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../applications.html">Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../method.html">Modeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kanapy.html">Code documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../history.html">History</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">kanapy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">kanapy.texture</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for kanapy.texture</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Tools for analysis of EBSD maps in form of .ang files</span>

<span class="sd">@author: Alexander Hartmaier, Abhishek Biswas, ICAMS, Ruhr-Universit√§t Bochum</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">networkx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nx</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib.colors</span><span class="w"> </span><span class="kn">import</span> <span class="n">LinearSegmentedColormap</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">kanapy.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_grain_geom</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.stats</span><span class="w"> </span><span class="kn">import</span> <span class="n">lognorm</span><span class="p">,</span> <span class="n">vonmises</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">ConvexHull</span><span class="p">,</span> <span class="n">KDTree</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.special</span><span class="w"> </span><span class="kn">import</span> <span class="n">legendre</span><span class="p">,</span> <span class="n">beta</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">fminbound</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.integrate</span><span class="w"> </span><span class="kn">import</span> <span class="n">quad</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">skimage.segmentation</span><span class="w"> </span><span class="kn">import</span> <span class="n">mark_boundaries</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">orix</span><span class="w"> </span><span class="kn">import</span> <span class="n">io</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">orix</span><span class="w"> </span><span class="kn">import</span> <span class="n">plot</span> <span class="k">as</span> <span class="n">ox_plot</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">orix.quaternion</span><span class="w"> </span><span class="kn">import</span> <span class="n">Orientation</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">orix.quaternion.symmetry</span><span class="w"> </span><span class="kn">import</span> <span class="n">Symmetry</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">orix.sampling</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_sample_fundamental</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">orix.vector</span><span class="w"> </span><span class="kn">import</span> <span class="n">Miller</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ABC</span>


<div class="viewcode-block" id="get_distinct_colormap">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.get_distinct_colormap">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_distinct_colormap</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;prism&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate N visually distinct colors as an RGB colormap.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - N: int, number of colors</span>
<span class="sd">    - seed: optional int, random seed for reproducibility</span>

<span class="sd">    Returns:</span>
<span class="sd">    - cmap: list of N RGB tuples in [0, 1]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">col_</span> <span class="o">=</span> <span class="p">[</span><span class="n">colors</span><span class="p">(</span><span class="n">i</span><span class="p">)[:</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">col_</span></div>



<div class="viewcode-block" id="neighbors">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.neighbors">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">neighbors</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the neighboring coordinates of a cell in a 2D grid.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    r : int</span>
<span class="sd">        Row index of the cell.</span>
<span class="sd">    c : int</span>
<span class="sd">        Column index of the cell.</span>
<span class="sd">    connectivity : int, optional</span>
<span class="sd">        Type of connectivity. Options are:</span>
<span class="sd">        - 1 or 4 : 4-connected neighbors (up, down, left, right)</span>
<span class="sd">        - 8      : 8-connected neighbors (includes diagonals)</span>
<span class="sd">        Default is 8.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    neighbors : list of tuple</span>
<span class="sd">        List of (row, column) tuples representing neighboring cells.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; neighbors(2, 3, connectivity=4)</span>
<span class="sd">    [(3, 3), (1, 3), (2, 4), (2, 2)]</span>

<span class="sd">    &gt;&gt;&gt; neighbors(2, 3)</span>
<span class="sd">    [(3, 2), (3, 3), (3, 4), (2, 2), (2, 4), (1, 2), (1, 3), (1, 4)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">connectivity</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">connectivity</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">r</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span></div>



<div class="viewcode-block" id="merge_nodes">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.merge_nodes">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">merge_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">):</span>
    <span class="c1"># merge pixel lists of node 1 into node 2, delete node 1</span>
    <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node2</span><span class="p">][</span><span class="s1">&#39;pixels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node1</span><span class="p">][</span><span class="s1">&#39;pixels&#39;</span><span class="p">],</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node2</span><span class="p">][</span><span class="s1">&#39;pixels&#39;</span><span class="p">]))</span>
    <span class="n">ntot</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node2</span><span class="p">][</span><span class="s1">&#39;ori_av&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node1</span><span class="p">][</span><span class="s1">&#39;ori_av&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node1</span><span class="p">][</span><span class="s1">&#39;npix&#39;</span><span class="p">]</span> <span class="o">+</span>
                                <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node2</span><span class="p">][</span><span class="s1">&#39;ori_av&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node2</span><span class="p">][</span><span class="s1">&#39;npix&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="n">ntot</span>
    <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node2</span><span class="p">][</span><span class="s1">&#39;npix&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ntot</span>  <span class="c1"># update length</span>
    <span class="k">if</span> <span class="s1">&#39;hull&#39;</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node2</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="c1"># update hull if it exists already</span>
        <span class="n">sh</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;label_map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node2</span><span class="p">][</span><span class="s1">&#39;pixels&#39;</span><span class="p">],</span> <span class="n">sh</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">pts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;dx&#39;</span><span class="p">]</span>  <span class="c1"># convert pixel distances to micron</span>
        <span class="n">pts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;dy&#39;</span><span class="p">]</span>
        <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node2</span><span class="p">][</span><span class="s1">&#39;hull&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ConvexHull</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
    <span class="c1"># add new edges (will ignore if edge already exists)</span>
    <span class="k">for</span> <span class="n">neigh</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">node1</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">node2</span> <span class="o">!=</span> <span class="n">neigh</span><span class="p">:</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">node2</span><span class="p">,</span> <span class="n">neigh</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">node1</span><span class="p">)</span>  <span class="c1"># remove grain1 and all its edges</span>
    <span class="c1"># update label map</span>
    <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;label_map&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">node1</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;label_map&#39;</span><span class="p">][</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="n">node2</span></div>



<div class="viewcode-block" id="find_largest_neighbor">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.find_largest_neighbor">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">find_largest_neighbor</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="c1"># find the largest neighbor of given grain</span>
    <span class="n">size_ln</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># size of largest neighbor grain</span>
    <span class="n">num_ln</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># ID of largest neighbor grain</span>
    <span class="k">for</span> <span class="n">neigh</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">neigh</span><span class="p">][</span><span class="s1">&#39;npix&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">size_ln</span><span class="p">:</span>
            <span class="n">size_ln</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">neigh</span><span class="p">][</span><span class="s1">&#39;npix&#39;</span><span class="p">]</span>
            <span class="n">num_ln</span> <span class="o">=</span> <span class="n">neigh</span>  <span class="c1"># number of largest neighbor grain</span>
    <span class="k">if</span> <span class="n">num_ln</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Grain </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s1"> has no neighbors.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">num_ln</span> <span class="o">==</span> <span class="n">node</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Corrupted graph with circular edges: </span><span class="si">{</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">num_ln</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">num_ln</span></div>



<div class="viewcode-block" id="find_sim_neighbor">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.find_sim_neighbor">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">find_sim_neighbor</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">nn</span><span class="p">):</span>
    <span class="n">sym</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;symmetry&#39;</span><span class="p">]</span>
    <span class="n">ori0</span> <span class="o">=</span> <span class="n">Orientation</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">nn</span><span class="p">][</span><span class="s1">&#39;ori_av&#39;</span><span class="p">],</span> <span class="n">sym</span><span class="p">)</span>
    <span class="n">on</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ng</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">neigh</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">nn</span><span class="p">]:</span>
        <span class="n">ang</span> <span class="o">=</span> <span class="n">ori0</span><span class="o">.</span><span class="n">angle_with</span><span class="p">(</span><span class="n">Orientation</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">neigh</span><span class="p">][</span><span class="s1">&#39;ori_av&#39;</span><span class="p">],</span> <span class="n">sym</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">on</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ang</span><span class="p">)</span>
        <span class="n">ng</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neigh</span><span class="p">)</span>
    <span class="n">nn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">on</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ng</span><span class="p">[</span><span class="n">nn</span><span class="p">],</span> <span class="n">on</span><span class="p">[</span><span class="n">nn</span><span class="p">]</span></div>



<div class="viewcode-block" id="summarize_labels">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.summarize_labels">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">summarize_labels</span><span class="p">(</span><span class="n">label_array</span><span class="p">,</span> <span class="n">rotations</span><span class="p">,</span> <span class="n">wanted_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    label_array: (H,W) int</span>
<span class="sd">    rotations:   (H*W, D) float  (emap.rotations.data)</span>
<span class="sd">    wanted_labels: Sequenz von Label-IDs; None =&gt; alle im Array</span>

<span class="sd">    returns: list[(lbl, info_dict)]</span>
<span class="sd">             info_dict: {&#39;npix&#39;, &#39;pixels&#39;, &#39;ori_av&#39;, &#39;ori_std&#39;}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lab</span> <span class="o">=</span> <span class="n">label_array</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">lab</span><span class="o">.</span><span class="n">size</span>
    <span class="n">rot</span> <span class="o">=</span> <span class="n">rotations</span>  <span class="c1"># shape (N, D)</span>

    <span class="c1"># Gruppierung: alle Pixel nach Label sortieren</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">lab</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;stable&quot;</span><span class="p">)</span>
    <span class="n">lab_sorted</span> <span class="o">=</span> <span class="n">lab</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>

    <span class="c1"># Eindeutige Labels + Segmentstarts + Counts</span>
    <span class="n">uniq</span><span class="p">,</span> <span class="n">starts</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">lab_sorted</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">ends</span> <span class="o">=</span> <span class="n">starts</span> <span class="o">+</span> <span class="n">counts</span>

    <span class="c1"># Rotations in derselben Reihenfolge sortieren</span>
    <span class="n">rot_sorted</span> <span class="o">=</span> <span class="n">rot</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>

    <span class="c1"># Mittelwerte und Standardabweichungen pro Segment (reduceat ist sehr schnell)</span>
    <span class="n">sums</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">rot_sorted</span><span class="p">,</span> <span class="n">starts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">means</span> <span class="o">=</span> <span class="n">sums</span> <span class="o">/</span> <span class="n">counts</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>

    <span class="n">sq</span> <span class="o">=</span> <span class="n">rot_sorted</span> <span class="o">*</span> <span class="n">rot_sorted</span>
    <span class="n">sums_sq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">sq</span><span class="p">,</span> <span class="n">starts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">vars_</span> <span class="o">=</span> <span class="n">sums_sq</span> <span class="o">/</span> <span class="n">counts</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">means</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">stds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">vars_</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>

    <span class="c1"># Pixelindizes pro Label (als Listen von 1D-Indizes)</span>
    <span class="n">pixels_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">starts</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>  <span class="c1"># Liste der Segmente in uniq-Reihenfolge</span>

    <span class="c1"># Auswahl / Re-Ordering auf gew√ºnschte Labels</span>
    <span class="k">if</span> <span class="n">wanted_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">labels_out</span> <span class="o">=</span> <span class="n">uniq</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uniq</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">labels_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">wanted_labels</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">{</span><span class="nb">int</span><span class="p">(</span><span class="n">l</span><span class="p">):</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">uniq</span><span class="p">)}</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">pos</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">labels_out</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">labels_out</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="n">info</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;npix&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
            <span class="s2">&quot;pixels&quot;</span><span class="p">:</span> <span class="n">pixels_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>              <span class="c1"># 1D-Indices in label_array.ravel()</span>
            <span class="s2">&quot;ori_av&quot;</span><span class="p">:</span> <span class="n">means</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>                   <span class="c1"># shape (D,)</span>
            <span class="s2">&quot;ori_std&quot;</span><span class="p">:</span> <span class="n">stds</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>                   <span class="c1"># shape (D,)</span>
        <span class="p">}</span>
        <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">lbl</span><span class="p">),</span> <span class="n">info</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">nodes</span></div>



<div class="viewcode-block" id="build_graph_from_labeled_pixels">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.build_graph_from_labeled_pixels">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">build_graph_from_labeled_pixels</span><span class="p">(</span><span class="n">label_array</span><span class="p">,</span> <span class="n">emap</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
    <span class="c1"># t1 = time.time()</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">summarize_labels</span><span class="p">(</span><span class="n">label_array</span><span class="p">,</span> <span class="n">emap</span><span class="o">.</span><span class="n">rotations</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="c1"># t2 = time.time()</span>
    <span class="c1"># print(f&#39;Time for extracting nodes: {t2 - t1}&#39;)</span>
    <span class="c1"># print(f&#39;Building microstructure graph with {len(nodes)} nodes (grains).&#39;)</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">label_map</span><span class="o">=</span><span class="n">label_array</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="n">emap</span><span class="o">.</span><span class="n">phases</span><span class="o">.</span><span class="n">point_groups</span><span class="p">[</span><span class="n">phase</span><span class="p">],</span>
                 <span class="n">dx</span><span class="o">=</span><span class="n">emap</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="n">emap</span><span class="o">.</span><span class="n">dy</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    <span class="c1"># t3 = time.time()</span>
    <span class="c1"># print(f&#39;Time for building graph: {t3 - t2}&#39;)</span>

    <span class="c1"># print(&#39;Adding edges (grain boundaries) to microstructure graph.&#39;)</span>
    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">label_array</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cols</span><span class="p">):</span>
            <span class="n">label_here</span> <span class="o">=</span> <span class="n">label_array</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">px</span><span class="p">,</span> <span class="n">py</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">):</span>
                <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">px</span> <span class="o">&lt;</span> <span class="n">rows</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">py</span> <span class="o">&lt;</span> <span class="n">cols</span><span class="p">:</span>
                    <span class="n">neighbor_label</span> <span class="o">=</span> <span class="n">label_array</span><span class="p">[</span><span class="n">px</span><span class="p">,</span> <span class="n">py</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">neighbor_label</span> <span class="o">!=</span> <span class="n">label_here</span><span class="p">:</span>
                        <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">label_here</span><span class="p">,</span> <span class="n">neighbor_label</span><span class="p">)</span>
    <span class="c1"># t4 = time.time()</span>
    <span class="c1"># print(f&#39;Time for adding edges: {t4 - t3}&#39;)</span>
    <span class="k">return</span> <span class="n">G</span></div>



<div class="viewcode-block" id="visualize_graph">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.visualize_graph">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">visualize_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mi">12</span><span class="p">):</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>  <span class="c1"># positioning</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;lightblue&#39;</span><span class="p">,</span> <span class="n">edge_color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span>
            <span class="n">node_size</span><span class="o">=</span><span class="n">node_size</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="n">fs</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>



<div class="viewcode-block" id="export_graph">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.export_graph">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">export_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;graphml&quot;</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;graphml&quot;</span><span class="p">:</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">write_graphml</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;gexf&quot;</span><span class="p">:</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">write_gexf</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only &#39;graphml&#39; or &#39;gexf&#39; formats are supported.&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="find_similar_regions">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.find_similar_regions">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">find_similar_regions</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.087</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identifies connected regions of similar values in a 2D array.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        array (ndarray): 2D NumPy array with values.</span>
<span class="sd">        tolerance (float): Max allowed difference between connected values.</span>
<span class="sd">        connectivity (int): 1 for 4-connectivity, 2 for 8-connectivity.</span>

<span class="sd">    Returns:</span>
<span class="sd">        labeled_array (ndarray): 2D array of region labels.</span>
<span class="sd">        num_features (int): Total number of connected regions found.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">labeled_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">current_label</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cols</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]:</span>
                <span class="n">ref_val</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>
                <span class="n">stack</span> <span class="o">=</span> <span class="p">[(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)]</span>
                <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
                    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rows</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">cols</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">ref_val</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>
                            <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="n">labeled_array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_label</span>
                            <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">neighbors</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">connectivity</span><span class="p">))</span>
                <span class="n">current_label</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">labeled_array</span><span class="p">,</span> <span class="n">current_label</span> <span class="o">-</span> <span class="mi">1</span></div>



<div class="viewcode-block" id="calc_error">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.calc_error">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calc_error</span><span class="p">(</span><span class="n">odf_ref</span><span class="p">,</span> <span class="n">odf_test</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="mf">10.</span><span class="p">):</span>
    <span class="n">cs</span> <span class="o">=</span> <span class="n">odf_ref</span><span class="o">.</span><span class="n">orientations</span><span class="o">.</span><span class="n">symmetry</span>
    <span class="k">if</span> <span class="n">cs</span> <span class="o">!=</span> <span class="n">odf_test</span><span class="o">.</span><span class="n">orientations</span><span class="o">.</span><span class="n">symmetry</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Symmetries of ODF&#39;s do not match.&quot;</span><span class="p">)</span>
    <span class="n">so3g</span> <span class="o">=</span> <span class="n">get_sample_fundamental</span><span class="p">(</span><span class="n">resolution</span><span class="o">=</span><span class="n">res</span><span class="p">,</span> <span class="n">point_group</span><span class="o">=</span><span class="n">cs</span><span class="p">)</span>
    <span class="n">so3g</span> <span class="o">=</span> <span class="n">Orientation</span><span class="p">(</span><span class="n">so3g</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="n">cs</span><span class="p">)</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">odf_ref</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">so3g</span><span class="p">)</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">odf_test</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">so3g</span><span class="p">)</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">p1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span> <span class="o">-</span> <span class="n">p2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p2</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">err</span></div>



<div class="viewcode-block" id="calc_orientations">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.calc_orientations">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calc_orientations</span><span class="p">(</span><span class="n">odf</span><span class="p">,</span> <span class="n">nori</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">oq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nori</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
    <span class="n">indstart</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">rem</span> <span class="o">=</span> <span class="n">nori</span>
    <span class="n">cs</span> <span class="o">=</span> <span class="n">odf</span><span class="o">.</span><span class="n">orientations</span><span class="o">.</span><span class="n">symmetry</span>
    <span class="n">hw</span> <span class="o">=</span> <span class="n">odf</span><span class="o">.</span><span class="n">halfwidth</span>
    <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">hw</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="n">so3g</span> <span class="o">=</span> <span class="n">get_sample_fundamental</span><span class="p">(</span><span class="n">resolution</span><span class="o">=</span><span class="n">res</span><span class="p">,</span> <span class="n">point_group</span><span class="o">=</span><span class="n">cs</span><span class="p">)</span>  <span class="c1"># generate fine mesh in fund. region; res in degree!</span>
    <span class="n">so3g</span> <span class="o">=</span> <span class="n">Orientation</span><span class="p">(</span><span class="n">so3g</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="n">cs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">so3g</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="o">*</span><span class="n">nori</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Resolution of SO3 grid in &quot;calc_orientations&quot; is too coarse: </span><span class="si">{</span><span class="n">res</span><span class="si">}</span><span class="s1">¬∞.</span><span class="se">\n</span><span class="s1">&#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;Only </span><span class="si">{</span><span class="n">so3g</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s1"> grid points available for </span><span class="si">{</span><span class="n">nori</span><span class="si">}</span><span class="s1"> desired orientations.&#39;</span><span class="p">)</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">odf</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">so3g</span><span class="p">)</span>  <span class="c1"># value of ODF at each gridpoint</span>
    <span class="c1"># do MC sampling of ODF to generate nori orientations</span>
    <span class="n">ctr</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">rem</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ctr</span> <span class="o">&lt;</span> <span class="mi">200</span><span class="p">:</span>
        <span class="n">rn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">so3g</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">vn</span> <span class="o">=</span> <span class="n">val</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">rn</span><span class="p">)</span> <span class="o">*</span> <span class="n">nori</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="n">ori</span> <span class="o">=</span> <span class="n">so3g</span><span class="p">[</span><span class="n">vn</span> <span class="o">&gt;=</span> <span class="n">rn</span><span class="p">]</span>
        <span class="n">no</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ori</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">rem</span><span class="p">)</span>
        <span class="n">oq</span><span class="p">[</span><span class="n">indstart</span><span class="p">:</span><span class="n">indstart</span><span class="o">+</span><span class="n">no</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">ori</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">no</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">indstart</span> <span class="o">+=</span> <span class="n">no</span>
        <span class="n">rem</span> <span class="o">-=</span> <span class="n">no</span>
        <span class="n">ctr</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">ctr</span> <span class="o">&gt;=</span> <span class="mi">200</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Monte Carlo algorithm in &quot;calc_orientations&quot; did not converge for resolution </span><span class="si">{</span><span class="n">res</span><span class="si">}</span><span class="s1">.</span><span class="se">\n</span><span class="s1">&#39;</span>
                           <span class="sa">f</span><span class="s1">&#39;Orientations found </span><span class="si">{</span><span class="n">indstart</span><span class="si">}</span><span class="s1"> orientations. Target was </span><span class="si">{</span><span class="n">nori</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Orientation</span><span class="p">(</span><span class="n">oq</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="n">cs</span><span class="p">)</span></div>



<div class="viewcode-block" id="odf_est">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.odf_est">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">odf_est</span><span class="p">(</span><span class="n">ori</span><span class="p">,</span> <span class="n">odf</span><span class="p">,</span> <span class="n">nstep</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">halfwidth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">e0</span> <span class="o">=</span> <span class="mf">1e8</span>
    <span class="n">st_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>
    <span class="n">hwmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">hwmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">nstep</span> <span class="o">*</span> <span class="n">st_rad</span>
    <span class="k">if</span> <span class="n">halfwidth</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">odf</span><span class="o">.</span><span class="n">halfwidth</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">nstep</span> <span class="o">*</span> <span class="n">st_rad</span><span class="p">,</span> <span class="n">hwmin</span><span class="p">,</span> <span class="n">hwmax</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Initial halfwidth set to </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">hw</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">halfwidth</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">st_rad</span><span class="p">,</span> <span class="n">hwmin</span><span class="p">,</span> <span class="n">hwmax</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Initial halfwidth is </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">hw</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nstep</span><span class="p">):</span>
        <span class="n">todf</span> <span class="o">=</span> <span class="n">ODF</span><span class="p">(</span><span class="n">ori</span><span class="p">,</span> <span class="n">halfwidth</span><span class="o">=</span><span class="n">hw</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">calc_error</span><span class="p">(</span><span class="n">odf</span><span class="p">,</span> <span class="n">todf</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Iteration </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s1">: error=</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s1">, halfwidth=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">hw</span><span class="p">)</span><span class="si">}</span><span class="s1">¬∞&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">e</span> <span class="o">&gt;</span> <span class="n">e0</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">e0</span> <span class="o">=</span> <span class="n">e</span>
        <span class="n">hw</span> <span class="o">+=</span> <span class="n">st_rad</span>
    <span class="c1"># return last value before error increased</span>
    <span class="n">hw</span> <span class="o">-=</span> <span class="n">st_rad</span>
    <span class="n">todf</span> <span class="o">=</span> <span class="n">ODF</span><span class="p">(</span><span class="n">ori</span><span class="p">,</span> <span class="n">halfwidth</span><span class="o">=</span><span class="n">hw</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">todf</span></div>



<div class="viewcode-block" id="plot_pole_figure">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.plot_pole_figure">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">plot_pole_figure</span><span class="p">(</span><span class="n">orientations</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># plot inverse pole figure</span>
    <span class="c1"># &lt;111&gt; poles in the sample reference frame</span>
    <span class="k">if</span> <span class="n">vector</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vector</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orientations</span><span class="p">,</span> <span class="n">Orientation</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">orientations</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;No orientations provided: </span><span class="si">{</span><span class="n">orientations</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
        <span class="n">scf</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">scf</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">orientations</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">250</span><span class="o">*</span><span class="n">scf</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">scf</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="n">t_</span> <span class="o">=</span> <span class="n">Miller</span><span class="p">(</span><span class="n">uvw</span><span class="o">=</span><span class="n">vector</span><span class="p">,</span> <span class="n">phase</span><span class="o">=</span><span class="n">phase</span><span class="p">)</span><span class="o">.</span><span class="n">symmetrise</span><span class="p">(</span><span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">t_all</span> <span class="o">=</span> <span class="n">orientations</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">t_</span><span class="p">)</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
    <span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">211</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s2">&quot;stereographic&quot;</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">t_all</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_labels</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">phase</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot; $\left&lt;&quot;</span> <span class="o">+</span>
                  <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}{</span><span class="n">vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}{</span><span class="n">vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">+</span>
                  <span class="sa">r</span><span class="s2">&quot;\right&gt;$ PF&quot;</span><span class="p">)</span>
    <span class="n">ax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">212</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s2">&quot;stereographic&quot;</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">pole_density_function</span><span class="p">(</span><span class="n">t_all</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">set_labels</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">phase</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot; $\left&lt;&quot;</span> <span class="o">+</span>
                  <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}{</span><span class="n">vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}{</span><span class="n">vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">+</span>
                  <span class="sa">r</span><span class="s2">&quot;\right&gt;$ PDF&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>



<div class="viewcode-block" id="plot_pole_figure_proj">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.plot_pole_figure_proj">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">plot_pole_figure_proj</span><span class="p">(</span><span class="n">orientations</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># Some sample direction, v</span>
    <span class="k">if</span> <span class="n">vector</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vector</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">Miller</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">v_title</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">vector</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">v_title</span> <span class="o">=</span> <span class="n">title</span>
    <span class="k">if</span> <span class="n">orientations</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;No orientations provided: </span><span class="si">{</span><span class="n">orientations</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
        <span class="n">scf</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">scf</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">orientations</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">250</span><span class="o">*</span><span class="n">scf</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">scf</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orientations</span><span class="p">,</span> <span class="n">Orientation</span><span class="p">)</span>
    <span class="c1"># Rotate sample direction v into every crystal orientation O</span>
    <span class="n">t_</span> <span class="o">=</span> <span class="n">orientations</span> <span class="o">*</span> <span class="n">v</span>

    <span class="c1"># Set IPDF range</span>
    <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

    <span class="n">subplot_kw</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;projection&quot;</span><span class="p">:</span> <span class="s2">&quot;ipf&quot;</span><span class="p">,</span> <span class="s2">&quot;symmetry&quot;</span><span class="p">:</span> <span class="n">phase</span><span class="o">.</span><span class="n">point_group</span><span class="o">.</span><span class="n">laue</span><span class="p">,</span> <span class="s2">&quot;direction&quot;</span><span class="p">:</span> <span class="n">v</span><span class="p">}</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>

    <span class="n">ax0</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">211</span><span class="p">,</span> <span class="o">**</span><span class="n">subplot_kw</span><span class="p">)</span>
    <span class="n">ax0</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">t_</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax0</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;EBSD data, </span><span class="si">{</span><span class="n">phase</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">v_title</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">ax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">212</span><span class="p">,</span> <span class="o">**</span><span class="n">subplot_kw</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">pole_density_function</span><span class="p">(</span><span class="n">t_</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;EBSD data, </span><span class="si">{</span><span class="n">phase</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">v_title</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="find_orientations_fast">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.find_orientations_fast">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">find_orientations_fast</span><span class="p">(</span><span class="n">ori1</span><span class="p">:</span> <span class="n">Orientation</span><span class="p">,</span> <span class="n">ori2</span><span class="p">:</span> <span class="n">Orientation</span><span class="p">,</span> <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find closest matches in ori1 for each orientation in ori2 using KDTree.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ori1 : Orientation</span>
<span class="sd">        Orientation database (e.g., EBSD orientations).</span>
<span class="sd">    ori2 : Orientation</span>
<span class="sd">        Orientations to match (e.g., grain mean orientations).</span>
<span class="sd">    tol : float</span>
<span class="sd">        Angular tolerance in radians.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    matches : np.ndarray</span>
<span class="sd">        Array of indices in ori1 matching each entry in ori2; -1 if no match found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get quaternions</span>
    <span class="n">q1</span> <span class="o">=</span> <span class="n">ori1</span><span class="o">.</span><span class="n">data</span>
    <span class="n">q2</span> <span class="o">=</span> <span class="n">ori2</span><span class="o">.</span><span class="n">data</span>

    <span class="n">tree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">q2</span><span class="p">)</span>  <span class="c1"># KDTree in 4D quaternion space for ori2 (typically, regular SO3 grid)</span>
    <span class="n">dists</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">q1</span><span class="p">)</span>  <span class="c1"># For every orientation in ori1, look for nearest neighbor in ori2 (grid)</span>

    <span class="c1"># create list of length or ori2, and store counts and indices of nearest neighbors in ori1</span>
    <span class="n">matches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ori2</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">neigh_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
        <span class="n">matches</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">neigh_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">neigh_dict</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">neigh_dict</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">matches</span><span class="p">,</span> <span class="n">neigh_dict</span></div>



<div class="viewcode-block" id="texture_reconstruction">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.texture_reconstruction">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">texture_reconstruction</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">ebsd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ebsdfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">orientations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">grainsfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">grains</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kernel_halfwidth</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                          <span class="n">res_low</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">res_high</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">res_step</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">lim</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function systematically reconstructs an ODF by a given number of</span>
<span class="sd">    orientations (refer .....)</span>
<span class="sd">    also the misorientation distribution is reproduced</span>


<span class="sd">    Inputs:</span>
<span class="sd">    1) ns: number of reduced orientations/grains in RVE</span>
<span class="sd">    2) Either path+filename of ebsd data saved as *.mat file (it should</span>
<span class="sd">      contain only one phase/mineral) or ebsd(single phase)/orientations</span>
<span class="sd">    3) Either path+filename of the estiamted grains from above</span>
<span class="sd">      EBSD saved as *.mat file (it should contain only one phase/mineral)</span>
<span class="sd">      or kernel(only deLaValeePoussinKernel)/kernelshape, if nothing</span>
<span class="sd">      mentioned then default value kappa = 5 (degree) is assumed.</span>

<span class="sd">    Output: reduced orientation set, ODF and L1 error</span>

<span class="sd">    Following steps described in Biswas et al (https://doi.org/10.1107/S1600576719017138)</span>

<span class="sd">   input fields and checks</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ebsd</span>
<span class="sd">    ebsdfile</span>
<span class="sd">    orientations</span>
<span class="sd">    grainsfile</span>
<span class="sd">    grains</span>
<span class="sd">    kernel</span>
<span class="sd">    kernel_halfwidth</span>
<span class="sd">    res_low</span>
<span class="sd">    res_high</span>
<span class="sd">    res_step</span>
<span class="sd">    lim</span>
<span class="sd">    verbose</span>
<span class="sd">    ns</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    orired_f</span>
<span class="sd">    odfred_f</span>
<span class="sd">    ero</span>
<span class="sd">    res</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ori</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">psi</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">ebsdfile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span><span class="s1">&#39;Option &quot;ebsdMatFile&quot; is not yet supported.&#39;</span><span class="p">)</span>
        <span class="c1"># ind = args.index(&#39;ebsdMatFile&#39;) + 1</span>
        <span class="c1"># ebsd = loadmat(args[ind])</span>
        <span class="c1"># ebsd_var = list(ebsd.keys())[0]</span>
        <span class="c1"># ebsd = ebsd[ebsd_var]</span>
        <span class="c1"># assert len(np.unique(ebsd.phaseId)) == 1, &#39;EBSD has multiple phases&#39;</span>
        <span class="c1"># ori = ebsd.orientations</span>
    <span class="k">if</span> <span class="n">ebsd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ebsd</span><span class="p">,</span> <span class="n">EBSDmap</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Argument &quot;ebsd&quot; must be of type EBSDmap.&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ebsd</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phases</span><span class="o">.</span><span class="n">ids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;EBSD has multiple phases&#39;</span>
        <span class="k">if</span> <span class="n">ori</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Both arguments &quot;ebsd&quot; and &quot;ori&quot; are given, using EBSD map orientations.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ori</span> <span class="o">=</span> <span class="n">ebsd</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">orientations</span>
    <span class="k">if</span> <span class="n">orientations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orientations</span><span class="p">,</span> <span class="n">Orientation</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Argument &quot;orientations&quot; must be of type Orientation,&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ori</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Both EBSD map and orientations are given, using EBSD.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ori</span> <span class="o">=</span> <span class="n">orientations</span>

    <span class="k">if</span> <span class="n">grainsfile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Estimation of optimal kernel from grain files not supported. &#39;</span>
                        <span class="s1">&#39;DeLaValleePoussinKernel with halfwidth 5¬∞ will be used.</span><span class="se">\n</span><span class="s1">&#39;</span>
                        <span class="s1">&#39;Please use kanapy-mtex for support of optimal kernels.&#39;</span><span class="p">)</span>
        <span class="c1"># ind = args.index(&#39;grainsMatFile&#39;) + 1</span>
        <span class="c1"># grains = loadmat(args[ind])</span>
        <span class="c1"># grains_var = list(grains.keys())[0]</span>
        <span class="c1"># grains = grains[grains_var]</span>
        <span class="c1"># assert len(np.unique(grains.phaseId)) == 1, &#39;Grains has multiple phases&#39;</span>
        <span class="c1"># print(&#39;Optimum kernel estimated from mean orientations of grains&#39;)</span>
        <span class="c1"># psi = calcKernel(grains.meanOrientation)</span>
    <span class="k">if</span> <span class="n">grains</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Estimation of optimal kernel from grains not supported. &#39;</span>
                        <span class="s1">&#39;DeLaValleePoussinKernel with halfwidth 5¬∞ will be used.</span><span class="se">\n</span><span class="s1">&#39;</span>
                        <span class="s1">&#39;Please use kanapy-mtex for support of optimal kernels.&#39;</span><span class="p">)</span>
        <span class="c1">#assert len(np.unique(grains.phaseId)) == 1, &#39;Grains has multiple phases&#39;</span>
        <span class="c1">#print(&#39;Optimum kernel estimated from mean orientations of grains&#39;)</span>
        <span class="c1">#psi = calcKernel(grains.meanOrientation)</span>
    <span class="k">if</span> <span class="n">kernel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">DeLaValleePoussinKernel</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Only kernels of type &quot;DeLaValeePoussinKernel&quot; are supported.&#39;</span><span class="p">)</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="n">kernel</span>
    <span class="k">if</span> <span class="n">psi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="n">DeLaValleePoussinKernel</span><span class="p">(</span><span class="n">halfwidth</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">kernel_halfwidth</span><span class="p">))</span>

    <span class="c1"># Step 1: Create reference odf from given orientations with proper kernel</span>
    <span class="n">odf</span> <span class="o">=</span> <span class="n">ODF</span><span class="p">(</span><span class="n">ori</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="n">psi</span><span class="p">)</span>
    <span class="n">cs</span> <span class="o">=</span> <span class="n">ori</span><span class="o">.</span><span class="n">symmetry</span>

    <span class="n">ero</span> <span class="o">=</span> <span class="mf">10.</span>
    <span class="n">e_mod</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">hw_stored</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">hw</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">res_low</span><span class="p">,</span> <span class="n">res_high</span> <span class="o">+</span> <span class="n">res_step</span><span class="p">,</span> <span class="n">res_step</span><span class="p">):</span>
        <span class="c1"># Step 2: create equispaced grid of orientations</span>
        <span class="n">S3G</span> <span class="o">=</span> <span class="n">get_sample_fundamental</span><span class="p">(</span><span class="n">resolution</span><span class="o">=</span><span class="n">hw</span><span class="p">,</span> <span class="n">point_group</span><span class="o">=</span><span class="n">cs</span><span class="p">)</span>  <span class="c1"># resolution in degrees! ori.SS not considered</span>
        <span class="n">S3G</span> <span class="o">=</span> <span class="n">Orientation</span><span class="p">(</span><span class="n">S3G</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="n">cs</span><span class="p">)</span>
        <span class="c1"># Step 3: calculate number of orientations close to each grid point (0 if no orientation close to GP)</span>
        <span class="c1"># count close orientations from EBSD map for each grid point, and get list of neighbor indices</span>
        <span class="n">M</span><span class="p">,</span> <span class="n">neighs</span> <span class="o">=</span> <span class="n">find_orientations_fast</span><span class="p">(</span><span class="n">ori</span><span class="p">,</span> <span class="n">S3G</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mf">0.5</span><span class="p">))</span>
        <span class="n">ictr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">M</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># indices of gridpoints with non-zero counts</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">ictr</span><span class="p">]</span>  <span class="c1"># create weights from non-zero counts of EBSD orientations at gridpoints</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>  <span class="c1"># calculate weights</span>
        <span class="c1"># Step 4: Calculate scaling factor hval such that sum of all int(weights*hval) = ns</span>
        <span class="n">lval</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">hval</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">ns</span><span class="p">)</span>
        <span class="n">ifc</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">ihval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">hval</span> <span class="o">*</span> <span class="n">weights</span><span class="p">))</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">hval</span> <span class="o">-</span> <span class="n">lval</span> <span class="o">&gt;</span> <span class="n">hval</span> <span class="o">*</span> <span class="mf">1e-15</span> <span class="ow">or</span> <span class="n">ihval</span> <span class="o">&lt;</span> <span class="n">ns</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ihval</span> <span class="o">!=</span> <span class="n">ns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ihval</span> <span class="o">&lt;</span> <span class="n">ns</span><span class="p">:</span>
                <span class="n">hval_old</span> <span class="o">=</span> <span class="n">hval</span>
                <span class="n">hval</span> <span class="o">=</span> <span class="n">hval</span> <span class="o">+</span> <span class="n">ifc</span> <span class="o">*</span> <span class="p">(</span><span class="n">hval</span> <span class="o">-</span> <span class="n">lval</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="n">lval</span> <span class="o">=</span> <span class="n">hval_old</span>
                <span class="n">ifc</span> <span class="o">=</span> <span class="n">ifc</span> <span class="o">*</span> <span class="mf">2.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hval</span> <span class="o">=</span> <span class="p">(</span><span class="n">lval</span> <span class="o">+</span> <span class="n">hval</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="n">ifc</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="n">ihval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">hval</span> <span class="o">*</span> <span class="n">weights</span><span class="p">))</span>
        <span class="n">screen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">weights</span> <span class="o">*</span> <span class="n">hval</span><span class="p">)</span>  <span class="c1"># number of orientations associated to each grid point</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">screen</span><span class="p">)</span> <span class="o">-</span> <span class="n">ns</span>  <span class="c1"># difference to desired number of orientations</span>
        <span class="n">weights_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        <span class="n">co</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">screen</span><span class="p">[</span><span class="n">weights_loc</span><span class="p">[</span><span class="n">co</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">screen</span><span class="p">[</span><span class="n">weights_loc</span><span class="p">[</span><span class="n">co</span><span class="p">]]</span> <span class="o">=</span> <span class="n">screen</span><span class="p">[</span><span class="n">weights_loc</span><span class="p">[</span><span class="n">co</span><span class="p">]]</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">screen</span><span class="p">)</span> <span class="o">-</span> <span class="n">ns</span>
            <span class="n">co</span> <span class="o">=</span> <span class="n">co</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># Step 5: Subdivide orientations around grid points into screen orientations</span>
        <span class="c1">#         and estimate mean orientation for each group or take orientation of grid point</span>
        <span class="c1">#         if only one orientation needs to be generated</span>
        <span class="n">ori_red</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ns</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
        <span class="n">octr</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">no</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">screen</span><span class="p">):</span>
            <span class="n">nl</span> <span class="o">=</span> <span class="n">neighs</span><span class="p">[</span><span class="n">ictr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nl</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">no</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">nl</span><span class="p">)</span><span class="si">}</span><span class="s1"> &lt; </span><span class="si">{</span><span class="n">no</span><span class="si">}</span><span class="s1"> @ </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">, ictr: </span><span class="si">{</span><span class="n">ictr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1">, weight: </span><span class="si">{</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="mf">0.5</span> <span class="o">&lt;</span> <span class="n">no</span> <span class="o">&lt;</span> <span class="mf">1.5</span><span class="p">:</span>
                <span class="n">ori_red</span><span class="p">[</span><span class="n">octr</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">S3G</span><span class="p">[</span><span class="n">ictr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">data</span>
                <span class="n">octr</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">no</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;no: </span><span class="si">{</span><span class="n">no</span><span class="si">}</span><span class="s1">, should be 1&#39;</span>
            <span class="k">elif</span> <span class="n">no</span> <span class="o">&gt;=</span> <span class="mf">1.5</span><span class="p">:</span>
                <span class="c1"># split orientations in EBSD map matching to one grid point according to required number of</span>
                <span class="c1"># orientations at this point</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nl</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">no</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nl</span><span class="p">),</span> <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">ho</span> <span class="o">=</span> <span class="n">octr</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">:</span>
                    <span class="n">ori_red</span><span class="p">[</span><span class="n">octr</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ori</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">octr</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">no</span><span class="p">,</span> <span class="n">octr</span><span class="o">-</span><span class="n">ho</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;len_nl: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">nl</span><span class="p">)</span><span class="si">}</span><span class="s1">, len_idx: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;no: </span><span class="si">{</span><span class="n">no</span><span class="si">}</span><span class="s1">, but increment is only #</span><span class="si">{</span><span class="n">octr</span><span class="o">-</span><span class="n">ho</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># create Orientations from quaternion array</span>
        <span class="n">ori_f</span> <span class="o">=</span> <span class="n">Orientation</span><span class="p">(</span><span class="n">ori_red</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="n">cs</span><span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ori_f</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">ori_f</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>

        <span class="c1"># Step 6: Compute reduced ODF</span>
        <span class="n">odfred</span> <span class="o">=</span> <span class="n">odf_est</span><span class="p">(</span><span class="n">ori_f</span><span class="p">,</span> <span class="n">odf</span><span class="p">,</span> <span class="n">halfwidth</span><span class="o">=</span><span class="n">hw_stored</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">hw_stored</span> <span class="o">=</span> <span class="n">odfred</span><span class="o">.</span><span class="n">halfwidth</span>

        <span class="c1"># Step 7: Compute error for kernel optimization</span>
        <span class="n">er</span> <span class="o">=</span> <span class="n">calc_error</span><span class="p">(</span><span class="n">odf</span><span class="p">,</span> <span class="n">odfred</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Resolution: </span><span class="si">{</span><span class="n">hw</span><span class="si">}</span><span class="s1">, Error: </span><span class="si">{</span><span class="n">er</span><span class="si">}</span><span class="s1">, Reduced HW: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">odfred</span><span class="o">.</span><span class="n">halfwidth</span><span class="p">)</span><span class="si">}</span><span class="s1">¬∞&#39;</span><span class="p">)</span>
        <span class="c1"># store best results and evaluate stopping criterion</span>
        <span class="k">if</span> <span class="n">er</span> <span class="o">&lt;</span> <span class="n">ero</span><span class="p">:</span>
            <span class="n">orired_f</span> <span class="o">=</span> <span class="n">ori_f</span>
            <span class="n">odfred_f</span> <span class="o">=</span> <span class="n">odfred</span>
            <span class="n">ero</span> <span class="o">=</span> <span class="n">er</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">hw</span>
        <span class="n">e_mod</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">er</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">e_mod</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">e_mod</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">lim</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="n">orired_f</span> <span class="o">=</span> <span class="n">orired_f</span><span class="o">.</span><span class="n">in_euler_fundamental_region</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">orired_f</span><span class="p">,</span> <span class="n">odfred_f</span><span class="p">,</span> <span class="n">ero</span><span class="p">,</span> <span class="n">res</span></div>



<div class="viewcode-block" id="Kernel">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.Kernel">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Kernel</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">if</span> <span class="n">A</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">bandwidth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="nd">@bandwidth</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">bandwidth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[:</span><span class="nb">min</span><span class="p">(</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">))]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;custom, halfwidth </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">halfwidth</span><span class="p">())</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">¬∞&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">L</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bandwidth</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">bandwidth</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[:</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">A</span><span class="p">[:</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-6</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">L</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bandwidth</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">bandwidth</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Kernel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[:</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">A</span><span class="p">[:</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bandwidth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Kernel</span><span class="p">(((</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">**</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

<div class="viewcode-block" id="Kernel.norm">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.Kernel.norm">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="Kernel.cutA">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.Kernel.cutA">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cutA</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fft_accuracy</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">):</span>
        <span class="n">epsilon</span> <span class="o">=</span> <span class="n">fft_accuracy</span> <span class="o">/</span> <span class="mi">150</span>
        <span class="n">A_mod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">A_mod</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&lt;=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">A_mod</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">epsilon</span><span class="p">]),</span> <span class="n">epsilon</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">idx</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[:</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span></div>


<div class="viewcode-block" id="Kernel.halfwidth">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.Kernel.halfwidth">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">halfwidth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">error_fn</span><span class="p">(</span><span class="n">omega</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)))</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="k">return</span> <span class="n">fminbound</span><span class="p">(</span><span class="n">error_fn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span></div>


<div class="viewcode-block" id="Kernel.K">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.Kernel.K">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">K</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">co2</span><span class="p">):</span>
        <span class="n">co2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">co2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">co2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clenshawU</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">omega</span><span class="p">)</span></div>


<div class="viewcode-block" id="Kernel.K_orientations">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.Kernel.K_orientations">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">K_orientations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orientations_ref</span><span class="p">,</span> <span class="n">orientations</span><span class="p">):</span>
        <span class="n">misangles</span> <span class="o">=</span> <span class="n">orientations</span><span class="o">.</span><span class="n">angle_with</span><span class="p">(</span><span class="n">orientations_ref</span><span class="p">)</span>
        <span class="n">co2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">misangles</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">(</span><span class="n">co2</span><span class="p">)</span></div>


<div class="viewcode-block" id="Kernel.RK">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.Kernel.RK">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">RK</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clenshawL</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span></div>


<div class="viewcode-block" id="Kernel.RRK">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.Kernel.RRK">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">RRK</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dh</span><span class="p">,</span> <span class="n">dr</span><span class="p">):</span>
        <span class="n">dh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">dh</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">dr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">dr</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bandwidth</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">dh</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">dr</span><span class="p">)))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dh</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">dr</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dh_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dh</span><span class="p">):</span>
                <span class="n">Plh</span> <span class="o">=</span> <span class="p">[</span><span class="n">legendre</span><span class="p">(</span><span class="n">l</span><span class="p">)(</span><span class="n">dh_i</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clenshawL</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Plh</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">dr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">dr_j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dr</span><span class="p">):</span>
                <span class="n">Plr</span> <span class="o">=</span> <span class="p">[</span><span class="n">legendre</span><span class="p">(</span><span class="n">l</span><span class="p">)(</span><span class="n">dr_j</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
                <span class="n">result</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clenshawL</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Plr</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">dh</span><span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">result</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_clenshawU</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">omega</span><span class="p">):</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="n">omega</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)):</span>
            <span class="n">term</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">*</span> <span class="n">omega</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">omega</span><span class="p">)</span> <span class="o">+</span> \
                   <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">*</span> <span class="n">term</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_clenshawL</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">b_next</span><span class="p">,</span> <span class="n">b_curr</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">b_next</span><span class="p">,</span> <span class="n">b_curr</span> <span class="o">=</span> <span class="n">b_curr</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">x2</span> <span class="o">*</span> <span class="n">b_curr</span> <span class="o">-</span> <span class="n">b_next</span>
        <span class="k">return</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">b_curr</span> <span class="o">-</span> <span class="n">b_next</span>

<div class="viewcode-block" id="Kernel.calc_fourier">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.Kernel.calc_fourier">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calc_fourier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">max_angle</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">fft_accuracy</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">):</span>
        <span class="n">A</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">small</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">integrand</span><span class="p">(</span><span class="n">omega</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">omega</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

            <span class="n">coeff</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">max_angle</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">2000</span><span class="p">)</span>
            <span class="n">coeff</span> <span class="o">*=</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="n">A</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">fft_accuracy</span><span class="p">:</span>
                <span class="n">small</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">small</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">small</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A</span><span class="p">)</span></div>


<div class="viewcode-block" id="Kernel.plot_K">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.Kernel.plot_K">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_K</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_points</span><span class="o">=</span><span class="mi">200</span><span class="p">):</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_points</span><span class="p">)</span>
        <span class="n">co2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">(</span><span class="n">co2</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">omega</span><span class="p">),</span> <span class="n">values</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Misorientation angle (degrees)&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;K(cos(omega/2))&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Kernel Function&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="DeLaValleePoussinKernel">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.DeLaValleePoussinKernel">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DeLaValleePoussinKernel</span><span class="p">(</span><span class="n">Kernel</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kappa</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">halfwidth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bandwidth</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">halfwidth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kappa</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">halfwidth</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">kappa</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kappa</span> <span class="o">=</span> <span class="mi">90</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span> <span class="o">=</span> <span class="n">kappa</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">bandwidth</span> <span class="k">if</span> <span class="n">bandwidth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">round</span><span class="p">(</span><span class="n">kappa</span><span class="p">)</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">beta</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="n">beta</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">kappa</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="n">C</span>

        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">kappa</span> <span class="o">/</span> <span class="p">(</span><span class="n">kappa</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">A</span><span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">kappa</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="n">l</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">kappa</span> <span class="o">+</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">A</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cutA</span><span class="p">()</span>

<div class="viewcode-block" id="DeLaValleePoussinKernel.K">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.DeLaValleePoussinKernel.K">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">K</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">co2</span><span class="p">):</span>
        <span class="n">co2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">co2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="o">*</span> <span class="n">co2</span> <span class="o">**</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span><span class="p">)</span></div>


<div class="viewcode-block" id="DeLaValleePoussinKernel.DK">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.DeLaValleePoussinKernel.DK">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">DK</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">co2</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">co2</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">co2</span> <span class="o">**</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="DeLaValleePoussinKernel.RK">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.DeLaValleePoussinKernel.RK">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">RK</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span></div>


<div class="viewcode-block" id="DeLaValleePoussinKernel.DRK">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.DeLaValleePoussinKernel.DRK">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">DRK</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kappa</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span></div>


<div class="viewcode-block" id="DeLaValleePoussinKernel.halfwidth">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.DeLaValleePoussinKernel.halfwidth">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">halfwidth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span><span class="p">)))</span></div>
</div>



<div class="viewcode-block" id="ODF">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.ODF">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ODF</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orientations</span><span class="p">,</span> <span class="n">halfwidth</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Estimate an Orientation Distribution Function (ODF) from individual orientations</span>
<span class="sd">            using kernel density estimation.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            orientations : orix.quaternion.Orientation</span>
<span class="sd">                Input orientation set.</span>
<span class="sd">            halfwidth : float, optional</span>
<span class="sd">                Halfwidth of the kernel in radians (default: 10 degrees).</span>
<span class="sd">            weights : array-like, optional</span>
<span class="sd">                Weights for each orientation. If None, weights are uniform.</span>
<span class="sd">            kernel : Kernel instance, optional</span>
<span class="sd">                Kernel function to use. If None, DeLaValleePoussinKernel is used.</span>
<span class="sd">            exact : bool, optional</span>
<span class="sd">                If False and orientation count &gt; 1000, approximate using grid.</span>

<span class="sd">            Attributes</span>
<span class="sd">            ----------</span>
<span class="sd">            orientations</span>
<span class="sd">            weights</span>
<span class="sd">            kernel</span>
<span class="sd">            halfwidth</span>
<span class="sd">            &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">orientations</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Orientation set is empty.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">orientations</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">/</span> <span class="n">orientations</span><span class="o">.</span><span class="n">size</span>

        <span class="c1"># Set up kernel</span>
        <span class="k">if</span> <span class="n">kernel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kernel</span> <span class="o">=</span> <span class="n">DeLaValleePoussinKernel</span><span class="p">(</span><span class="n">halfwidth</span><span class="o">=</span><span class="n">halfwidth</span><span class="p">)</span>
        <span class="n">hw</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">halfwidth</span><span class="p">()</span>

        <span class="c1"># Gridify if too many orientations and not exact</span>
        <span class="k">if</span> <span class="n">orientations</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1000</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">exact</span><span class="p">:</span>
            <span class="c1"># Placeholder: replace with proper gridify function if needed</span>
            <span class="c1"># Currently using simple thinning and weighting</span>
            <span class="n">step</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">orientations</span><span class="o">.</span><span class="n">size</span> <span class="o">//</span> <span class="mi">1000</span><span class="p">)</span>
            <span class="n">orientations</span> <span class="o">=</span> <span class="n">orientations</span><span class="p">[::</span><span class="n">step</span><span class="p">]</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[::</span><span class="n">step</span><span class="p">]</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">orientations</span> <span class="o">=</span> <span class="n">orientations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">halfwidth</span> <span class="o">=</span> <span class="n">hw</span>

<div class="viewcode-block" id="ODF.evaluate">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.ODF.evaluate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ori</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ori</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">orientations</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span><span class="o">.</span><span class="n">K_orientations</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">ori</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">values</span></div>
</div>



<div class="viewcode-block" id="EBSDmap">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.EBSDmap">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">EBSDmap</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class to store attributes and methods to import EBSD maps</span>
<span class="sd">    and filter out their statistical data needed to generate</span>
<span class="sd">    synthetic RVEs</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">gs_min</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">vf_min</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span> <span class="n">max_angle</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
                 <span class="n">show_plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">show_hist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">felzenszwalb</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">show_grains</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">hist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate microstructural data from EBSD maps</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fname : str</span>
<span class="sd">            filname incl. path to EBSD file.</span>
<span class="sd">        matname : str, optional</span>
<span class="sd">            Name of material, depracted. The default is None.</span>
<span class="sd">        gs_min : int, optional</span>
<span class="sd">            Minimum grain size in pixels, smaller grains will be disregarded</span>
<span class="sd">            for the statistical analysis. The default is 3.</span>
<span class="sd">        vf_min : int, optional</span>
<span class="sd">            Minimum volume fracture, phases with smaller values will be</span>
<span class="sd">            disregarded. The default is 0.03.</span>
<span class="sd">        plot : bool, optional</span>
<span class="sd">            Plot microstructures. The default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>
<span class="sd">        </span>
<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        ms_data : list of dict</span>
<span class="sd">            List of dictionaries with phase specific microstructure</span>
<span class="sd">            information.  </span>
<span class="sd">            name : name of phase  </span>
<span class="sd">            vf : volume fraction</span>
<span class="sd">            ngrain : number of grains in phase</span>
<span class="sd">            ori : matlab object with grain orientations</span>
<span class="sd">            cs : matlab object with crystal structure</span>
<span class="sd">            grains : matlab object with grains in each phase</span>
<span class="sd">            omega : orientations of major grain axis</span>
<span class="sd">            gs_param : statistical grain size parameters</span>
<span class="sd">            gs_data : grain sizes</span>
<span class="sd">            ar_param</span>
<span class="sd">            ar_data</span>
<span class="sd">            om_param</span>
<span class="sd">            om_data</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">reassign</span><span class="p">(</span><span class="n">pix</span><span class="p">,</span> <span class="n">ori</span><span class="p">,</span> <span class="n">phid</span><span class="p">,</span> <span class="n">bads</span><span class="p">):</span>
            <span class="n">phase</span> <span class="o">=</span> <span class="n">phid</span><span class="p">[</span><span class="n">pix</span><span class="p">]</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">pix</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">phid</span><span class="p">[</span><span class="n">pix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">phase</span> <span class="ow">and</span> <span class="n">pix</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bads</span><span class="p">:</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">pix</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">pix</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">npx</span> <span class="ow">and</span> <span class="n">phid</span><span class="p">[</span><span class="n">pix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">phase</span> <span class="ow">and</span> <span class="n">pix</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bads</span><span class="p">:</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">pix</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">pix</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">phid</span><span class="p">[</span><span class="n">pix</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">phase</span> <span class="ow">and</span> <span class="n">pix</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bads</span><span class="p">:</span>
                <span class="n">pix</span> <span class="o">=</span> <span class="n">pix</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span>
            <span class="k">elif</span> <span class="n">pix</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">npx</span> <span class="ow">and</span> <span class="n">phid</span><span class="p">[</span><span class="n">pix</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">phase</span> <span class="ow">and</span> <span class="n">pix</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bads</span><span class="p">:</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">pix</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span>
            <span class="k">if</span> <span class="n">ix</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ori</span><span class="p">[</span><span class="n">pix</span><span class="p">]</span> <span class="o">=</span> <span class="n">ori</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>  <span class="c1"># pixel orientation is reassigned</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bads</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pix</span><span class="p">)</span>  <span class="c1"># no valid neighbor found add pix again to list</span>

        <span class="c1"># interpret parameters</span>
        <span class="k">if</span> <span class="n">plot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">show_plot</span> <span class="o">=</span> <span class="n">plot</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Use of &quot;plot&quot; is depracted, use argument &quot;show_plot&quot; instead.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hist</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">show_hist</span> <span class="o">=</span> <span class="n">hist</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Use of &quot;hist&quot; is depracted, use argument &quot;show_plot&quot; instead.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">show_hist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">show_hist</span> <span class="o">=</span> <span class="n">show_plot</span>
        <span class="n">max_angle</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ms_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># read EBSD map and return the orix object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emap</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># shape of EBSD map in pixels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">dy</span>  <span class="c1"># distance in micron b/w pixels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">size</span>  <span class="c1"># total number of pixels in EBSD map</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_y</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npx</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Size of map (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">npx</span><span class="si">}</span><span class="s2"> px) does not match its shape: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">sh_y</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># determine number of phases and generate histogram</span>
        <span class="n">Nphase</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phases</span><span class="o">.</span><span class="n">ids</span><span class="p">)</span>  <span class="c1"># number of phases</span>
        <span class="n">offs</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phases</span><span class="o">.</span><span class="n">ids</span> <span class="k">else</span> <span class="mi">1</span>  <span class="c1"># in CTX maps, there is no phase &quot;0&quot;</span>
        <span class="n">phist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phase_id</span><span class="p">,</span> <span class="n">Nphase</span> <span class="o">+</span> <span class="n">offs</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Imported EBSD map with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phases</span><span class="o">.</span><span class="n">ids</span><span class="p">)</span><span class="si">}</span><span class="s1"> phases.&#39;</span><span class="p">)</span>

        <span class="c1"># read phase names and calculate volume fractions and plots if active</span>
        <span class="k">for</span> <span class="n">n_ph</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phases</span><span class="o">.</span><span class="n">ids</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ind</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">vf</span> <span class="o">=</span> <span class="n">phist</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">n_ph</span> <span class="o">+</span> <span class="n">offs</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">npx</span>
            <span class="k">if</span> <span class="n">vf</span> <span class="o">&lt;</span> <span class="n">vf_min</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># initialize data dictionary</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;vf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">vf</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phases</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">n_ph</span><span class="p">]</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;len_x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;len_y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_y</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;delta_x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;delta_y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span>

            <span class="c1"># generate phase-specific orientations</span>
            <span class="n">ori_e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phase_id</span> <span class="o">==</span> <span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">orientations</span><span class="o">.</span><span class="n">in_euler_fundamental_region</span><span class="p">()</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ori&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Orientation</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="n">ori_e</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;cs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">point_group</span><span class="o">.</span><span class="n">laue</span>
            <span class="c1"># assign bad pixels to one neighbor</span>
            <span class="c1"># identify non-indexed pixels and pixels with low confidence index (CI)</span>
            <span class="k">if</span> <span class="s1">&#39;ci&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">prop</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">prop</span><span class="p">[</span><span class="s1">&#39;ci&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">npx</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ci_map</span> <span class="o">=</span> <span class="n">val</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ci_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npx</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ci_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phase_id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
                <span class="n">bad_pix</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bad_pix</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad_pix</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">niter</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Initial number of bad pixels: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">bad_pix</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">nbad</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad_pix</span><span class="p">)</span>
                <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad_pix</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">niter</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nbad</span><span class="p">:</span>
                    <span class="n">bp</span> <span class="o">=</span> <span class="n">bad_pix</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">reassign</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ori&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phase_id</span><span class="p">,</span> <span class="n">bad_pix</span><span class="p">)</span>
                    <span class="n">niter</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;After </span><span class="si">{</span><span class="n">niter</span><span class="si">}</span><span class="s1"> loops: number of bad pixels: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">bad_pix</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="c1"># calculate misorientation field</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ori&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">angle</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">npx</span><span class="p">:</span>
                <span class="n">bmap</span> <span class="o">=</span> <span class="n">val</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bmap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npx</span><span class="p">)</span>
                <span class="n">bmap</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phase_id</span> <span class="o">==</span> <span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;mo_map&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bmap</span>

            <span class="c1"># Get IPF colors</span>
            <span class="n">ipf_key</span> <span class="o">=</span> <span class="n">ox_plot</span><span class="o">.</span><span class="n">IPFColorKeyTSL</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;cs&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ori&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">npx</span><span class="p">:</span>
                <span class="n">rgb_val</span> <span class="o">=</span> <span class="n">ipf_key</span><span class="o">.</span><span class="n">orientation2color</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;ori&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rgb_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">npx</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
                <span class="n">rgb_val</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phase_id</span> <span class="o">==</span> <span class="n">ind</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">ipf_key</span><span class="o">.</span><span class="n">orientation2color</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;ori&#39;</span><span class="p">])</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;rgb_im&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">rgb_val</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_y</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

            <span class="c1"># generate map with grain labels</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Identifying regions of homogeneous misorientations and assigning them to grains.&#39;</span><span class="p">)</span>
            <span class="n">labels</span><span class="p">,</span> <span class="n">n_regions</span> <span class="o">=</span> <span class="n">find_similar_regions</span><span class="p">(</span><span class="n">bmap</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_y</span><span class="p">)),</span>
                                                     <span class="n">tolerance</span><span class="o">=</span><span class="n">max_angle</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Phase #</span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">): Identified Grains: </span><span class="si">{</span><span class="n">n_regions</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># build and visualize graph of unfiltered map</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Building microstructure graph.&#39;</span><span class="p">)</span>
            <span class="n">ms_graph</span> <span class="o">=</span> <span class="n">build_graph_from_labeled_pixels</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="p">,</span> <span class="n">n_ph</span><span class="p">)</span>
            <span class="n">ms_graph</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Graph of microstructure&#39;</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Starting to simplify microstructure graph.&#39;</span><span class="p">)</span>

            <span class="c1"># graph pruning step 1: remove grains that have no convex hull</span>
            <span class="c1"># and merge regions with similar misorientation</span>
            <span class="n">grain_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ms_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
            <span class="n">rem_grains</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grain_set</span><span class="p">)</span>
            <span class="k">while</span> <span class="n">rem_grains</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">num</span> <span class="o">=</span> <span class="n">grain_set</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>  <span class="c1"># get random ID of grain and remove it from the list</span>
                <span class="n">nd</span> <span class="o">=</span> <span class="n">ms_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">num</span><span class="p">]</span>  <span class="c1"># node to be considered</span>
                <span class="n">rem_grains</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grain_set</span><span class="p">)</span>
                <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">nd</span><span class="p">[</span><span class="s1">&#39;pixels&#39;</span><span class="p">],</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_y</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                <span class="n">pts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>  <span class="c1"># convert pixel distances to micron</span>
                <span class="n">pts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">hull</span> <span class="o">=</span> <span class="n">ConvexHull</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
                    <span class="n">ms_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">num</span><span class="p">][</span><span class="s1">&#39;hull&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hull</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="c1"># grain has no convex hull</span>
                    <span class="n">num_ln</span> <span class="o">=</span> <span class="n">find_largest_neighbor</span><span class="p">(</span><span class="n">ms_graph</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
                    <span class="n">merge_nodes</span><span class="p">(</span><span class="n">ms_graph</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">num_ln</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="c1"># search for neighbors with similar orientation</span>
                <span class="n">sim_neigh</span><span class="p">,</span> <span class="n">ori_neigh</span> <span class="o">=</span> <span class="n">find_sim_neighbor</span><span class="p">(</span><span class="n">ms_graph</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ori_neigh</span> <span class="o">&lt;=</span> <span class="n">max_angle</span><span class="p">:</span>
                    <span class="n">merge_nodes</span><span class="p">(</span><span class="n">ms_graph</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">sim_neigh</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ngrains</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ms_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;After merging of similar regions, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ngrains</span><span class="si">}</span><span class="s1"> grains left.&#39;</span><span class="p">)</span>

            <span class="c1"># graph pruning step 2: merge small grains into their largest neighbor grain</span>
            <span class="n">grain_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ms_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
            <span class="n">rem_grains</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grain_set</span><span class="p">)</span>
            <span class="k">while</span> <span class="n">rem_grains</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">num</span> <span class="o">=</span> <span class="n">grain_set</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>  <span class="c1"># get random ID of grain and remove it from the list</span>
                <span class="n">rem_grains</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grain_set</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ms_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">num</span><span class="p">][</span><span class="s1">&#39;npix&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">gs_min</span><span class="p">:</span>
                    <span class="n">num_ln</span> <span class="o">=</span> <span class="n">find_largest_neighbor</span><span class="p">(</span><span class="n">ms_graph</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
                    <span class="n">merge_nodes</span><span class="p">(</span><span class="n">ms_graph</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">num_ln</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ngrains</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ms_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ngrains&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ngrains</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;After elimination of small grains, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ngrains</span><span class="si">}</span><span class="s1"> grains left.&#39;</span><span class="p">)</span>

            <span class="c1"># Extract grain statistics and axes</span>
            <span class="n">arr_a</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">arr_b</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">arr_eqd</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">arr_om</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">ms_graph</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">hull</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;hull&#39;</span><span class="p">]</span>
                <span class="n">eqd</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">hull</span><span class="o">.</span><span class="n">volume</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>  <span class="c1"># area of convex hull approximates grain better than pixels</span>
                <span class="n">pts</span> <span class="o">=</span> <span class="n">hull</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">hull</span><span class="o">.</span><span class="n">vertices</span><span class="p">]</span>  <span class="c1"># outer nodes of grain</span>
                <span class="c1"># analyze geometry of point cloud</span>
                <span class="n">ea</span><span class="p">,</span> <span class="n">eb</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">vb</span> <span class="o">=</span> <span class="n">get_grain_geom</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;ellipsis&#39;</span><span class="p">,</span> <span class="n">two_dim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># std: &#39;ellipsis&#39;, failsafe: &#39;raw&#39;</span>
                <span class="c1"># assert ea &gt;= eb</span>
                <span class="k">if</span> <span class="n">eb</span> <span class="o">&lt;</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="n">ea</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Grain </span><span class="si">{</span><span class="n">num</span><span class="si">}</span><span class="s1"> has too high aspect ratio: main axes: </span><span class="si">{</span><span class="n">ea</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">eb</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">eb</span> <span class="o">=</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="n">ea</span>
                <span class="n">sc_fct</span> <span class="o">=</span> <span class="n">eqd</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ea</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">eb</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># rescale axes of ellipsis to ensure consistency with eqd</span>
                <span class="n">ea</span> <span class="o">*=</span> <span class="n">sc_fct</span>
                <span class="n">eb</span> <span class="o">*=</span> <span class="n">sc_fct</span>
                <span class="c1"># assert np.dot(va, vb) &lt; 1.e-9</span>
                <span class="c1"># assert np.isclose(np.linalg.norm(va), 1.0)</span>
                <span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">va</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># angle of major axis against y-axis of map in range [0, pi]</span>
                <span class="n">node</span><span class="p">[</span><span class="s1">&#39;max_dia&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ea</span>
                <span class="n">node</span><span class="p">[</span><span class="s1">&#39;min_dia&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">eb</span>
                <span class="n">node</span><span class="p">[</span><span class="s1">&#39;equ_dia&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">eqd</span>
                <span class="n">node</span><span class="p">[</span><span class="s1">&#39;maj_ax&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">va</span>
                <span class="n">node</span><span class="p">[</span><span class="s1">&#39;min_ax&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">vb</span>
                <span class="n">node</span><span class="p">[</span><span class="s1">&#39;omega&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">omega</span>
                <span class="n">node</span><span class="p">[</span><span class="s1">&#39;center&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hull</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">arr_a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ea</span><span class="p">)</span>
                <span class="n">arr_b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eb</span><span class="p">)</span>
                <span class="n">arr_eqd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eqd</span><span class="p">)</span>
                <span class="n">arr_om</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span>
            <span class="n">arr_om</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr_om</span><span class="p">)</span>
            <span class="n">arr_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr_a</span><span class="p">)</span>
            <span class="n">arr_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr_b</span><span class="p">)</span>
            <span class="n">arr_eqd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr_eqd</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">--------------------------------------------------------&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Statistical microstructure parameters in pixel map &#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;--------------------------------------------------------&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">arr_a</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">arr_a</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">arr_b</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">arr_b</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">arr_eqd</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">arr_eqd</span><span class="p">))</span>

            <span class="c1"># calculate equivalent diameters</span>
            <span class="n">doffs</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">deq_log</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">arr_eqd</span><span class="p">)</span>
            <span class="n">dscale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">deq_log</span><span class="p">))</span>
            <span class="n">dsig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">deq_log</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;gs_param&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dsig</span><span class="p">,</span> <span class="n">doffs</span><span class="p">,</span> <span class="n">dscale</span><span class="p">])</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;gs_data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr_eqd</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;gs_moments&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">dscale</span><span class="p">,</span> <span class="n">dsig</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">show_hist</span><span class="p">:</span>
                <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
                <span class="n">hc</span><span class="p">,</span> <span class="n">hb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">arr_eqd</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
                <span class="n">x0</span> <span class="o">=</span> <span class="n">hb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">hc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># find first bin with count == 1</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">x1</span> <span class="o">=</span> <span class="n">hb</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">x1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">arr_eqd</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="mi">150</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dsig</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">doffs</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">dscale</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;-r&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;lognorm fit&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">arr_eqd</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">),</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Histogram of grain equivalent diameters&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Equivalent diameter (micron)&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Normalized frequency&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

            <span class="c1"># grain aspect ratio</span>
            <span class="n">asp</span> <span class="o">=</span> <span class="n">arr_a</span> <span class="o">/</span> <span class="n">arr_b</span>
            <span class="n">aoffs</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">asp_log</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">asp</span><span class="p">)</span>
            <span class="n">ascale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">asp_log</span><span class="p">))</span>  <span class="c1"># lognorm.median(asig, loc=aoffs, scale=ascale)</span>
            <span class="n">asig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">asp_log</span><span class="p">)</span>  <span class="c1"># lognorm.std(asig, loc=aoffs, scale=ascale)</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ar_param&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">asig</span><span class="p">,</span> <span class="n">aoffs</span><span class="p">,</span> <span class="n">ascale</span><span class="p">])</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ar_data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">asp</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ar_moments&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">ascale</span><span class="p">,</span> <span class="n">asig</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">show_hist</span><span class="p">:</span>
                <span class="c1"># plot distribution of aspect ratios</span>
                <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
                <span class="n">hc</span><span class="p">,</span> <span class="n">hb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">asp</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
                <span class="n">x0</span> <span class="o">=</span> <span class="n">hb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">hc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># find first bin with count == 1</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">x1</span> <span class="o">=</span> <span class="n">hb</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">x1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">asp</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="mi">150</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">asig</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">aoffs</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">ascale</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;-r&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;lognorm fit&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">asp</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="nb">range</span> <span class="o">=</span> <span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">),</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Histogram of grain aspect ratio&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;aspect ratio&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;normalized frequency&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

            <span class="c1"># angles of main axis</span>
            <span class="c1"># fit von Mises distribution (circular normal distribution) to data</span>
            <span class="n">kappa</span><span class="p">,</span> <span class="n">oloc</span><span class="p">,</span> <span class="n">oscale</span> <span class="o">=</span> <span class="n">vonmises</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">arr_om</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
            <span class="n">med_om</span> <span class="o">=</span> <span class="n">vonmises</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">kappa</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">oloc</span><span class="p">)</span>  <span class="c1"># scale parameter has no effect on vonmises distribution</span>
            <span class="n">std_om</span> <span class="o">=</span> <span class="n">vonmises</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">kappa</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">oloc</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;om_param&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">kappa</span><span class="p">,</span> <span class="n">oloc</span><span class="p">])</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;om_data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr_om</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;om_moments&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">med_om</span><span class="p">,</span> <span class="n">std_om</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">show_hist</span><span class="p">:</span>
                <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>  <span class="c1"># np.amin(omega), np.amax(omega), 150)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">vonmises</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">kappa</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">oloc</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;-r&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;von Mises fit&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">arr_om</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Histogram of tilt angles of major axes&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;angle (rad)&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;normalized frequency&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Analyzed microstructure of phase #</span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">) with </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ngrains</span><span class="si">}</span><span class="s2"> grains.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Median values: equiv. diameter: </span><span class="si">{</span><span class="n">dscale</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="si">}</span><span class="s1"> micron, &#39;</span> <span class="o">+</span>
                  <span class="sa">f</span><span class="s1">&#39;aspect ratio: </span><span class="si">{</span><span class="n">ascale</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="si">}</span><span class="s1">, &#39;</span> <span class="o">+</span>
                  <span class="sa">f</span><span class="s1">&#39;tilt angle: </span><span class="si">{</span><span class="p">(</span><span class="n">med_om</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">180</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="si">}</span><span class="s1">¬∞&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Std. dev: equivalent diameter: </span><span class="si">{</span><span class="n">dsig</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="si">}</span><span class="s1"> micron, &#39;</span> <span class="o">+</span>
                  <span class="sa">f</span><span class="s1">&#39;aspect ratio: </span><span class="si">{</span><span class="n">asig</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="si">}</span><span class="s1">, &#39;</span> <span class="o">+</span>
                  <span class="sa">f</span><span class="s1">&#39;tilt angle: </span><span class="si">{</span><span class="p">(</span><span class="n">std_om</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">180</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="si">}</span><span class="s1">¬∞&#39;</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;graph&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ms_graph</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ms_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">show_plot</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_mo_map</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_ipf_map</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_segmentation</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_pf</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">show_grains</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_grains</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">felzenszwalb</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_felsenszwalb</span><span class="p">()</span>
        <span class="k">return</span>

<div class="viewcode-block" id="EBSDmap.calcORI">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.EBSDmap.calcORI">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calcORI</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Ng</span><span class="p">,</span> <span class="n">iphase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">shared_area</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nbins</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span>
                <span class="n">res_low</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">res_high</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">res_step</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">lim</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate optimum kernel half-width and produce reduced set of</span>
<span class="sd">        orientations for given number of grains.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Ng : int</span>
<span class="sd">            Numbr of grains for which orientation is requested.</span>
<span class="sd">        iphase : int, optional</span>
<span class="sd">            Phase for which data is requested. The default is 0.</span>
<span class="sd">        shared_area : array, optional</span>
<span class="sd">            Grain boundary data. The default is None.</span>
<span class="sd">        nbins : int, optional</span>
<span class="sd">            number of bins for GB texture. The default is 12.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ori : (Ng, 3)-array</span>
<span class="sd">            Array with Ng Euler angles.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms_data</span><span class="p">[</span><span class="n">iphase</span><span class="p">]</span>
        <span class="n">orired</span><span class="p">,</span> <span class="n">odfred</span><span class="p">,</span> <span class="n">ero</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="n">texture_reconstruction</span><span class="p">(</span><span class="n">Ng</span><span class="p">,</span> <span class="n">orientations</span><span class="o">=</span><span class="n">ms</span><span class="p">[</span><span class="s1">&#39;ori&#39;</span><span class="p">],</span>
                                                          <span class="n">res_low</span><span class="o">=</span><span class="n">res_low</span><span class="p">,</span> <span class="n">res_high</span><span class="o">=</span><span class="n">res_high</span><span class="p">,</span>
                                                          <span class="n">res_step</span><span class="o">=</span><span class="n">res_step</span><span class="p">,</span> <span class="n">lim</span><span class="o">=</span><span class="n">lim</span><span class="p">,</span>
                                                          <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">shared_area</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">full_output</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">orired</span><span class="p">,</span> <span class="n">odfred</span><span class="p">,</span> <span class="n">ero</span><span class="p">,</span> <span class="n">res</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">orired</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span><span class="s1">&#39;Shared area is not implemented yet in pure Python version.</span><span class="se">\n</span><span class="s1">&#39;</span>
                                      <span class="s1">&#39;Use kanapy-mtex for this option.&#39;</span><span class="p">)</span></div>

            <span class="c1">#orilist, ein, eout, mbin = \</span>
            <span class="c1">#    self.eng.gb_textureReconstruction(ms[&#39;grains&#39;], orired,</span>
            <span class="c1">#                                      matlab.double(shared_area), nbins, nargout=4)</span>
            <span class="c1">#return np.array(self.eng.Euler(orilist))</span>

<div class="viewcode-block" id="EBSDmap.showIPF">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.EBSDmap.showIPF">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">showIPF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot IPF key.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phases</span><span class="o">.</span><span class="n">ids</span><span class="p">:</span>
            <span class="n">pg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">point_group</span><span class="o">.</span><span class="n">laue</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
            <span class="n">ax0</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s2">&quot;ipf&quot;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="n">pg</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">ax0</span><span class="o">.</span><span class="n">plot_ipf_color_key</span><span class="p">(</span><span class="n">show_title</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">ax0</span><span class="o">.</span><span class="n">patch</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s2">&quot;None&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="EBSDmap.plot_ci_map">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.EBSDmap.plot_ci_map">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_ci_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;ci&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">prop</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ci_map</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_y</span><span class="p">)))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;CI values in EBSD map&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;CI&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="EBSDmap.plot_pf">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.EBSDmap.plot_pf">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_pf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># plot inverse pole figure</span>
        <span class="c1"># &lt;111&gt; poles in the sample reference frame</span>
        <span class="k">if</span> <span class="n">vector</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vector</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">pids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phases</span><span class="o">.</span><span class="n">ids</span><span class="p">)</span>
        <span class="n">pids</span> <span class="o">=</span> <span class="n">pids</span><span class="p">[</span><span class="n">pids</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">n_ph</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ms_data</span><span class="p">):</span>
            <span class="n">orientations</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ori&#39;</span><span class="p">]</span>
            <span class="n">plot_pole_figure</span><span class="p">(</span><span class="n">orientations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">pids</span><span class="p">[</span><span class="n">n_ph</span><span class="p">]],</span> <span class="n">vector</span><span class="o">=</span><span class="n">vector</span><span class="p">)</span></div>

            <span class="c1">#t_ = Miller(uvw=vector, phase=self.emap.phases[ind]).symmetrise(unique=True)</span>
            <span class="c1">#t_all = orientations.inv().outer(t_)</span>
            <span class="c1">#fig = plt.figure(figsize=(8, 8))</span>
            <span class="c1">#ax = fig.add_subplot(111, projection=&quot;stereographic&quot;)</span>
            <span class="c1">#ax.scatter(t_all)</span>
            <span class="c1">#ax.set_labels(&quot;X&quot;, &quot;Y&quot;, None)</span>
            <span class="c1">#ax.set_title(data[&#39;name&#39;] + r&quot; $\left&lt;001\right&gt;$ PF&quot;)</span>
            <span class="c1">#plt.show()</span>

<div class="viewcode-block" id="EBSDmap.plot_pf_proj">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.EBSDmap.plot_pf_proj">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_pf_proj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># plot inverse pole figure</span>
        <span class="c1"># &lt;111&gt; poles in the sample reference frame</span>
        <span class="k">if</span> <span class="n">vector</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vector</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">pids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phases</span><span class="o">.</span><span class="n">ids</span><span class="p">)</span>
        <span class="n">pids</span> <span class="o">=</span> <span class="n">pids</span><span class="p">[</span><span class="n">pids</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">n_ph</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ms_data</span><span class="p">):</span>
            <span class="n">orientations</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ori&#39;</span><span class="p">]</span>
            <span class="n">plot_pole_figure_proj</span><span class="p">(</span><span class="n">orientations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">pids</span><span class="p">[</span><span class="n">n_ph</span><span class="p">]],</span> <span class="n">vector</span><span class="o">=</span><span class="n">vector</span><span class="p">)</span></div>


<div class="viewcode-block" id="EBSDmap.plot_grains_marked">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.EBSDmap.plot_grains_marked">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_grains_marked</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># plot grain with numbers and axes</span>
        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms_data</span><span class="p">:</span>
            <span class="n">ngr</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ngrains&#39;</span><span class="p">]</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">get_distinct_colormap</span><span class="p">(</span><span class="n">ngr</span><span class="p">)</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">LinearSegmentedColormap</span><span class="o">.</span><span class="n">from_list</span><span class="p">(</span><span class="s1">&#39;segs&#39;</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">ngr</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;graph&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;label_map&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">ngr</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;graph&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">ctr</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;graph&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">num</span><span class="p">][</span><span class="s1">&#39;center&#39;</span><span class="p">]</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">num</span><span class="p">),</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">ctr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ctr</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
                <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;center&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;max_dia&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;maj_ax&#39;</span><span class="p">]</span>
                <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;center&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;max_dia&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;maj_ax&#39;</span><span class="p">]</span>
                <span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;center&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;min_dia&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;min_ax&#39;</span><span class="p">]</span>
                <span class="n">pts</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;center&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;min_dia&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;min_ax&#39;</span><span class="p">]</span>
                <span class="n">pts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
                <span class="n">pts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Phase #</span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">): Grain labels and axes: </span><span class="si">{</span><span class="n">ngr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;Grain Number&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="EBSDmap.plot_mo_map">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.EBSDmap.plot_mo_map">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_mo_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms_data</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;mo_map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_y</span><span class="p">)))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Phase #</span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">): Misorientation angle wrt reference&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Misorientation (rad)&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="EBSDmap.plot_segmentation">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.EBSDmap.plot_segmentation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_segmentation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">show_mo</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">show_ipf</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="c1"># plot segmentation results</span>
        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms_data</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">show_mo</span><span class="p">:</span>
                <span class="n">gscale_map</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;mo_map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_y</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">mark_boundaries</span><span class="p">(</span><span class="n">gscale_map</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;graph&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;label_map&#39;</span><span class="p">]))</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Phase #</span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">): Misorientation map with similarity segmentation&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">show_ipf</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">mark_boundaries</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;rgb_im&#39;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;graph&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;label_map&#39;</span><span class="p">]))</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Phase #</span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">): IPF map with similarity segmentation&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="EBSDmap.plot_felsenszwalb">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.EBSDmap.plot_felsenszwalb">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_felsenszwalb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">skimage.segmentation</span><span class="w"> </span><span class="kn">import</span> <span class="n">felzenszwalb</span>
        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms_data</span><span class="p">:</span>
            <span class="n">gscale_map</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;mo_map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_y</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="n">labels_fz</span> <span class="o">=</span> <span class="n">felzenszwalb</span><span class="p">(</span><span class="n">gscale_map</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span> <span class="n">min_size</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>  <span class="c1"># sc=300, sig=0.8, min_s=25</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">mark_boundaries</span><span class="p">(</span><span class="n">gscale_map</span><span class="p">,</span> <span class="n">labels_fz</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Phase #</span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">): Misorientation map with Felzenszwalb segmentation&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="EBSDmap.plot_graph">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.EBSDmap.plot_graph">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># visualize graph</span>
        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms_data</span><span class="p">:</span>
            <span class="n">visualize_graph</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;graph&#39;</span><span class="p">])</span></div>


<div class="viewcode-block" id="EBSDmap.plot_ipf_map">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.EBSDmap.plot_ipf_map">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_ipf_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># plot EBSD maps for all phase</span>
        <span class="c1"># set pixels of other phases to black</span>
        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms_data</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                <span class="n">data</span><span class="p">[</span><span class="s1">&#39;rgb_im&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npx</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                <span class="n">return_figure</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">figure_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;figsize&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">)},</span>
            <span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="EBSDmap.plot_grains">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.EBSDmap.plot_grains">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_grains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="c1"># select N largest gains and create a one-hot-plot for each grain</span>
        <span class="c1"># showing its pixels, the vertices of the convex hull and the convex hull itself</span>
        <span class="c1"># together with the principal axes of the grain</span>
        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms_data</span><span class="p">:</span>
            <span class="n">glist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">slist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;graph&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">hs</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;equ_dia&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">hs</span> <span class="o">&gt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">slist</span><span class="p">):</span>
                    <span class="n">glist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
                    <span class="n">slist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hs</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">glist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">N</span><span class="p">:</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">slist</span><span class="p">)</span>
                        <span class="n">glist</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                        <span class="n">slist</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">glist</span><span class="p">:</span>
                <span class="n">pix_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;graph&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">num</span><span class="p">][</span><span class="s1">&#39;pixels&#39;</span><span class="p">],</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_y</span><span class="p">))</span>
                <span class="n">oh_grain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_y</span><span class="p">))</span>
                <span class="n">oh_grain</span><span class="p">[</span><span class="n">pix_c</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.3</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;graph&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">num</span><span class="p">]</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;hull&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">vertices</span>
                <span class="n">oh_grain</span><span class="p">[</span><span class="n">pix_c</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ind</span><span class="p">],</span> <span class="n">pix_c</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">ind</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">oh_grain</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
                <span class="c1"># add convex hull</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">ix</span> <span class="o">=</span> <span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ind</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pix_c</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">ix</span><span class="p">],</span> <span class="n">pix_c</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ix</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pix_c</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">ix</span><span class="p">],</span> <span class="n">pix_c</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ix</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
                <span class="c1"># add axes</span>
                <span class="n">ctr</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;center&#39;</span><span class="p">]</span>
                <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
                <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">ctr</span> <span class="o">-</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;max_dia&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;maj_ax&#39;</span><span class="p">]</span>
                <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">ctr</span> <span class="o">+</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;max_dia&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;maj_ax&#39;</span><span class="p">]</span>
                <span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">ctr</span> <span class="o">-</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;min_dia&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;min_ax&#39;</span><span class="p">]</span>
                <span class="n">pts</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">ctr</span> <span class="o">+</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;min_dia&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;min_ax&#39;</span><span class="p">]</span>
                <span class="n">pts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
                <span class="n">pts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;cyan&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Phase #</span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">): Grain #</span><span class="si">{</span><span class="n">num</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="get_ipf_colors">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.get_ipf_colors">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_ipf_colors</span><span class="p">(</span><span class="n">ori_list</span><span class="p">,</span> <span class="n">color_key</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get colors of list of orientations (in radians).</span>
<span class="sd">    Assumes cubic crystal symmetry and cubic specimen symmetry.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ori_list: (N, 3) ndarray</span>
<span class="sd">        List of N Euler angles in radians</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    colors: (N, 3) ndarray</span>
<span class="sd">        List of RGB values</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># get colors</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ori_list</span><span class="p">,</span> <span class="n">Orientation</span><span class="p">):</span>
        <span class="n">ori_list</span> <span class="o">=</span> <span class="n">Orientation</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="n">ori_list</span><span class="p">)</span>
    <span class="n">ckey</span> <span class="o">=</span> <span class="n">ox_plot</span><span class="o">.</span><span class="n">IPFColorKeyTSL</span><span class="p">(</span><span class="n">ori_list</span><span class="o">.</span><span class="n">symmetry</span><span class="p">)</span>
    <span class="n">ocol</span> <span class="o">=</span> <span class="n">ckey</span><span class="o">.</span><span class="n">orientation2color</span><span class="p">(</span><span class="n">ori_list</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ocol</span></div>



<div class="viewcode-block" id="createOriset">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.createOriset">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">createOriset</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">ang</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">hist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shared_area</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">cs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">Nbase</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">res_low</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">res_high</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">res_step</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">lim</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a set of num Euler angles according to the ODF defined by the</span>
<span class="sd">    set of Euler angles ang and the kernel half-width omega.</span>
<span class="sd">    Example: Goss texture: ang = [0, 45, 0], omega = 5</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    num : int</span>
<span class="sd">        Number of Euler angles in set to be created.</span>
<span class="sd">    ang : (3, ) or (M, 3) array</span>
<span class="sd">        Set of Euler angles (in degrees or radians) defining the ODF.</span>
<span class="sd">    omega : float</span>
<span class="sd">        Half-width of kernel in degrees or radians.</span>
<span class="sd">    hist : array, optional</span>
<span class="sd">        Histogram of MDF. The default is None.</span>
<span class="sd">    shared_area: array, optional</span>
<span class="sd">        The shared area between pairs of grains. The default in None.</span>
<span class="sd">    cs : str, optional</span>
<span class="sd">        Crystal symmetry group. The default is &#39;m3m&#39;.</span>
<span class="sd">    Nbase : int, optional</span>
<span class="sd">        Base number of orientations for random texture. The default is 10000</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ori : (num, 3) array</span>
<span class="sd">        Set of Euler angles</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># prepare parameters</span>
    <span class="k">if</span> <span class="n">hist</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">shared_area</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span><span class="s1">&#39;The grain-boundary-texture module is currently only available in kanapy-mtex.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">Symmetry</span><span class="p">):</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Crystal Symmetry &quot;cs&quot; must be provided as Symmetry object.&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">cs</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">resolution</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">degree</span><span class="p">:</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="n">omega</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span>  <span class="c1"># resolution must be given in degrees</span>
    <span class="k">if</span> <span class="n">degree</span><span class="p">:</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ang</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">degree</span><span class="p">:</span>
            <span class="n">ang</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">ang</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ang</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ang</span><span class="p">)</span>
        <span class="n">ang</span> <span class="o">=</span> <span class="n">Orientation</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="n">ang</span><span class="p">,</span> <span class="n">cs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ang</span><span class="p">,</span> <span class="n">Orientation</span><span class="p">)</span>    
    <span class="c1"># psi = DeLaValleePoussinKernel(halfwidth=omega)</span>
    <span class="k">if</span> <span class="n">ang</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">Nbase</span><span class="o">/</span><span class="mi">100</span><span class="p">:</span>
        <span class="c1"># create artificial ODF for monomodal texture or small orientation set</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Creating artificial ODF centered around orientation </span><span class="si">{</span><span class="n">ang</span><span class="si">}</span><span class="s1"> with &#39;</span>
                         <span class="sa">f</span><span class="s1">&#39;kernel halfwidth: </span><span class="si">{</span><span class="n">omega</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">odf</span> <span class="o">=</span> <span class="n">ODF</span><span class="p">(</span><span class="n">ang</span><span class="p">,</span> <span class="n">halfwidth</span><span class="o">=</span><span class="n">omega</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Creating </span><span class="si">{</span><span class="n">Nbase</span><span class="si">}</span><span class="s1"> orientation from artificial ODF.&#39;</span><span class="p">)</span>
        <span class="n">ori</span> <span class="o">=</span> <span class="n">calc_orientations</span><span class="p">(</span><span class="n">odf</span><span class="p">,</span> <span class="n">Nbase</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="n">resolution</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">ori</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">Nbase</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ori</span> <span class="o">=</span> <span class="n">ang</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Texture reconstruction generating </span><span class="si">{</span><span class="n">num</span><span class="si">}</span><span class="s1"> orientations from </span><span class="si">{</span><span class="n">ori</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s1"> inputs.&#39;</span>
                 <span class="sa">f</span><span class="s1">&#39;Kernel halfwidth: </span><span class="si">{</span><span class="n">omega</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">ori_red</span><span class="p">,</span> <span class="n">odfred</span><span class="p">,</span> <span class="n">ero</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="n">texture_reconstruction</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">orientations</span><span class="o">=</span><span class="n">ori</span><span class="p">,</span>
                                                   <span class="n">kernel_halfwidth</span><span class="o">=</span><span class="n">omega</span><span class="p">,</span>
                                                   <span class="n">res_low</span><span class="o">=</span><span class="n">res_low</span><span class="p">,</span> <span class="n">res_high</span><span class="o">=</span><span class="n">res_high</span><span class="p">,</span>
                                                   <span class="n">res_step</span><span class="o">=</span><span class="n">res_step</span><span class="p">,</span> <span class="n">lim</span><span class="o">=</span><span class="n">lim</span><span class="p">,</span>
                                                   <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">hist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">full_output</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ori_red</span><span class="p">,</span> <span class="n">odfred</span><span class="p">,</span> <span class="n">ero</span><span class="p">,</span> <span class="n">res</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ori_red</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span></div>

        <span class="c1">#if shared_area is None:</span>
        <span class="c1">#    raise ValueError(&#39;Microstructure.shared_area must be provided if hist is given.&#39;)</span>
        <span class="c1">#orilist, ein, eout, mbin = \</span>
        <span class="c1">#    eng.gb_textureReconstruction(matlab.double(hist), ori,</span>
        <span class="c1">#                                 matlab.double(shared_area), len(hist), nargout=4)</span>
        <span class="c1">#return np.array(eng.Euler(orilist))</span>


<div class="viewcode-block" id="createOrisetRandom">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.createOrisetRandom">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">createOrisetRandom</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">omega</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shared_area</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Nbase</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a set of num Euler angles for Random texture.</span>
<span class="sd">    Other than knpy.createOriset() this method does not create an artificial</span>
<span class="sd">    EBSD which is reduced in a second step to num discrete orientations but</span>
<span class="sd">    directly samples num randomly distributed orientations.s</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    num : int</span>
<span class="sd">        Number of Euler angles in set to be created.</span>
<span class="sd">    omega : float</span>
<span class="sd">        Halfwidth of kernel in degrees (optional, default: 7.5)</span>
<span class="sd">    hist : array, optional</span>
<span class="sd">        Histogram of MDF. The default is None.</span>
<span class="sd">    shared_area: array, optional</span>
<span class="sd">        The shared area between pairs of grains. The default in None.</span>
<span class="sd">    cs : str, optional</span>
<span class="sd">        Crystal symmetry group. The default is &#39;m3m&#39;.</span>
<span class="sd">    Nbase : int, optional</span>
<span class="sd">        Base number of orientations for random texture. The default is 5000</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ori : (num, 3) array</span>
<span class="sd">        Set of Euler angles</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">hist</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">shared_area</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span><span class="s1">&#39;The grain-boundary-texture module is currently only available in kanapy-mtex.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">Symmetry</span><span class="p">):</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Crystal Symmetry &quot;cs&quot; must be provided as Symmetry object.&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">cs</span><span class="p">))</span>

    <span class="n">ori</span> <span class="o">=</span> <span class="n">Orientation</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">cs</span><span class="p">)</span><span class="o">.</span><span class="n">in_euler_fundamental_region</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">hist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ori</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span></div>

    <span class="c1"># ori = eng.project2FundamentalRegion(ori)</span>
    <span class="c1">#    if shared_area is None:</span>
    <span class="c1">#        raise ValueError(&#39;Shared grain boundary area (geometry[&quot;GBarea&quot;]) must be provided if hist is given.&#39;)</span>
    <span class="c1">#    orilist, ein, eout, mbin = \</span>
    <span class="c1">#        eng.gb_textureReconstruction(matlab.double(hist), ori,</span>
    <span class="c1">#                                     matlab.double(shared_area), len(hist), nargout=4)</span>
    <span class="c1">#    return np.array(eng.Euler(orilist))</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright This work is published under a CC BY-SA 4.0 license.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>