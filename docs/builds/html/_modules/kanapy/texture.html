

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>kanapy.texture &mdash; kanapy 6.5.3.post1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=53ab5b41"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            kanapy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../applications.html">Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../method.html">Modeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kanapy.html">Code documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../history.html">History</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">kanapy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">kanapy.texture</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for kanapy.texture</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Tools for analysis of EBSD maps in form of .ang files</span>

<span class="sd">@author: Alexander Hartmaier, Abhishek Biswas, ICAMS, Ruhr-Universität Bochum</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">networkx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nx</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib.colors</span><span class="w"> </span><span class="kn">import</span> <span class="n">LinearSegmentedColormap</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">kanapy.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_grain_geom</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.stats</span><span class="w"> </span><span class="kn">import</span> <span class="n">lognorm</span><span class="p">,</span> <span class="n">vonmises</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">ConvexHull</span><span class="p">,</span> <span class="n">KDTree</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.special</span><span class="w"> </span><span class="kn">import</span> <span class="n">legendre</span><span class="p">,</span> <span class="n">beta</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">fminbound</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.integrate</span><span class="w"> </span><span class="kn">import</span> <span class="n">quad</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">skimage.segmentation</span><span class="w"> </span><span class="kn">import</span> <span class="n">mark_boundaries</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">orix</span><span class="w"> </span><span class="kn">import</span> <span class="n">io</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">orix</span><span class="w"> </span><span class="kn">import</span> <span class="n">plot</span> <span class="k">as</span> <span class="n">ox_plot</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">orix.quaternion</span><span class="w"> </span><span class="kn">import</span> <span class="n">Orientation</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">orix.quaternion.symmetry</span><span class="w"> </span><span class="kn">import</span> <span class="n">Symmetry</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">orix.sampling</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_sample_fundamental</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">orix.vector</span><span class="w"> </span><span class="kn">import</span> <span class="n">Miller</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ABC</span>


<div class="viewcode-block" id="get_distinct_colormap">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.get_distinct_colormap">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_distinct_colormap</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;prism&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate N visually distinct colors as an RGB colormap.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - N: int, number of colors</span>
<span class="sd">    - seed: optional int, random seed for reproducibility</span>

<span class="sd">    Returns:</span>
<span class="sd">    - cmap: list of N RGB tuples in [0, 1]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">col_</span> <span class="o">=</span> <span class="p">[</span><span class="n">colors</span><span class="p">(</span><span class="n">i</span><span class="p">)[:</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">col_</span></div>



<div class="viewcode-block" id="neighbors">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.neighbors">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">neighbors</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the neighboring coordinates of a cell in a 2D grid.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    r : int</span>
<span class="sd">        Row index of the cell.</span>
<span class="sd">    c : int</span>
<span class="sd">        Column index of the cell.</span>
<span class="sd">    connectivity : int, optional</span>
<span class="sd">        Type of connectivity. Options are:</span>
<span class="sd">        - 1 or 4 : 4-connected neighbors (up, down, left, right)</span>
<span class="sd">        - 8      : 8-connected neighbors (includes diagonals)</span>
<span class="sd">        Default is 8.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    neighbors : list of tuple</span>
<span class="sd">        List of (row, column) tuples representing neighboring cells.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; neighbors(2, 3, connectivity=4)</span>
<span class="sd">    [(3, 3), (1, 3), (2, 4), (2, 2)]</span>

<span class="sd">    &gt;&gt;&gt; neighbors(2, 3)</span>
<span class="sd">    [(3, 2), (3, 3), (3, 4), (2, 2), (2, 4), (1, 2), (1, 3), (1, 4)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">connectivity</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">connectivity</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">r</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span></div>



<div class="viewcode-block" id="merge_nodes">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.merge_nodes">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">merge_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merge the pixel and attribute data of node1 into node2 in a graph</span>

<span class="sd">    This function performs the following steps:</span>
<span class="sd">    1. Concatenates the pixel lists of node1 and node2 and updates node2&#39;s &#39;pixels&#39; attribute</span>
<span class="sd">    2. Updates the average orientation &#39;ori_av&#39; and pixel count &#39;npix&#39; for node2</span>
<span class="sd">    3. Updates the convex hull for node2 if it exists</span>
<span class="sd">    4. Adds edges from node1&#39;s neighbors to node2, avoiding duplicates</span>
<span class="sd">    5. Removes node1 from the graph</span>
<span class="sd">    6. Updates the graph&#39;s &#39;label_map&#39; to replace all occurrences of node1 with node2</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : networkx.Graph</span>
<span class="sd">        Graph object where nodes represent grains and have attributes:</span>
<span class="sd">        - &#39;pixels&#39; : array of pixel indices</span>
<span class="sd">        - &#39;ori_av&#39; : average orientation</span>
<span class="sd">        - &#39;npix&#39; : number of pixels</span>
<span class="sd">        - optional &#39;hull&#39; : ConvexHull object</span>
<span class="sd">        The graph also contains:</span>
<span class="sd">        - &#39;label_map&#39; : 2D array of node labels</span>
<span class="sd">        - &#39;dx&#39;, &#39;dy&#39; : pixel spacing in x and y directions</span>
<span class="sd">    node1 : int</span>
<span class="sd">        Node ID to be merged and removed</span>
<span class="sd">    node2 : int</span>
<span class="sd">        Node ID to merge into and retain</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Modifies the graph `G` in place</span>
<span class="sd">    - Updates &#39;pixels&#39;, &#39;ori_av&#39;, &#39;npix&#39;, &#39;hull&#39; for node2</span>
<span class="sd">    - Updates &#39;label_map&#39; to replace node1 with node2</span>
<span class="sd">    - Adds new edges from node1 to node2 while avoiding duplicates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># merge pixel lists of node 1 into node 2, delete node 1</span>
    <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node2</span><span class="p">][</span><span class="s1">&#39;pixels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node1</span><span class="p">][</span><span class="s1">&#39;pixels&#39;</span><span class="p">],</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node2</span><span class="p">][</span><span class="s1">&#39;pixels&#39;</span><span class="p">]))</span>
    <span class="n">ntot</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node2</span><span class="p">][</span><span class="s1">&#39;ori_av&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node1</span><span class="p">][</span><span class="s1">&#39;ori_av&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node1</span><span class="p">][</span><span class="s1">&#39;npix&#39;</span><span class="p">]</span> <span class="o">+</span>
                                <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node2</span><span class="p">][</span><span class="s1">&#39;ori_av&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node2</span><span class="p">][</span><span class="s1">&#39;npix&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="n">ntot</span>
    <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node2</span><span class="p">][</span><span class="s1">&#39;npix&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ntot</span>  <span class="c1"># update length</span>
    <span class="k">if</span> <span class="s1">&#39;hull&#39;</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node2</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="c1"># update hull if it exists already</span>
        <span class="n">sh</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;label_map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node2</span><span class="p">][</span><span class="s1">&#39;pixels&#39;</span><span class="p">],</span> <span class="n">sh</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">pts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;dx&#39;</span><span class="p">]</span>  <span class="c1"># convert pixel distances to micron</span>
        <span class="n">pts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;dy&#39;</span><span class="p">]</span>
        <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node2</span><span class="p">][</span><span class="s1">&#39;hull&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ConvexHull</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
    <span class="c1"># add new edges (will ignore if edge already exists)</span>
    <span class="k">for</span> <span class="n">neigh</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">node1</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">node2</span> <span class="o">!=</span> <span class="n">neigh</span><span class="p">:</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">node2</span><span class="p">,</span> <span class="n">neigh</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">node1</span><span class="p">)</span>  <span class="c1"># remove grain1 and all its edges</span>
    <span class="c1"># update label map</span>
    <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;label_map&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">node1</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;label_map&#39;</span><span class="p">][</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="n">node2</span></div>



<div class="viewcode-block" id="find_largest_neighbor">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.find_largest_neighbor">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">find_largest_neighbor</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the largest neighboring node of a given node in a graph</span>

<span class="sd">    This function iterates over all neighbors of the specified node and returns</span>
<span class="sd">    the neighbor with the largest &#39;npix&#39; (number of pixels).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : networkx.Graph</span>
<span class="sd">        Graph object where nodes have an attribute &#39;npix&#39; representing their size.</span>
<span class="sd">    node : int</span>
<span class="sd">        Node ID for which the largest neighbor is to be found.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        Node ID of the largest neighbor.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Raises a ValueError if the node has no neighbors.</span>
<span class="sd">    - Raises a ValueError if the graph contains circular edges (neighbor is the node itself).</span>
<span class="sd">    - Does not modify the graph.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># find the largest neighbor of given grain</span>
    <span class="n">size_ln</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># size of largest neighbor grain</span>
    <span class="n">num_ln</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># ID of largest neighbor grain</span>
    <span class="k">for</span> <span class="n">neigh</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">neigh</span><span class="p">][</span><span class="s1">&#39;npix&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">size_ln</span><span class="p">:</span>
            <span class="n">size_ln</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">neigh</span><span class="p">][</span><span class="s1">&#39;npix&#39;</span><span class="p">]</span>
            <span class="n">num_ln</span> <span class="o">=</span> <span class="n">neigh</span>  <span class="c1"># number of largest neighbor grain</span>
    <span class="k">if</span> <span class="n">num_ln</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Grain </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s1"> has no neighbors.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">num_ln</span> <span class="o">==</span> <span class="n">node</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Corrupted graph with circular edges: </span><span class="si">{</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">num_ln</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">num_ln</span></div>



<div class="viewcode-block" id="find_sim_neighbor">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.find_sim_neighbor">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">find_sim_neighbor</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">nn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the neighboring node most similar in orientation to the given node</span>

<span class="sd">    This function computes the misorientation angles between the given node and</span>
<span class="sd">    all its neighbors, and returns the neighbor with the smallest misorientation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : networkx.Graph</span>
<span class="sd">        Graph object where nodes have an &#39;ori_av&#39; attribute representing average orientation.</span>
<span class="sd">        The graph also contains a &#39;symmetry&#39; key in G.graph used for orientation calculations.</span>
<span class="sd">    nn : int</span>
<span class="sd">        Node ID for which the most similar neighbor is to be found.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        A tuple (neighbor_id, angle) where:</span>
<span class="sd">        - neighbor_id : int, ID of the neighbor with smallest misorientation</span>
<span class="sd">        - angle : float, misorientation angle with the given node</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Uses the `Orientation` class for misorientation calculations</span>
<span class="sd">    - Assumes all neighbors have a valid &#39;ori_av&#39; attribute</span>
<span class="sd">    - Does not modify the graph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sym</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;symmetry&#39;</span><span class="p">]</span>
    <span class="n">ori0</span> <span class="o">=</span> <span class="n">Orientation</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">nn</span><span class="p">][</span><span class="s1">&#39;ori_av&#39;</span><span class="p">],</span> <span class="n">sym</span><span class="p">)</span>
    <span class="n">on</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ng</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">neigh</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">nn</span><span class="p">]:</span>
        <span class="n">ang</span> <span class="o">=</span> <span class="n">ori0</span><span class="o">.</span><span class="n">angle_with</span><span class="p">(</span><span class="n">Orientation</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">neigh</span><span class="p">][</span><span class="s1">&#39;ori_av&#39;</span><span class="p">],</span> <span class="n">sym</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">on</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ang</span><span class="p">)</span>
        <span class="n">ng</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neigh</span><span class="p">)</span>
    <span class="n">nn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">on</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ng</span><span class="p">[</span><span class="n">nn</span><span class="p">],</span> <span class="n">on</span><span class="p">[</span><span class="n">nn</span><span class="p">]</span></div>



<div class="viewcode-block" id="summarize_labels">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.summarize_labels">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">summarize_labels</span><span class="p">(</span><span class="n">label_array</span><span class="p">,</span> <span class="n">rotations</span><span class="p">,</span> <span class="n">wanted_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Summarize labeled pixels with average orientation and statistics</span>

<span class="sd">    This function computes, for each label in `label_array` (or a subset of `wanted_labels`):</span>
<span class="sd">    - Number of pixels</span>
<span class="sd">    - Pixel indices</span>
<span class="sd">    - Average orientation vector</span>
<span class="sd">    - Standard deviation of orientation</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    label_array : ndarray of shape (H, W)</span>
<span class="sd">        2D array of integer labels.</span>
<span class="sd">    rotations : ndarray of shape (H*W, D)</span>
<span class="sd">        Orientation data corresponding to each pixel (e.g., emap.rotations.data).</span>
<span class="sd">    wanted_labels : sequence of int, optional</span>
<span class="sd">        List of label IDs to summarize. If None, all labels in `label_array` are used.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of tuples</span>
<span class="sd">        Each tuple is `(label, info_dict)` where `info_dict` contains:</span>
<span class="sd">        - &#39;npix&#39; : int, number of pixels</span>
<span class="sd">        - &#39;pixels&#39; : array of 1D indices in `label_array.ravel()`</span>
<span class="sd">        - &#39;ori_av&#39; : ndarray of shape (D,), average orientation vector</span>
<span class="sd">        - &#39;ori_std&#39; : ndarray of shape (D,), standard deviation of orientation</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Uses `np.add.reduceat` and sorting for efficient computation</span>
<span class="sd">    - The returned list preserves the order of `wanted_labels` if provided,</span>
<span class="sd">      otherwise follows sorted unique labels from `label_array`</span>
<span class="sd">    - Does not modify input arrays</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lab</span> <span class="o">=</span> <span class="n">label_array</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">lab</span><span class="o">.</span><span class="n">size</span>
    <span class="n">rot</span> <span class="o">=</span> <span class="n">rotations</span>  <span class="c1"># shape (N, D)</span>

    <span class="c1"># Gruppierung: alle Pixel nach Label sortieren</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">lab</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;stable&quot;</span><span class="p">)</span>
    <span class="n">lab_sorted</span> <span class="o">=</span> <span class="n">lab</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>

    <span class="c1"># Eindeutige Labels + Segmentstarts + Counts</span>
    <span class="n">uniq</span><span class="p">,</span> <span class="n">starts</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">lab_sorted</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">ends</span> <span class="o">=</span> <span class="n">starts</span> <span class="o">+</span> <span class="n">counts</span>

    <span class="c1"># Rotations in derselben Reihenfolge sortieren</span>
    <span class="n">rot_sorted</span> <span class="o">=</span> <span class="n">rot</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>

    <span class="c1"># Mittelwerte und Standardabweichungen pro Segment (reduceat ist sehr schnell)</span>
    <span class="n">sums</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">rot_sorted</span><span class="p">,</span> <span class="n">starts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">means</span> <span class="o">=</span> <span class="n">sums</span> <span class="o">/</span> <span class="n">counts</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>

    <span class="n">sq</span> <span class="o">=</span> <span class="n">rot_sorted</span> <span class="o">*</span> <span class="n">rot_sorted</span>
    <span class="n">sums_sq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">sq</span><span class="p">,</span> <span class="n">starts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">vars_</span> <span class="o">=</span> <span class="n">sums_sq</span> <span class="o">/</span> <span class="n">counts</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">means</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">stds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">vars_</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>

    <span class="c1"># Pixelindizes pro Label (als Listen von 1D-Indizes)</span>
    <span class="n">pixels_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">starts</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>  <span class="c1"># Liste der Segmente in uniq-Reihenfolge</span>

    <span class="c1"># Auswahl / Re-Ordering auf gewünschte Labels</span>
    <span class="k">if</span> <span class="n">wanted_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">labels_out</span> <span class="o">=</span> <span class="n">uniq</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uniq</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">labels_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">wanted_labels</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">{</span><span class="nb">int</span><span class="p">(</span><span class="n">l</span><span class="p">):</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">uniq</span><span class="p">)}</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">pos</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">labels_out</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">labels_out</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="n">info</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;npix&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
            <span class="s2">&quot;pixels&quot;</span><span class="p">:</span> <span class="n">pixels_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>              <span class="c1"># 1D-Indices in label_array.ravel()</span>
            <span class="s2">&quot;ori_av&quot;</span><span class="p">:</span> <span class="n">means</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>                   <span class="c1"># shape (D,)</span>
            <span class="s2">&quot;ori_std&quot;</span><span class="p">:</span> <span class="n">stds</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>                   <span class="c1"># shape (D,)</span>
        <span class="p">}</span>
        <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">lbl</span><span class="p">),</span> <span class="n">info</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">nodes</span></div>



<div class="viewcode-block" id="build_graph_from_labeled_pixels">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.build_graph_from_labeled_pixels">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">build_graph_from_labeled_pixels</span><span class="p">(</span><span class="n">label_array</span><span class="p">,</span> <span class="n">emap</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build a graph representation of a microstructure from labeled pixels</span>

<span class="sd">    Each node in the graph represents a grain (label) and stores pixel indices,</span>
<span class="sd">    average orientation, and orientation statistics. Edges connect neighboring grains</span>
<span class="sd">    based on pixel adjacency.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    label_array : ndarray of shape (H, W)</span>
<span class="sd">        2D array of integer labels representing grains.</span>
<span class="sd">    emap : object</span>
<span class="sd">        Orientation map object containing:</span>
<span class="sd">        - `rotations.data` : orientation vectors for each pixel</span>
<span class="sd">        - `phases.point_groups` : symmetry information for each phase</span>
<span class="sd">        - `dx`, `dy` : pixel spacing in x and y directions</span>
<span class="sd">    phase : int</span>
<span class="sd">        Phase index to select the corresponding symmetry from `emap.phases.point_groups`.</span>
<span class="sd">    connectivity : int, optional</span>
<span class="sd">        Connectivity criterion for neighbors (4 or 8). Default is 8.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    networkx.Graph</span>
<span class="sd">        Graph object with:</span>
<span class="sd">        - Nodes representing grains, storing &#39;pixels&#39;, &#39;ori_av&#39;, &#39;ori_std&#39;, &#39;npix&#39;</span>
<span class="sd">        - Edges representing neighboring grains (shared boundaries)</span>
<span class="sd">        - Graph attributes: &#39;label_map&#39;, &#39;symmetry&#39;, &#39;dx&#39;, &#39;dy&#39;</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Uses `summarize_labels` to extract node properties from labeled pixels</span>
<span class="sd">    - Loops over all pixels to add edges between neighboring grains</span>
<span class="sd">    - The function preserves the shape and indices of `label_array`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># t1 = time.time()</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">summarize_labels</span><span class="p">(</span><span class="n">label_array</span><span class="p">,</span> <span class="n">emap</span><span class="o">.</span><span class="n">rotations</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="c1"># t2 = time.time()</span>
    <span class="c1"># print(f&#39;Time for extracting nodes: {t2 - t1}&#39;)</span>
    <span class="c1"># print(f&#39;Building microstructure graph with {len(nodes)} nodes (grains).&#39;)</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">label_map</span><span class="o">=</span><span class="n">label_array</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="n">emap</span><span class="o">.</span><span class="n">phases</span><span class="o">.</span><span class="n">point_groups</span><span class="p">[</span><span class="n">phase</span><span class="p">],</span>
                 <span class="n">dx</span><span class="o">=</span><span class="n">emap</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="n">emap</span><span class="o">.</span><span class="n">dy</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    <span class="c1"># t3 = time.time()</span>
    <span class="c1"># print(f&#39;Time for building graph: {t3 - t2}&#39;)</span>

    <span class="c1"># print(&#39;Adding edges (grain boundaries) to microstructure graph.&#39;)</span>
    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">label_array</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cols</span><span class="p">):</span>
            <span class="n">label_here</span> <span class="o">=</span> <span class="n">label_array</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">px</span><span class="p">,</span> <span class="n">py</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">):</span>
                <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">px</span> <span class="o">&lt;</span> <span class="n">rows</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">py</span> <span class="o">&lt;</span> <span class="n">cols</span><span class="p">:</span>
                    <span class="n">neighbor_label</span> <span class="o">=</span> <span class="n">label_array</span><span class="p">[</span><span class="n">px</span><span class="p">,</span> <span class="n">py</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">neighbor_label</span> <span class="o">!=</span> <span class="n">label_here</span><span class="p">:</span>
                        <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">label_here</span><span class="p">,</span> <span class="n">neighbor_label</span><span class="p">)</span>
    <span class="c1"># t4 = time.time()</span>
    <span class="c1"># print(f&#39;Time for adding edges: {t4 - t3}&#39;)</span>
    <span class="k">return</span> <span class="n">G</span></div>



<div class="viewcode-block" id="visualize_graph">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.visualize_graph">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">visualize_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mi">12</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Visualize a microstructure graph using a spring layout</span>

<span class="sd">    This function draws the nodes and edges of the graph with labels,</span>
<span class="sd">    using a spring layout for positioning. Node color, edge color,</span>
<span class="sd">    node size, and font size can be adjusted.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : networkx.Graph</span>
<span class="sd">        Graph object representing the microstructure. Nodes should have meaningful labels.</span>
<span class="sd">    node_size : int, optional</span>
<span class="sd">        Size of the nodes in the plot. Default is 100.</span>
<span class="sd">    fs : int, optional</span>
<span class="sd">        Font size for node labels. Default is 12.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Uses NetworkX&#39;s `spring_layout` for node positioning</span>
<span class="sd">    - Uses Matplotlib to render the plot</span>
<span class="sd">    - Does not modify the graph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>  <span class="c1"># positioning</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;lightblue&#39;</span><span class="p">,</span> <span class="n">edge_color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span>
            <span class="n">node_size</span><span class="o">=</span><span class="n">node_size</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="n">fs</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>



<div class="viewcode-block" id="export_graph">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.export_graph">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">export_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;graphml&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Export a microstructure graph to a file in the specified format</span>

<span class="sd">    This function writes the NetworkX graph to disk in either GraphML or GEXF format.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : networkx.Graph</span>
<span class="sd">        Graph object representing the microstructure.</span>
<span class="sd">    filename : str</span>
<span class="sd">        Path to the output file.</span>
<span class="sd">    format : str, optional</span>
<span class="sd">        File format for export. Supported options are &#39;graphml&#39; and &#39;gexf&#39;. Default is &#39;graphml&#39;.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Raises a ValueError if an unsupported format is provided</span>
<span class="sd">    - Does not modify the graph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;graphml&quot;</span><span class="p">:</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">write_graphml</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;gexf&quot;</span><span class="p">:</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">write_gexf</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only &#39;graphml&#39; or &#39;gexf&#39; formats are supported.&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="find_similar_regions">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.find_similar_regions">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">find_similar_regions</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.087</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identify connected regions of similar values in a 2D array</span>

<span class="sd">    This function labels all connected pixels in the input array whose values</span>
<span class="sd">    differ by at most `tolerance`. Connectivity can be 4- or 8-connected.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array : ndarray of shape (H, W)</span>
<span class="sd">        2D input array with values to segment.</span>
<span class="sd">    tolerance : float, optional</span>
<span class="sd">        Maximum allowed difference between connected values. Default is 0.087.</span>
<span class="sd">    connectivity : int, optional</span>
<span class="sd">        Connectivity criterion for neighbors: 1 for 4-connectivity, 2 for 8-connectivity. Default is 1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    labeled_array : ndarray of shape (H, W)</span>
<span class="sd">        Array where each connected region of similar values has a unique label.</span>
<span class="sd">    num_features : int</span>
<span class="sd">        Total number of connected regions found.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Uses a depth-first search to find connected regions.</span>
<span class="sd">    - Does not modify the input array.</span>
<span class="sd">    - Assumes `neighbors(i, j, connectivity)` returns valid neighboring indices.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">labeled_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">current_label</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cols</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]:</span>
                <span class="n">ref_val</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>
                <span class="n">stack</span> <span class="o">=</span> <span class="p">[(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)]</span>
                <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
                    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rows</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">cols</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">ref_val</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>
                            <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="n">labeled_array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_label</span>
                            <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">neighbors</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">connectivity</span><span class="p">))</span>
                <span class="n">current_label</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">labeled_array</span><span class="p">,</span> <span class="n">current_label</span> <span class="o">-</span> <span class="mi">1</span></div>



<div class="viewcode-block" id="calc_error">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.calc_error">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calc_error</span><span class="p">(</span><span class="n">odf_ref</span><span class="p">,</span> <span class="n">odf_test</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="mf">10.</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the normalized difference between two orientation distribution functions (ODFs)</span>

<span class="sd">    This function evaluates the ODFs on a sample grid in fundamental space and</span>
<span class="sd">    computes the L1 norm of the difference after normalization.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    odf_ref : object</span>
<span class="sd">        Reference ODF object. Must have `.orientations.symmetry` and `.evaluate()` method.</span>
<span class="sd">    odf_test : object</span>
<span class="sd">        Test ODF object to compare. Must have the same symmetry as `odf_ref`.</span>
<span class="sd">    res : float, optional</span>
<span class="sd">        Resolution for sampling the fundamental space grid. Default is 10.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        L1 error between the normalized ODFs.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Raises a RuntimeError if the symmetries of the two ODFs do not match.</span>
<span class="sd">    - Uses `get_sample_fundamental` to sample the fundamental zone and `Orientation` for evaluation.</span>
<span class="sd">    - Does not modify the input ODFs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cs</span> <span class="o">=</span> <span class="n">odf_ref</span><span class="o">.</span><span class="n">orientations</span><span class="o">.</span><span class="n">symmetry</span>
    <span class="k">if</span> <span class="n">cs</span> <span class="o">!=</span> <span class="n">odf_test</span><span class="o">.</span><span class="n">orientations</span><span class="o">.</span><span class="n">symmetry</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Symmetries of ODF&#39;s do not match.&quot;</span><span class="p">)</span>
    <span class="n">so3g</span> <span class="o">=</span> <span class="n">get_sample_fundamental</span><span class="p">(</span><span class="n">resolution</span><span class="o">=</span><span class="n">res</span><span class="p">,</span> <span class="n">point_group</span><span class="o">=</span><span class="n">cs</span><span class="p">)</span>
    <span class="n">so3g</span> <span class="o">=</span> <span class="n">Orientation</span><span class="p">(</span><span class="n">so3g</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="n">cs</span><span class="p">)</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">odf_ref</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">so3g</span><span class="p">)</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">odf_test</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">so3g</span><span class="p">)</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">p1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span> <span class="o">-</span> <span class="n">p2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p2</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">err</span></div>



<div class="viewcode-block" id="calc_orientations">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.calc_orientations">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calc_orientations</span><span class="p">(</span><span class="n">odf</span><span class="p">,</span> <span class="n">nori</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a set of orientations sampled from an orientation distribution function (ODF)</span>

<span class="sd">    This function uses Monte Carlo sampling to generate `nori` orientations according to</span>
<span class="sd">    the probabilities defined by the input ODF. Sampling is performed in the fundamental</span>
<span class="sd">    zone of the crystal symmetry.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    odf : object</span>
<span class="sd">        Orientation distribution function object. Must have `.orientations.symmetry` and `.evaluate()` method.</span>
<span class="sd">    nori : int</span>
<span class="sd">        Number of orientations to generate.</span>
<span class="sd">    res : float, optional</span>
<span class="sd">        Angular resolution in degrees for sampling the fundamental zone grid.</span>
<span class="sd">        If None, a resolution between 2° and 5° is selected based on ODF half-width.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Orientation</span>
<span class="sd">        Orientation object containing `nori` orientations sampled from the ODF.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Raises a RuntimeError if the Monte Carlo sampling does not converge after 200 iterations.</span>
<span class="sd">    - Logs a warning if the SO3 grid resolution is too coarse for the requested number of orientations.</span>
<span class="sd">    - Uses `get_sample_fundamental` to generate the sampling grid and `Orientation` to store results.</span>
<span class="sd">    - Does not modify the input ODF.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">oq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nori</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
    <span class="n">indstart</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">rem</span> <span class="o">=</span> <span class="n">nori</span>
    <span class="n">cs</span> <span class="o">=</span> <span class="n">odf</span><span class="o">.</span><span class="n">orientations</span><span class="o">.</span><span class="n">symmetry</span>
    <span class="n">hw</span> <span class="o">=</span> <span class="n">odf</span><span class="o">.</span><span class="n">halfwidth</span>
    <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">hw</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="n">so3g</span> <span class="o">=</span> <span class="n">get_sample_fundamental</span><span class="p">(</span><span class="n">resolution</span><span class="o">=</span><span class="n">res</span><span class="p">,</span> <span class="n">point_group</span><span class="o">=</span><span class="n">cs</span><span class="p">)</span>  <span class="c1"># generate fine mesh in fund. region; res in degree!</span>
    <span class="n">so3g</span> <span class="o">=</span> <span class="n">Orientation</span><span class="p">(</span><span class="n">so3g</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="n">cs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">so3g</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="o">*</span><span class="n">nori</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Resolution of SO3 grid in &quot;calc_orientations&quot; is too coarse: </span><span class="si">{</span><span class="n">res</span><span class="si">}</span><span class="s1">°.</span><span class="se">\n</span><span class="s1">&#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;Only </span><span class="si">{</span><span class="n">so3g</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s1"> grid points available for </span><span class="si">{</span><span class="n">nori</span><span class="si">}</span><span class="s1"> desired orientations.&#39;</span><span class="p">)</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">odf</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">so3g</span><span class="p">)</span>  <span class="c1"># value of ODF at each gridpoint</span>
    <span class="c1"># do MC sampling of ODF to generate nori orientations</span>
    <span class="n">ctr</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">rem</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ctr</span> <span class="o">&lt;</span> <span class="mi">200</span><span class="p">:</span>
        <span class="n">rn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">so3g</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">vn</span> <span class="o">=</span> <span class="n">val</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">rn</span><span class="p">)</span> <span class="o">*</span> <span class="n">nori</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="n">ori</span> <span class="o">=</span> <span class="n">so3g</span><span class="p">[</span><span class="n">vn</span> <span class="o">&gt;=</span> <span class="n">rn</span><span class="p">]</span>
        <span class="n">no</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ori</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">rem</span><span class="p">)</span>
        <span class="n">oq</span><span class="p">[</span><span class="n">indstart</span><span class="p">:</span><span class="n">indstart</span><span class="o">+</span><span class="n">no</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">ori</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">no</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">indstart</span> <span class="o">+=</span> <span class="n">no</span>
        <span class="n">rem</span> <span class="o">-=</span> <span class="n">no</span>
        <span class="n">ctr</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">ctr</span> <span class="o">&gt;=</span> <span class="mi">200</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Monte Carlo algorithm in &quot;calc_orientations&quot; did not converge for resolution </span><span class="si">{</span><span class="n">res</span><span class="si">}</span><span class="s1">.</span><span class="se">\n</span><span class="s1">&#39;</span>
                           <span class="sa">f</span><span class="s1">&#39;Orientations found </span><span class="si">{</span><span class="n">indstart</span><span class="si">}</span><span class="s1"> orientations. Target was </span><span class="si">{</span><span class="n">nori</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Orientation</span><span class="p">(</span><span class="n">oq</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="n">cs</span><span class="p">)</span></div>



<div class="viewcode-block" id="odf_est">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.odf_est">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">odf_est</span><span class="p">(</span><span class="n">ori</span><span class="p">,</span> <span class="n">odf</span><span class="p">,</span> <span class="n">nstep</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">halfwidth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Estimate an ODF from a set of orientations using iterative half-width adjustment</span>

<span class="sd">    This function generates a new orientation distribution function (ODF) from</span>
<span class="sd">    input orientations by iteratively adjusting the half-width to minimize the</span>
<span class="sd">    error relative to a reference ODF.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ori : Orientation</span>
<span class="sd">        Input orientations used to estimate the ODF.</span>
<span class="sd">    odf : ODF</span>
<span class="sd">        Reference orientation distribution function for error comparison.</span>
<span class="sd">    nstep : int, optional</span>
<span class="sd">        Maximum number of iterations for adjusting the half-width. Default is 50.</span>
<span class="sd">    step : float, optional</span>
<span class="sd">        Increment step in degrees for half-width adjustment. Default is 0.5.</span>
<span class="sd">    halfwidth : float, optional</span>
<span class="sd">        Initial half-width in radians. If None, a value based on `odf.halfwidth` is used.</span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        If True, prints iteration details. Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ODF</span>
<span class="sd">        Estimated orientation distribution function corresponding to input orientations.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Uses `calc_error` to compare the estimated ODF with the reference ODF.</span>
<span class="sd">    - Iteratively increases half-width until the error starts to increase.</span>
<span class="sd">    - The returned ODF corresponds to the last half-width before error increased.</span>
<span class="sd">    - Does not modify the input orientations or reference ODF.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">e0</span> <span class="o">=</span> <span class="mf">1e8</span>
    <span class="n">st_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>
    <span class="n">hwmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">hwmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">nstep</span> <span class="o">*</span> <span class="n">st_rad</span>
    <span class="k">if</span> <span class="n">halfwidth</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">odf</span><span class="o">.</span><span class="n">halfwidth</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">nstep</span> <span class="o">*</span> <span class="n">st_rad</span><span class="p">,</span> <span class="n">hwmin</span><span class="p">,</span> <span class="n">hwmax</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Initial halfwidth set to </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">hw</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">halfwidth</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">st_rad</span><span class="p">,</span> <span class="n">hwmin</span><span class="p">,</span> <span class="n">hwmax</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Initial halfwidth is </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">hw</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nstep</span><span class="p">):</span>
        <span class="n">todf</span> <span class="o">=</span> <span class="n">ODF</span><span class="p">(</span><span class="n">ori</span><span class="p">,</span> <span class="n">halfwidth</span><span class="o">=</span><span class="n">hw</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">calc_error</span><span class="p">(</span><span class="n">odf</span><span class="p">,</span> <span class="n">todf</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Iteration </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s1">: error=</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s1">, halfwidth=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">hw</span><span class="p">)</span><span class="si">}</span><span class="s1">°&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">e</span> <span class="o">&gt;</span> <span class="n">e0</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">e0</span> <span class="o">=</span> <span class="n">e</span>
        <span class="n">hw</span> <span class="o">+=</span> <span class="n">st_rad</span>
    <span class="c1"># return last value before error increased</span>
    <span class="n">hw</span> <span class="o">-=</span> <span class="n">st_rad</span>
    <span class="n">todf</span> <span class="o">=</span> <span class="n">ODF</span><span class="p">(</span><span class="n">ori</span><span class="p">,</span> <span class="n">halfwidth</span><span class="o">=</span><span class="n">hw</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">todf</span></div>



<div class="viewcode-block" id="plot_pole_figure">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.plot_pole_figure">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">plot_pole_figure</span><span class="p">(</span><span class="n">orientations</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot an inverse pole figure and pole density function for given orientations</span>

<span class="sd">    This function visualizes the orientation distribution of a crystal phase by</span>
<span class="sd">    plotting the stereographic projection of specified poles and the corresponding</span>
<span class="sd">    pole density function (PDF).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    orientations : Orientation</span>
<span class="sd">        Orientation object containing crystal orientations to plot.</span>
<span class="sd">    phase : object</span>
<span class="sd">        Crystal phase object containing symmetry information and name.</span>
<span class="sd">    vector : array-like of shape (3,), optional</span>
<span class="sd">        Miller indices of the pole vector to plot. Default is [0, 0, 1].</span>
<span class="sd">    size : float, optional</span>
<span class="sd">        Marker size for scatter plot. Automatically scaled if None.</span>
<span class="sd">    alpha : float, optional</span>
<span class="sd">        Marker transparency for scatter plot. Automatically scaled if None.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Uses Matplotlib for plotting with stereographic projection.</span>
<span class="sd">    - The first subplot shows the inverse pole figure (scatter of poles).</span>
<span class="sd">    - The second subplot shows the pole density function.</span>
<span class="sd">    - Marker size and transparency are scaled inversely with the number of orientations.</span>
<span class="sd">    - Does not modify the input `orientations` or `phase`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># plot inverse pole figure</span>
    <span class="c1"># &lt;111&gt; poles in the sample reference frame</span>
    <span class="k">if</span> <span class="n">vector</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vector</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orientations</span><span class="p">,</span> <span class="n">Orientation</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">orientations</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;No orientations provided: </span><span class="si">{</span><span class="n">orientations</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
        <span class="n">scf</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">scf</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">orientations</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">250</span><span class="o">*</span><span class="n">scf</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">scf</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="n">t_</span> <span class="o">=</span> <span class="n">Miller</span><span class="p">(</span><span class="n">uvw</span><span class="o">=</span><span class="n">vector</span><span class="p">,</span> <span class="n">phase</span><span class="o">=</span><span class="n">phase</span><span class="p">)</span><span class="o">.</span><span class="n">symmetrise</span><span class="p">(</span><span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">t_all</span> <span class="o">=</span> <span class="n">orientations</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">t_</span><span class="p">)</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
    <span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">211</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s2">&quot;stereographic&quot;</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">t_all</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_labels</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">phase</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot; $\left&lt;&quot;</span> <span class="o">+</span>
                  <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}{</span><span class="n">vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}{</span><span class="n">vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">+</span>
                  <span class="sa">r</span><span class="s2">&quot;\right&gt;$ PF&quot;</span><span class="p">)</span>
    <span class="n">ax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">212</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s2">&quot;stereographic&quot;</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">pole_density_function</span><span class="p">(</span><span class="n">t_all</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">set_labels</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">phase</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot; $\left&lt;&quot;</span> <span class="o">+</span>
                  <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}{</span><span class="n">vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}{</span><span class="n">vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">+</span>
                  <span class="sa">r</span><span class="s2">&quot;\right&gt;$ PDF&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>



<div class="viewcode-block" id="plot_pole_figure_proj">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.plot_pole_figure_proj">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">plot_pole_figure_proj</span><span class="p">(</span><span class="n">orientations</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot an inverse pole figure (IPF) projection and pole density function for EBSD data</span>

<span class="sd">    This function visualizes crystal orientations along a specified sample direction</span>
<span class="sd">    using an IPF projection. The first subplot shows the scatter of rotated poles,</span>
<span class="sd">    and the second subplot shows the corresponding pole density function (PDF).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    orientations : Orientation</span>
<span class="sd">        Orientation object containing crystal orientations to plot.</span>
<span class="sd">    phase : object</span>
<span class="sd">        Crystal phase object with symmetry information and name.</span>
<span class="sd">    vector : array-like of shape (3,), optional</span>
<span class="sd">        Sample direction to project (Miller indices). Default is [0, 0, 1].</span>
<span class="sd">    title : str, optional</span>
<span class="sd">        Title for the plot. If None, automatically uses the principal axis of `vector`.</span>
<span class="sd">    alpha : float, optional</span>
<span class="sd">        Marker transparency for scatter plot. Automatically scaled if None.</span>
<span class="sd">    size : float, optional</span>
<span class="sd">        Marker size for scatter plot. Automatically scaled if None.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Uses Matplotlib with stereographic projection (IPF) for plotting.</span>
<span class="sd">    - Marker size and transparency are scaled inversely with the number of orientations.</span>
<span class="sd">    - The first subplot shows the inverse pole figure (scatter of rotated poles).</span>
<span class="sd">    - The second subplot shows the pole density function (PDF).</span>
<span class="sd">    - Does not modify the input `orientations` or `phase`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Some sample direction, v</span>
    <span class="k">if</span> <span class="n">vector</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vector</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">Miller</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">v_title</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">vector</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">v_title</span> <span class="o">=</span> <span class="n">title</span>
    <span class="k">if</span> <span class="n">orientations</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;No orientations provided: </span><span class="si">{</span><span class="n">orientations</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
        <span class="n">scf</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">scf</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">orientations</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">250</span><span class="o">*</span><span class="n">scf</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">scf</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orientations</span><span class="p">,</span> <span class="n">Orientation</span><span class="p">)</span>
    <span class="c1"># Rotate sample direction v into every crystal orientation O</span>
    <span class="n">t_</span> <span class="o">=</span> <span class="n">orientations</span> <span class="o">*</span> <span class="n">v</span>

    <span class="c1"># Set IPDF range</span>
    <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

    <span class="n">subplot_kw</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;projection&quot;</span><span class="p">:</span> <span class="s2">&quot;ipf&quot;</span><span class="p">,</span> <span class="s2">&quot;symmetry&quot;</span><span class="p">:</span> <span class="n">phase</span><span class="o">.</span><span class="n">point_group</span><span class="o">.</span><span class="n">laue</span><span class="p">,</span> <span class="s2">&quot;direction&quot;</span><span class="p">:</span> <span class="n">v</span><span class="p">}</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>

    <span class="n">ax0</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">211</span><span class="p">,</span> <span class="o">**</span><span class="n">subplot_kw</span><span class="p">)</span>
    <span class="n">ax0</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">t_</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax0</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;EBSD data, </span><span class="si">{</span><span class="n">phase</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">v_title</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">ax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">212</span><span class="p">,</span> <span class="o">**</span><span class="n">subplot_kw</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">pole_density_function</span><span class="p">(</span><span class="n">t_</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;EBSD data, </span><span class="si">{</span><span class="n">phase</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">v_title</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="find_orientations_fast">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.find_orientations_fast">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">find_orientations_fast</span><span class="p">(</span><span class="n">ori1</span><span class="p">:</span> <span class="n">Orientation</span><span class="p">,</span> <span class="n">ori2</span><span class="p">:</span> <span class="n">Orientation</span><span class="p">,</span> <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find closest matches in ori1 for each orientation in ori2 using KDTree</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ori1 : Orientation</span>
<span class="sd">        Orientation database (e.g., EBSD orientations).</span>
<span class="sd">    ori2 : Orientation</span>
<span class="sd">        Orientations to match (e.g., grain mean orientations).</span>
<span class="sd">    tol : float</span>
<span class="sd">        Angular tolerance in radians.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    matches : np.ndarray</span>
<span class="sd">        Array of indices in ori1 matching each entry in ori2; -1 if no match found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get quaternions</span>
    <span class="n">q1</span> <span class="o">=</span> <span class="n">ori1</span><span class="o">.</span><span class="n">data</span>
    <span class="n">q2</span> <span class="o">=</span> <span class="n">ori2</span><span class="o">.</span><span class="n">data</span>

    <span class="n">tree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">q2</span><span class="p">)</span>  <span class="c1"># KDTree in 4D quaternion space for ori2 (typically, regular SO3 grid)</span>
    <span class="n">dists</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">q1</span><span class="p">)</span>  <span class="c1"># For every orientation in ori1, look for nearest neighbor in ori2 (grid)</span>

    <span class="c1"># create list of length or ori2, and store counts and indices of nearest neighbors in ori1</span>
    <span class="n">matches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ori2</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">neigh_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
        <span class="n">matches</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">neigh_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">neigh_dict</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">neigh_dict</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">matches</span><span class="p">,</span> <span class="n">neigh_dict</span></div>



<div class="viewcode-block" id="texture_reconstruction">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.texture_reconstruction">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">texture_reconstruction</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">ebsd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ebsdfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">orientations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">grainsfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">grains</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kernel_halfwidth</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                          <span class="n">res_low</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">res_high</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">res_step</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">lim</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reconstruct a reduced ODF from EBSD or orientation data</span>

<span class="sd">    This function systematically reconstructs an orientation distribution function (ODF)</span>
<span class="sd">    using a given number of orientations or grains in a representative volume element (RVE).</span>
<span class="sd">    The reconstructed ODF approximates the misorientation distribution of the input data.</span>
<span class="sd">    Follows the method described in Biswas et al. (https://doi.org/10.1107/S1600576719017138).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ns : int</span>
<span class="sd">        Number of reduced orientations/grains in the RVE.</span>
<span class="sd">    ebsd : EBSDmap, optional</span>
<span class="sd">        EBSD map containing orientations for a single phase.</span>
<span class="sd">    ebsdfile : str, optional</span>
<span class="sd">        Path to a *.mat file with EBSD data (not yet supported).</span>
<span class="sd">    orientations : Orientation, optional</span>
<span class="sd">        Predefined orientations to use instead of EBSD data.</span>
<span class="sd">    grainsfile : str, optional</span>
<span class="sd">        Path to estimated grains file (*.mat). Not used for kernel estimation.</span>
<span class="sd">    grains : object, optional</span>
<span class="sd">        Grain data. Not used for kernel estimation.</span>
<span class="sd">    kernel : DeLaValleePoussinKernel, optional</span>
<span class="sd">        Kernel for ODF estimation. Default: halfwidth=kernel_halfwidth.</span>
<span class="sd">    kernel_halfwidth : float, optional</span>
<span class="sd">        Halfwidth in degrees for default DeLaValleePoussin kernel. Default is 5°.</span>
<span class="sd">    res_low : float, optional</span>
<span class="sd">        Minimum resolution (in degrees) of orientation grid for reconstruction. Default 5°.</span>
<span class="sd">    res_high : float, optional</span>
<span class="sd">        Maximum resolution (in degrees) of orientation grid. Default 25°.</span>
<span class="sd">    res_step : float, optional</span>
<span class="sd">        Step size (in degrees) for grid resolution. Default 2°.</span>
<span class="sd">    lim : int, optional</span>
<span class="sd">        Maximum number of consecutive worsening errors before stopping. Default 5.</span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        If True, print progress and error information. Default False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    orired_f : Orientation</span>
<span class="sd">        Reduced set of orientations in the fundamental region.</span>
<span class="sd">    odfred_f : ODF</span>
<span class="sd">        Reconstructed ODF using the reduced orientations.</span>
<span class="sd">    ero : float</span>
<span class="sd">        L1 error between reference ODF and reconstructed ODF.</span>
<span class="sd">    res : float</span>
<span class="sd">        Grid resolution (degrees) at which the minimum error was achieved.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Uses Monte Carlo sampling and kernel smoothing to generate reduced orientations.</span>
<span class="sd">    - Only supports single-phase EBSD data.</span>
<span class="sd">    - Kernel estimation from grains or files is not yet supported; default kernel is used.</span>
<span class="sd">    - The reconstructed ODF approximates the misorientation distribution of the input data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ori</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">psi</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">ebsdfile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span><span class="s1">&#39;Option &quot;ebsdMatFile&quot; is not yet supported.&#39;</span><span class="p">)</span>
        <span class="c1"># ind = args.index(&#39;ebsdMatFile&#39;) + 1</span>
        <span class="c1"># ebsd = loadmat(args[ind])</span>
        <span class="c1"># ebsd_var = list(ebsd.keys())[0]</span>
        <span class="c1"># ebsd = ebsd[ebsd_var]</span>
        <span class="c1"># assert len(np.unique(ebsd.phaseId)) == 1, &#39;EBSD has multiple phases&#39;</span>
        <span class="c1"># ori = ebsd.orientations</span>
    <span class="k">if</span> <span class="n">ebsd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ebsd</span><span class="p">,</span> <span class="n">EBSDmap</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Argument &quot;ebsd&quot; must be of type EBSDmap.&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ebsd</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phases</span><span class="o">.</span><span class="n">ids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;EBSD has multiple phases&#39;</span>
        <span class="k">if</span> <span class="n">ori</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Both arguments &quot;ebsd&quot; and &quot;ori&quot; are given, using EBSD map orientations.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ori</span> <span class="o">=</span> <span class="n">ebsd</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">orientations</span>
    <span class="k">if</span> <span class="n">orientations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orientations</span><span class="p">,</span> <span class="n">Orientation</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Argument &quot;orientations&quot; must be of type Orientation,&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ori</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Both EBSD map and orientations are given, using EBSD.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ori</span> <span class="o">=</span> <span class="n">orientations</span>

    <span class="k">if</span> <span class="n">grainsfile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Estimation of optimal kernel from grain files not supported. &#39;</span>
                        <span class="s1">&#39;DeLaValleePoussinKernel with halfwidth 5° will be used.</span><span class="se">\n</span><span class="s1">&#39;</span>
                        <span class="s1">&#39;Please use kanapy-mtex for support of optimal kernels.&#39;</span><span class="p">)</span>
        <span class="c1"># ind = args.index(&#39;grainsMatFile&#39;) + 1</span>
        <span class="c1"># grains = loadmat(args[ind])</span>
        <span class="c1"># grains_var = list(grains.keys())[0]</span>
        <span class="c1"># grains = grains[grains_var]</span>
        <span class="c1"># assert len(np.unique(grains.phaseId)) == 1, &#39;Grains has multiple phases&#39;</span>
        <span class="c1"># print(&#39;Optimum kernel estimated from mean orientations of grains&#39;)</span>
        <span class="c1"># psi = calcKernel(grains.meanOrientation)</span>
    <span class="k">if</span> <span class="n">grains</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Estimation of optimal kernel from grains not supported. &#39;</span>
                        <span class="s1">&#39;DeLaValleePoussinKernel with halfwidth 5° will be used.</span><span class="se">\n</span><span class="s1">&#39;</span>
                        <span class="s1">&#39;Please use kanapy-mtex for support of optimal kernels.&#39;</span><span class="p">)</span>
        <span class="c1">#assert len(np.unique(grains.phaseId)) == 1, &#39;Grains has multiple phases&#39;</span>
        <span class="c1">#print(&#39;Optimum kernel estimated from mean orientations of grains&#39;)</span>
        <span class="c1">#psi = calcKernel(grains.meanOrientation)</span>
    <span class="k">if</span> <span class="n">kernel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">DeLaValleePoussinKernel</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Only kernels of type &quot;DeLaValeePoussinKernel&quot; are supported.&#39;</span><span class="p">)</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="n">kernel</span>
    <span class="k">if</span> <span class="n">psi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="n">DeLaValleePoussinKernel</span><span class="p">(</span><span class="n">halfwidth</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">kernel_halfwidth</span><span class="p">))</span>

    <span class="c1"># Step 1: Create reference odf from given orientations with proper kernel</span>
    <span class="n">odf</span> <span class="o">=</span> <span class="n">ODF</span><span class="p">(</span><span class="n">ori</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="n">psi</span><span class="p">)</span>
    <span class="n">cs</span> <span class="o">=</span> <span class="n">ori</span><span class="o">.</span><span class="n">symmetry</span>

    <span class="n">ero</span> <span class="o">=</span> <span class="mf">10.</span>
    <span class="n">e_mod</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">hw_stored</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">hw</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">res_low</span><span class="p">,</span> <span class="n">res_high</span> <span class="o">+</span> <span class="n">res_step</span><span class="p">,</span> <span class="n">res_step</span><span class="p">):</span>
        <span class="c1"># Step 2: create equispaced grid of orientations</span>
        <span class="n">S3G</span> <span class="o">=</span> <span class="n">get_sample_fundamental</span><span class="p">(</span><span class="n">resolution</span><span class="o">=</span><span class="n">hw</span><span class="p">,</span> <span class="n">point_group</span><span class="o">=</span><span class="n">cs</span><span class="p">)</span>  <span class="c1"># resolution in degrees! ori.SS not considered</span>
        <span class="n">S3G</span> <span class="o">=</span> <span class="n">Orientation</span><span class="p">(</span><span class="n">S3G</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="n">cs</span><span class="p">)</span>
        <span class="c1"># Step 3: calculate number of orientations close to each grid point (0 if no orientation close to GP)</span>
        <span class="c1"># count close orientations from EBSD map for each grid point, and get list of neighbor indices</span>
        <span class="n">M</span><span class="p">,</span> <span class="n">neighs</span> <span class="o">=</span> <span class="n">find_orientations_fast</span><span class="p">(</span><span class="n">ori</span><span class="p">,</span> <span class="n">S3G</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mf">0.5</span><span class="p">))</span>
        <span class="n">ictr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">M</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># indices of gridpoints with non-zero counts</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">ictr</span><span class="p">]</span>  <span class="c1"># create weights from non-zero counts of EBSD orientations at gridpoints</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>  <span class="c1"># calculate weights</span>
        <span class="c1"># Step 4: Calculate scaling factor hval such that sum of all int(weights*hval) = ns</span>
        <span class="n">lval</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">hval</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">ns</span><span class="p">)</span>
        <span class="n">ifc</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">ihval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">hval</span> <span class="o">*</span> <span class="n">weights</span><span class="p">))</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">hval</span> <span class="o">-</span> <span class="n">lval</span> <span class="o">&gt;</span> <span class="n">hval</span> <span class="o">*</span> <span class="mf">1e-15</span> <span class="ow">or</span> <span class="n">ihval</span> <span class="o">&lt;</span> <span class="n">ns</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ihval</span> <span class="o">!=</span> <span class="n">ns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ihval</span> <span class="o">&lt;</span> <span class="n">ns</span><span class="p">:</span>
                <span class="n">hval_old</span> <span class="o">=</span> <span class="n">hval</span>
                <span class="n">hval</span> <span class="o">=</span> <span class="n">hval</span> <span class="o">+</span> <span class="n">ifc</span> <span class="o">*</span> <span class="p">(</span><span class="n">hval</span> <span class="o">-</span> <span class="n">lval</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="n">lval</span> <span class="o">=</span> <span class="n">hval_old</span>
                <span class="n">ifc</span> <span class="o">=</span> <span class="n">ifc</span> <span class="o">*</span> <span class="mf">2.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hval</span> <span class="o">=</span> <span class="p">(</span><span class="n">lval</span> <span class="o">+</span> <span class="n">hval</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="n">ifc</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="n">ihval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">hval</span> <span class="o">*</span> <span class="n">weights</span><span class="p">))</span>
        <span class="n">screen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">weights</span> <span class="o">*</span> <span class="n">hval</span><span class="p">)</span>  <span class="c1"># number of orientations associated to each grid point</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">screen</span><span class="p">)</span> <span class="o">-</span> <span class="n">ns</span>  <span class="c1"># difference to desired number of orientations</span>
        <span class="n">weights_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        <span class="n">co</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">screen</span><span class="p">[</span><span class="n">weights_loc</span><span class="p">[</span><span class="n">co</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">screen</span><span class="p">[</span><span class="n">weights_loc</span><span class="p">[</span><span class="n">co</span><span class="p">]]</span> <span class="o">=</span> <span class="n">screen</span><span class="p">[</span><span class="n">weights_loc</span><span class="p">[</span><span class="n">co</span><span class="p">]]</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">screen</span><span class="p">)</span> <span class="o">-</span> <span class="n">ns</span>
            <span class="n">co</span> <span class="o">=</span> <span class="n">co</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># Step 5: Subdivide orientations around grid points into screen orientations</span>
        <span class="c1">#         and estimate mean orientation for each group or take orientation of grid point</span>
        <span class="c1">#         if only one orientation needs to be generated</span>
        <span class="n">ori_red</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ns</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
        <span class="n">octr</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">no</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">screen</span><span class="p">):</span>
            <span class="n">nl</span> <span class="o">=</span> <span class="n">neighs</span><span class="p">[</span><span class="n">ictr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nl</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">no</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">nl</span><span class="p">)</span><span class="si">}</span><span class="s1"> &lt; </span><span class="si">{</span><span class="n">no</span><span class="si">}</span><span class="s1"> @ </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">, ictr: </span><span class="si">{</span><span class="n">ictr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1">, weight: </span><span class="si">{</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="mf">0.5</span> <span class="o">&lt;</span> <span class="n">no</span> <span class="o">&lt;</span> <span class="mf">1.5</span><span class="p">:</span>
                <span class="n">ori_red</span><span class="p">[</span><span class="n">octr</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">S3G</span><span class="p">[</span><span class="n">ictr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">data</span>
                <span class="n">octr</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">no</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;no: </span><span class="si">{</span><span class="n">no</span><span class="si">}</span><span class="s1">, should be 1&#39;</span>
            <span class="k">elif</span> <span class="n">no</span> <span class="o">&gt;=</span> <span class="mf">1.5</span><span class="p">:</span>
                <span class="c1"># split orientations in EBSD map matching to one grid point according to required number of</span>
                <span class="c1"># orientations at this point</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nl</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">no</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nl</span><span class="p">),</span> <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">ho</span> <span class="o">=</span> <span class="n">octr</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">:</span>
                    <span class="n">ori_red</span><span class="p">[</span><span class="n">octr</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ori</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">octr</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">no</span><span class="p">,</span> <span class="n">octr</span><span class="o">-</span><span class="n">ho</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;len_nl: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">nl</span><span class="p">)</span><span class="si">}</span><span class="s1">, len_idx: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;no: </span><span class="si">{</span><span class="n">no</span><span class="si">}</span><span class="s1">, but increment is only #</span><span class="si">{</span><span class="n">octr</span><span class="o">-</span><span class="n">ho</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># create Orientations from quaternion array</span>
        <span class="n">ori_f</span> <span class="o">=</span> <span class="n">Orientation</span><span class="p">(</span><span class="n">ori_red</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="n">cs</span><span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ori_f</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">ori_f</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>

        <span class="c1"># Step 6: Compute reduced ODF</span>
        <span class="n">odfred</span> <span class="o">=</span> <span class="n">odf_est</span><span class="p">(</span><span class="n">ori_f</span><span class="p">,</span> <span class="n">odf</span><span class="p">,</span> <span class="n">halfwidth</span><span class="o">=</span><span class="n">hw_stored</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">hw_stored</span> <span class="o">=</span> <span class="n">odfred</span><span class="o">.</span><span class="n">halfwidth</span>

        <span class="c1"># Step 7: Compute error for kernel optimization</span>
        <span class="n">er</span> <span class="o">=</span> <span class="n">calc_error</span><span class="p">(</span><span class="n">odf</span><span class="p">,</span> <span class="n">odfred</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Resolution: </span><span class="si">{</span><span class="n">hw</span><span class="si">}</span><span class="s1">, Error: </span><span class="si">{</span><span class="n">er</span><span class="si">}</span><span class="s1">, Reduced HW: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">odfred</span><span class="o">.</span><span class="n">halfwidth</span><span class="p">)</span><span class="si">}</span><span class="s1">°&#39;</span><span class="p">)</span>
        <span class="c1"># store best results and evaluate stopping criterion</span>
        <span class="k">if</span> <span class="n">er</span> <span class="o">&lt;</span> <span class="n">ero</span><span class="p">:</span>
            <span class="n">orired_f</span> <span class="o">=</span> <span class="n">ori_f</span>
            <span class="n">odfred_f</span> <span class="o">=</span> <span class="n">odfred</span>
            <span class="n">ero</span> <span class="o">=</span> <span class="n">er</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">hw</span>
        <span class="n">e_mod</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">er</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">e_mod</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">e_mod</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">lim</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="n">orired_f</span> <span class="o">=</span> <span class="n">orired_f</span><span class="o">.</span><span class="n">in_euler_fundamental_region</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">orired_f</span><span class="p">,</span> <span class="n">odfred_f</span><span class="p">,</span> <span class="n">ero</span><span class="p">,</span> <span class="n">res</span></div>



<div class="viewcode-block" id="Kernel">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.Kernel">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Kernel</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract base class for kernels used in orientation distribution estimation.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    A : ndarray</span>
<span class="sd">        Flattened array of kernel parameters. Initialized to empty array if not provided.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">if</span> <span class="n">A</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">bandwidth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the bandwidth of the kernel.</span>

<span class="sd">        The bandwidth is defined as the number of elements in `A` minus one.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Bandwidth of the kernel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="nd">@bandwidth</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">bandwidth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the bandwidth of the kernel.</span>

<span class="sd">        Truncates the kernel parameter array `A` to have at most `L + 1` elements.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        L : int</span>
<span class="sd">            Desired bandwidth.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[:</span><span class="nb">min</span><span class="p">(</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">))]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a human-readable string representation of the kernel.</span>

<span class="sd">        Displays the kernel type and its halfwidth in degrees.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            String describing the kernel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;custom, halfwidth </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">halfwidth</span><span class="p">())</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">°&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if two kernels are equal.</span>

<span class="sd">        Comparison is based on the truncated arrays of kernel parameters `A` up to</span>
<span class="sd">        the minimum bandwidth of the two kernels. Returns True if the relative</span>
<span class="sd">        difference is less than 1e-6.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Kernel</span>
<span class="sd">            Another kernel to compare against.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if kernels are considered equal, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">L</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bandwidth</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">bandwidth</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[:</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">A</span><span class="p">[:</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-6</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multiply two kernels element-wise with scaling by (2l + 1).</span>

<span class="sd">        Only the first `L + 1` elements are used, where L is the minimum bandwidth</span>
<span class="sd">        of the two kernels. Returns a new Kernel instance with the resulting array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Kernel</span>
<span class="sd">            Another kernel to multiply with.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Kernel</span>
<span class="sd">            New kernel resulting from element-wise multiplication and scaling.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">L</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bandwidth</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">bandwidth</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Kernel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[:</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">A</span><span class="p">[:</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Raise kernel elements to a given power with scaling.</span>

<span class="sd">        Each element of the kernel parameter array `A` is scaled by (2l + 1),</span>
<span class="sd">        raised to the power `p`, and then rescaled by (2l + 1).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        p : float</span>
<span class="sd">            Power to raise the kernel elements to.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Kernel</span>
<span class="sd">            New kernel resulting from the power operation with scaling.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bandwidth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Kernel</span><span class="p">(((</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">**</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

<div class="viewcode-block" id="Kernel.norm">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.Kernel.norm">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the L2 norm of the squared kernel elements.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            L2 norm of the squared elements of the kernel array `A`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="Kernel.cutA">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.Kernel.cutA">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cutA</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fft_accuracy</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Truncate the kernel array `A` based on the specified FFT accuracy.</span>

<span class="sd">        Elements of `A` are scaled by 1/(l^2), and elements smaller than</span>
<span class="sd">        a threshold determined from `fft_accuracy` are removed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fft_accuracy : float, optional</span>
<span class="sd">            Desired FFT accuracy (default is 1e-2).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The first element is never truncated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">epsilon</span> <span class="o">=</span> <span class="n">fft_accuracy</span> <span class="o">/</span> <span class="mi">150</span>
        <span class="n">A_mod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">A_mod</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&lt;=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">A_mod</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">epsilon</span><span class="p">]),</span> <span class="n">epsilon</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">idx</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[:</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span></div>


<div class="viewcode-block" id="Kernel.halfwidth">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.Kernel.halfwidth">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">halfwidth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the halfwidth of the kernel.</span>

<span class="sd">        The halfwidth is determined by finding the angle `omega` that minimizes</span>
<span class="sd">        the squared difference between K(1) and 2*K(cos(omega/2)).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Halfwidth angle in radians.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">error_fn</span><span class="p">(</span><span class="n">omega</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Compute the squared difference used to determine kernel halfwidth.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            omega : float</span>
<span class="sd">                Angle in radians to evaluate the kernel function.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            float</span>
<span class="sd">                Squared difference: (K(1) - 2*K(cos(omega/2)))**2</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)))</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="k">return</span> <span class="n">fminbound</span><span class="p">(</span><span class="n">error_fn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span></div>


<div class="viewcode-block" id="Kernel.K">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.Kernel.K">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">K</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">co2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the kernel function at a given squared cosine value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        co2 : float or ndarray</span>
<span class="sd">            Cosine squared value(s), will be clipped to [-1, 1].</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float or ndarray</span>
<span class="sd">            Value(s) of the kernel function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">co2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">co2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">co2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clenshawU</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">omega</span><span class="p">)</span></div>


<div class="viewcode-block" id="Kernel.K_orientations">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.Kernel.K_orientations">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">K_orientations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orientations_ref</span><span class="p">,</span> <span class="n">orientations</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the kernel function for the misorientation angles between two sets of orientations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        orientations_ref : Orientation</span>
<span class="sd">            Reference set of orientations.</span>
<span class="sd">        orientations : Orientation</span>
<span class="sd">            Target set of orientations to compare.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">            Kernel values corresponding to misorientation angles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">misangles</span> <span class="o">=</span> <span class="n">orientations</span><span class="o">.</span><span class="n">angle_with</span><span class="p">(</span><span class="n">orientations_ref</span><span class="p">)</span>
        <span class="n">co2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">misangles</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">(</span><span class="n">co2</span><span class="p">)</span></div>


<div class="viewcode-block" id="Kernel.RK">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.Kernel.RK">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">RK</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the kernel using the Clenshaw-L method for given cosine distances.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        d : array_like</span>
<span class="sd">            Cosine of angles (distance metric) in the range [-1, 1].</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">            Kernel values for the given distances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clenshawL</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span></div>


<div class="viewcode-block" id="Kernel.RRK">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.Kernel.RRK">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">RRK</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dh</span><span class="p">,</span> <span class="n">dr</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the kernel on two sets of cosine distances using a reduced rotational kernel.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dh : array_like</span>
<span class="sd">            Cosines of angles for the first set, clipped to [-1, 1].</span>
<span class="sd">        dr : array_like</span>
<span class="sd">            Cosines of angles for the second set, clipped to [-1, 1].</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">            2D array of kernel values for each combination of dh and dr.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">dh</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">dr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">dr</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bandwidth</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">dh</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">dr</span><span class="p">)))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dh</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">dr</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dh_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dh</span><span class="p">):</span>
                <span class="n">Plh</span> <span class="o">=</span> <span class="p">[</span><span class="n">legendre</span><span class="p">(</span><span class="n">l</span><span class="p">)(</span><span class="n">dh_i</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clenshawL</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Plh</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">dr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">dr_j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dr</span><span class="p">):</span>
                <span class="n">Plr</span> <span class="o">=</span> <span class="p">[</span><span class="n">legendre</span><span class="p">(</span><span class="n">l</span><span class="p">)(</span><span class="n">dr_j</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
                <span class="n">result</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clenshawL</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Plr</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">dh</span><span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">result</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_clenshawU</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">omega</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the kernel using the Clenshaw algorithm in the Chebyshev U basis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        A : array_like</span>
<span class="sd">            Coefficients of the kernel.</span>
<span class="sd">        omega : array_like</span>
<span class="sd">            Angles in radians.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">            Kernel values evaluated at the given angles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="n">omega</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)):</span>
            <span class="n">term</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">*</span> <span class="n">omega</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">omega</span><span class="p">)</span> <span class="o">+</span> \
                   <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">*</span> <span class="n">term</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_clenshawL</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the kernel using the Clenshaw algorithm in the Legendre basis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        A : array_like</span>
<span class="sd">            Coefficients of the kernel.</span>
<span class="sd">        x : array_like</span>
<span class="sd">            Input values where the kernel is evaluated (should be within [-1, 1]).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray or float</span>
<span class="sd">            Kernel values evaluated at the given input(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">b_next</span><span class="p">,</span> <span class="n">b_curr</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">b_next</span><span class="p">,</span> <span class="n">b_curr</span> <span class="o">=</span> <span class="n">b_curr</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">x2</span> <span class="o">*</span> <span class="n">b_curr</span> <span class="o">-</span> <span class="n">b_next</span>
        <span class="k">return</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">b_curr</span> <span class="o">-</span> <span class="n">b_next</span>

<div class="viewcode-block" id="Kernel.calc_fourier">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.Kernel.calc_fourier">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calc_fourier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">max_angle</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">fft_accuracy</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the Fourier coefficients of the kernel up to order L.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        L : int</span>
<span class="sd">            Maximum order of the Fourier coefficients.</span>
<span class="sd">        max_angle : float, optional</span>
<span class="sd">            Upper limit of integration in radians (default is pi).</span>
<span class="sd">        fft_accuracy : float, optional</span>
<span class="sd">            Threshold below which coefficients are considered negligible and</span>
<span class="sd">            computation stops early (default is 1e-2).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">            Array of Fourier coefficients of length &lt;= L+1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">A</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">small</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">integrand</span><span class="p">(</span><span class="n">omega</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">omega</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

            <span class="n">coeff</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">max_angle</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">2000</span><span class="p">)</span>
            <span class="n">coeff</span> <span class="o">*=</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="n">A</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">fft_accuracy</span><span class="p">:</span>
                <span class="n">small</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">small</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">small</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A</span><span class="p">)</span></div>


<div class="viewcode-block" id="Kernel.plot_K">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.Kernel.plot_K">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_K</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_points</span><span class="o">=</span><span class="mi">200</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the kernel function K as a function of misorientation angle.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_points : int, optional</span>
<span class="sd">            Number of points used for plotting the kernel function (default is 200).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_points</span><span class="p">)</span>
        <span class="n">co2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">(</span><span class="n">co2</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">omega</span><span class="p">),</span> <span class="n">values</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Misorientation angle (degrees)&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;K(cos(omega/2))&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Kernel Function&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="DeLaValleePoussinKernel">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.DeLaValleePoussinKernel">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DeLaValleePoussinKernel</span><span class="p">(</span><span class="n">Kernel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    De La Vallee Poussin kernel class for orientation distribution functions</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    kappa : float, optional</span>
<span class="sd">        Shape parameter of the kernel</span>
<span class="sd">    halfwidth : float, optional</span>
<span class="sd">        Halfwidth in radians; overrides kappa if provided</span>
<span class="sd">    bandwidth : int, optional</span>
<span class="sd">        Maximum degree of the series expansion</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    A : ndarray</span>
<span class="sd">        Series coefficients of the kernel</span>
<span class="sd">    kappa : float</span>
<span class="sd">        Shape parameter of the kernel</span>
<span class="sd">    C : float</span>
<span class="sd">        Normalization constant</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kappa</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">halfwidth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bandwidth</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">halfwidth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kappa</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">halfwidth</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">kappa</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kappa</span> <span class="o">=</span> <span class="mi">90</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span> <span class="o">=</span> <span class="n">kappa</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">bandwidth</span> <span class="k">if</span> <span class="n">bandwidth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">round</span><span class="p">(</span><span class="n">kappa</span><span class="p">)</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">beta</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="n">beta</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">kappa</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="n">C</span>

        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">kappa</span> <span class="o">/</span> <span class="p">(</span><span class="n">kappa</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">A</span><span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">kappa</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="n">l</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">kappa</span> <span class="o">+</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">A</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cutA</span><span class="p">()</span>

<div class="viewcode-block" id="DeLaValleePoussinKernel.K">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.DeLaValleePoussinKernel.K">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">K</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">co2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the De La Vallee Poussin kernel function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        co2 : float or ndarray</span>
<span class="sd">            Cosine of half the misorientation angle. Values will be clipped to [-1, 1].</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float or ndarray</span>
<span class="sd">            Kernel value(s) evaluated at the input `co2`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">co2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">co2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="o">*</span> <span class="n">co2</span> <span class="o">**</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span><span class="p">)</span></div>


<div class="viewcode-block" id="DeLaValleePoussinKernel.DK">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.DeLaValleePoussinKernel.DK">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">DK</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">co2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the derivative of the De La Vallee Poussin kernel with respect to misorientation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        co2 : float or ndarray</span>
<span class="sd">            Cosine of half the misorientation angle. Values should be in [-1, 1].</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float or ndarray</span>
<span class="sd">            Derivative of the kernel function evaluated at the input `co2`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">co2</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">co2</span> <span class="o">**</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="DeLaValleePoussinKernel.RK">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.DeLaValleePoussinKernel.RK">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">RK</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the reduced kernel function R_K at a given input.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        t : float or ndarray</span>
<span class="sd">            Input value, typically representing a normalized distance or cosine value.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float or ndarray</span>
<span class="sd">            Value of the reduced kernel function R_K at `t`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span></div>


<div class="viewcode-block" id="DeLaValleePoussinKernel.DRK">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.DeLaValleePoussinKernel.DRK">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">DRK</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the derivative of the reduced kernel function R_K at a given input.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        t : float or ndarray</span>
<span class="sd">            Input value, typically representing a normalized distance or cosine value.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float or ndarray</span>
<span class="sd">            Value of the derivative of R_K at `t`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kappa</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span></div>


<div class="viewcode-block" id="DeLaValleePoussinKernel.halfwidth">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.DeLaValleePoussinKernel.halfwidth">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">halfwidth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the halfwidth of the DeLaValleePoussin kernel.</span>

<span class="sd">        The halfwidth is the misorientation angle ω where the kernel value</span>
<span class="sd">        drops to half its maximum.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Halfwidth angle in radians.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span><span class="p">)))</span></div>
</div>



<div class="viewcode-block" id="ODF">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.ODF">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ODF</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Estimate an Orientation Distribution Function (ODF) from a set of orientations</span>
<span class="sd">    using kernel density estimation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    orientations : orix.quaternion.Orientation</span>
<span class="sd">        Input orientation set.</span>
<span class="sd">    halfwidth : float, optional</span>
<span class="sd">        Halfwidth of the kernel in radians (default: 10 degrees).</span>
<span class="sd">    weights : array-like, optional</span>
<span class="sd">        Weights for each orientation. If None, uniform weights are used.</span>
<span class="sd">    kernel : Kernel instance, optional</span>
<span class="sd">        Kernel function to use. If None, DeLaValleePoussinKernel is used.</span>
<span class="sd">    exact : bool, optional</span>
<span class="sd">        If False and orientation count &gt; 1000, approximation using grid is applied.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    orientations : orix.quaternion.Orientation</span>
<span class="sd">        Orientation set stored in the ODF.</span>
<span class="sd">    weights : ndarray</span>
<span class="sd">        Normalized weights of the orientations.</span>
<span class="sd">    kernel : Kernel</span>
<span class="sd">        Kernel used for density estimation.</span>
<span class="sd">    halfwidth : float</span>
<span class="sd">        Halfwidth of the kernel in radians.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orientations</span><span class="p">,</span> <span class="n">halfwidth</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">orientations</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Orientation set is empty.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">orientations</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">/</span> <span class="n">orientations</span><span class="o">.</span><span class="n">size</span>

        <span class="c1"># Set up kernel</span>
        <span class="k">if</span> <span class="n">kernel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kernel</span> <span class="o">=</span> <span class="n">DeLaValleePoussinKernel</span><span class="p">(</span><span class="n">halfwidth</span><span class="o">=</span><span class="n">halfwidth</span><span class="p">)</span>
        <span class="n">hw</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">halfwidth</span><span class="p">()</span>

        <span class="c1"># Gridify if too many orientations and not exact</span>
        <span class="k">if</span> <span class="n">orientations</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1000</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">exact</span><span class="p">:</span>
            <span class="c1"># Placeholder: replace with proper gridify function if needed</span>
            <span class="c1"># Currently using simple thinning and weighting</span>
            <span class="n">step</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">orientations</span><span class="o">.</span><span class="n">size</span> <span class="o">//</span> <span class="mi">1000</span><span class="p">)</span>
            <span class="n">orientations</span> <span class="o">=</span> <span class="n">orientations</span><span class="p">[::</span><span class="n">step</span><span class="p">]</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[::</span><span class="n">step</span><span class="p">]</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">orientations</span> <span class="o">=</span> <span class="n">orientations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">halfwidth</span> <span class="o">=</span> <span class="n">hw</span>

<div class="viewcode-block" id="ODF.evaluate">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.ODF.evaluate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ori</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the ODF at given orientations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ori : Orientation</span>
<span class="sd">            Orientation(s) at which to evaluate the ODF.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        values : ndarray</span>
<span class="sd">            ODF values at the specified orientations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ori</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">orientations</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span><span class="o">.</span><span class="n">K_orientations</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">ori</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">values</span></div>
</div>



<div class="viewcode-block" id="EBSDmap">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.EBSDmap">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">EBSDmap</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to store attributes and methods to import EBSD maps</span>
<span class="sd">    and filter out their statistical data needed to generate</span>
<span class="sd">    synthetic RVEs</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname : str</span>
<span class="sd">        Filename including path to EBSD file.</span>
<span class="sd">    gs_min : float, optional</span>
<span class="sd">        Minimum grain size in pixels. Grains smaller than this are disregarded</span>
<span class="sd">        for statistical analysis. Default is 10.0.</span>
<span class="sd">    vf_min : float, optional</span>
<span class="sd">        Minimum volume fraction. Phases with smaller values are disregarded.</span>
<span class="sd">        Default is 0.03.</span>
<span class="sd">    max_angle : float, optional</span>
<span class="sd">        Maximum misorientation angle (degrees) used for grain merging.</span>
<span class="sd">        Default is 5.0.</span>
<span class="sd">    connectivity : int, optional</span>
<span class="sd">        Connectivity for grain identification. Default is 8.</span>
<span class="sd">    show_plot : bool, optional</span>
<span class="sd">        If True, plots microstructure maps. Default is True.</span>
<span class="sd">    show_hist : bool, optional</span>
<span class="sd">        If True, plots histograms of grain statistics. Default follows `show_plot`.</span>
<span class="sd">    felzenszwalb : bool, optional</span>
<span class="sd">        If True, applies Felzenszwalb segmentation. Default is False.</span>
<span class="sd">    show_grains : bool, optional</span>
<span class="sd">        If True, plots grain labeling. Default is False.</span>
<span class="sd">    hist : bool, optional</span>
<span class="sd">        Deprecated. Use `show_hist` instead.</span>
<span class="sd">    plot : bool, optional</span>
<span class="sd">        Deprecated. Use `show_plot` instead.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    emap : object</span>
<span class="sd">        Loaded EBSD map object.</span>
<span class="sd">    sh_x, sh_y : int</span>
<span class="sd">        Shape of EBSD map in pixels.</span>
<span class="sd">    dx, dy : float</span>
<span class="sd">        Pixel size in microns.</span>
<span class="sd">    npx : int</span>
<span class="sd">        Total number of pixels in the map.</span>
<span class="sd">    ms_data : list of dict</span>
<span class="sd">        Phase-specific microstructure information including:</span>
<span class="sd">        - name : str — phase name</span>
<span class="sd">        - vf : float — volume fraction</span>
<span class="sd">        - index : int — phase index</span>
<span class="sd">        - ori : Orientation — grain orientations</span>
<span class="sd">        - cs : crystal symmetry / Laue group</span>
<span class="sd">        - mo_map : ndarray — misorientation field</span>
<span class="sd">        - rgb_im : ndarray — IPF color image</span>
<span class="sd">        - ngrains : int — number of grains</span>
<span class="sd">        - gs_param, ar_param, om_param : ndarray — grain size, aspect ratio, main axis angle parameters</span>
<span class="sd">        - gs_data, ar_data, om_data : ndarray — raw distributions</span>
<span class="sd">        - gs_moments, ar_moments, om_moments : list — distribution moments</span>
<span class="sd">        - graph : object — microstructure graph</span>
<span class="sd">    ci_map : ndarray</span>
<span class="sd">        Optional confidence index map if available.</span>
<span class="sd">    ngrains : int</span>
<span class="sd">        Total number of grains after merging/pruning.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">gs_min</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">vf_min</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span> <span class="n">max_angle</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
                 <span class="n">show_plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">show_hist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">felzenszwalb</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">show_grains</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">hist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>


        <span class="k">def</span><span class="w"> </span><span class="nf">reassign</span><span class="p">(</span><span class="n">pix</span><span class="p">,</span> <span class="n">ori</span><span class="p">,</span> <span class="n">phid</span><span class="p">,</span> <span class="n">bads</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Reassign the orientation of a pixel based on neighboring pixels of the same phase.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            pix : int</span>
<span class="sd">                Index of the pixel to be reassigned.</span>
<span class="sd">            ori : ndarray</span>
<span class="sd">                Array of orientations for all pixels.</span>
<span class="sd">            phid : ndarray</span>
<span class="sd">                Array of phase IDs for all pixels.</span>
<span class="sd">            bads : set</span>
<span class="sd">                Set of indices corresponding to pixels that could not be reassigned previously.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            None</span>
<span class="sd">                Modifies `ori` in-place. If no valid neighbor is found, `pix` is added to `bads`.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">phase</span> <span class="o">=</span> <span class="n">phid</span><span class="p">[</span><span class="n">pix</span><span class="p">]</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">pix</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">phid</span><span class="p">[</span><span class="n">pix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">phase</span> <span class="ow">and</span> <span class="n">pix</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bads</span><span class="p">:</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">pix</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">pix</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">npx</span> <span class="ow">and</span> <span class="n">phid</span><span class="p">[</span><span class="n">pix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">phase</span> <span class="ow">and</span> <span class="n">pix</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bads</span><span class="p">:</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">pix</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">pix</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">phid</span><span class="p">[</span><span class="n">pix</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">phase</span> <span class="ow">and</span> <span class="n">pix</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bads</span><span class="p">:</span>
                <span class="n">pix</span> <span class="o">=</span> <span class="n">pix</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span>
            <span class="k">elif</span> <span class="n">pix</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">npx</span> <span class="ow">and</span> <span class="n">phid</span><span class="p">[</span><span class="n">pix</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">phase</span> <span class="ow">and</span> <span class="n">pix</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bads</span><span class="p">:</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">pix</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span>
            <span class="k">if</span> <span class="n">ix</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ori</span><span class="p">[</span><span class="n">pix</span><span class="p">]</span> <span class="o">=</span> <span class="n">ori</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>  <span class="c1"># pixel orientation is reassigned</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bads</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pix</span><span class="p">)</span>  <span class="c1"># no valid neighbor found add pix again to list</span>

        <span class="c1"># interpret parameters</span>
        <span class="k">if</span> <span class="n">plot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">show_plot</span> <span class="o">=</span> <span class="n">plot</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Use of &quot;plot&quot; is depracted, use argument &quot;show_plot&quot; instead.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hist</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">show_hist</span> <span class="o">=</span> <span class="n">hist</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Use of &quot;hist&quot; is depracted, use argument &quot;show_plot&quot; instead.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">show_hist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">show_hist</span> <span class="o">=</span> <span class="n">show_plot</span>
        <span class="n">max_angle</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ms_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># read EBSD map and return the orix object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emap</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># shape of EBSD map in pixels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">dy</span>  <span class="c1"># distance in micron b/w pixels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">size</span>  <span class="c1"># total number of pixels in EBSD map</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_y</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npx</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Size of map (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">npx</span><span class="si">}</span><span class="s2"> px) does not match its shape: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">sh_y</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># determine number of phases and generate histogram</span>
        <span class="n">Nphase</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phases</span><span class="o">.</span><span class="n">ids</span><span class="p">)</span>  <span class="c1"># number of phases</span>
        <span class="n">offs</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phases</span><span class="o">.</span><span class="n">ids</span> <span class="k">else</span> <span class="mi">1</span>  <span class="c1"># in CTX maps, there is no phase &quot;0&quot;</span>
        <span class="n">phist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phase_id</span><span class="p">,</span> <span class="n">Nphase</span> <span class="o">+</span> <span class="n">offs</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Imported EBSD map with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phases</span><span class="o">.</span><span class="n">ids</span><span class="p">)</span><span class="si">}</span><span class="s1"> phases.&#39;</span><span class="p">)</span>

        <span class="c1"># read phase names and calculate volume fractions and plots if active</span>
        <span class="k">for</span> <span class="n">n_ph</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phases</span><span class="o">.</span><span class="n">ids</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ind</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">vf</span> <span class="o">=</span> <span class="n">phist</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">n_ph</span> <span class="o">+</span> <span class="n">offs</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">npx</span>
            <span class="k">if</span> <span class="n">vf</span> <span class="o">&lt;</span> <span class="n">vf_min</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># initialize data dictionary</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;vf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">vf</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phases</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">n_ph</span><span class="p">]</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;len_x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;len_y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_y</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;delta_x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;delta_y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span>

            <span class="c1"># generate phase-specific orientations</span>
            <span class="n">ori_e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phase_id</span> <span class="o">==</span> <span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">orientations</span><span class="o">.</span><span class="n">in_euler_fundamental_region</span><span class="p">()</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ori&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Orientation</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="n">ori_e</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;cs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">point_group</span><span class="o">.</span><span class="n">laue</span>
            <span class="c1"># assign bad pixels to one neighbor</span>
            <span class="c1"># identify non-indexed pixels and pixels with low confidence index (CI)</span>
            <span class="k">if</span> <span class="s1">&#39;ci&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">prop</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">prop</span><span class="p">[</span><span class="s1">&#39;ci&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">npx</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ci_map</span> <span class="o">=</span> <span class="n">val</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ci_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npx</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ci_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phase_id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
                <span class="n">bad_pix</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bad_pix</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad_pix</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">niter</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Initial number of bad pixels: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">bad_pix</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">nbad</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad_pix</span><span class="p">)</span>
                <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad_pix</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">niter</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nbad</span><span class="p">:</span>
                    <span class="n">bp</span> <span class="o">=</span> <span class="n">bad_pix</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">reassign</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ori&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phase_id</span><span class="p">,</span> <span class="n">bad_pix</span><span class="p">)</span>
                    <span class="n">niter</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;After </span><span class="si">{</span><span class="n">niter</span><span class="si">}</span><span class="s1"> loops: number of bad pixels: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">bad_pix</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="c1"># calculate misorientation field</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ori&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">angle</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">npx</span><span class="p">:</span>
                <span class="n">bmap</span> <span class="o">=</span> <span class="n">val</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bmap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npx</span><span class="p">)</span>
                <span class="n">bmap</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phase_id</span> <span class="o">==</span> <span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;mo_map&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bmap</span>

            <span class="c1"># Get IPF colors</span>
            <span class="n">ipf_key</span> <span class="o">=</span> <span class="n">ox_plot</span><span class="o">.</span><span class="n">IPFColorKeyTSL</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;cs&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ori&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">npx</span><span class="p">:</span>
                <span class="n">rgb_val</span> <span class="o">=</span> <span class="n">ipf_key</span><span class="o">.</span><span class="n">orientation2color</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;ori&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rgb_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">npx</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
                <span class="n">rgb_val</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phase_id</span> <span class="o">==</span> <span class="n">ind</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">ipf_key</span><span class="o">.</span><span class="n">orientation2color</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;ori&#39;</span><span class="p">])</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;rgb_im&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">rgb_val</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_y</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

            <span class="c1"># generate map with grain labels</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Identifying regions of homogeneous misorientations and assigning them to grains.&#39;</span><span class="p">)</span>
            <span class="n">labels</span><span class="p">,</span> <span class="n">n_regions</span> <span class="o">=</span> <span class="n">find_similar_regions</span><span class="p">(</span><span class="n">bmap</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_y</span><span class="p">)),</span>
                                                     <span class="n">tolerance</span><span class="o">=</span><span class="n">max_angle</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Phase #</span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">): Identified Grains: </span><span class="si">{</span><span class="n">n_regions</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># build and visualize graph of unfiltered map</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Building microstructure graph.&#39;</span><span class="p">)</span>
            <span class="n">ms_graph</span> <span class="o">=</span> <span class="n">build_graph_from_labeled_pixels</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="p">,</span> <span class="n">n_ph</span><span class="p">)</span>
            <span class="n">ms_graph</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Graph of microstructure&#39;</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Starting to simplify microstructure graph.&#39;</span><span class="p">)</span>

            <span class="c1"># graph pruning step 1: remove grains that have no convex hull</span>
            <span class="c1"># and merge regions with similar misorientation</span>
            <span class="n">grain_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ms_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
            <span class="n">rem_grains</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grain_set</span><span class="p">)</span>
            <span class="k">while</span> <span class="n">rem_grains</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">num</span> <span class="o">=</span> <span class="n">grain_set</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>  <span class="c1"># get random ID of grain and remove it from the list</span>
                <span class="n">nd</span> <span class="o">=</span> <span class="n">ms_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">num</span><span class="p">]</span>  <span class="c1"># node to be considered</span>
                <span class="n">rem_grains</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grain_set</span><span class="p">)</span>
                <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">nd</span><span class="p">[</span><span class="s1">&#39;pixels&#39;</span><span class="p">],</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_y</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                <span class="n">pts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>  <span class="c1"># convert pixel distances to micron</span>
                <span class="n">pts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">hull</span> <span class="o">=</span> <span class="n">ConvexHull</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
                    <span class="n">ms_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">num</span><span class="p">][</span><span class="s1">&#39;hull&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hull</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="c1"># grain has no convex hull</span>
                    <span class="n">num_ln</span> <span class="o">=</span> <span class="n">find_largest_neighbor</span><span class="p">(</span><span class="n">ms_graph</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
                    <span class="n">merge_nodes</span><span class="p">(</span><span class="n">ms_graph</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">num_ln</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="c1"># search for neighbors with similar orientation</span>
                <span class="n">sim_neigh</span><span class="p">,</span> <span class="n">ori_neigh</span> <span class="o">=</span> <span class="n">find_sim_neighbor</span><span class="p">(</span><span class="n">ms_graph</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ori_neigh</span> <span class="o">&lt;=</span> <span class="n">max_angle</span><span class="p">:</span>
                    <span class="n">merge_nodes</span><span class="p">(</span><span class="n">ms_graph</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">sim_neigh</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ngrains</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ms_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;After merging of similar regions, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ngrains</span><span class="si">}</span><span class="s1"> grains left.&#39;</span><span class="p">)</span>

            <span class="c1"># graph pruning step 2: merge small grains into their largest neighbor grain</span>
            <span class="n">grain_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ms_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
            <span class="n">rem_grains</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grain_set</span><span class="p">)</span>
            <span class="k">while</span> <span class="n">rem_grains</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">num</span> <span class="o">=</span> <span class="n">grain_set</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>  <span class="c1"># get random ID of grain and remove it from the list</span>
                <span class="n">rem_grains</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grain_set</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ms_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">num</span><span class="p">][</span><span class="s1">&#39;npix&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">gs_min</span><span class="p">:</span>
                    <span class="n">num_ln</span> <span class="o">=</span> <span class="n">find_largest_neighbor</span><span class="p">(</span><span class="n">ms_graph</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
                    <span class="n">merge_nodes</span><span class="p">(</span><span class="n">ms_graph</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">num_ln</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ngrains</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ms_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ngrains&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ngrains</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;After elimination of small grains, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ngrains</span><span class="si">}</span><span class="s1"> grains left.&#39;</span><span class="p">)</span>

            <span class="c1"># Extract grain statistics and axes</span>
            <span class="n">arr_a</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">arr_b</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">arr_eqd</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">arr_om</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">ms_graph</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">hull</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;hull&#39;</span><span class="p">]</span>
                <span class="n">eqd</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">hull</span><span class="o">.</span><span class="n">volume</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>  <span class="c1"># area of convex hull approximates grain better than pixels</span>
                <span class="n">pts</span> <span class="o">=</span> <span class="n">hull</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">hull</span><span class="o">.</span><span class="n">vertices</span><span class="p">]</span>  <span class="c1"># outer nodes of grain</span>
                <span class="c1"># analyze geometry of point cloud</span>
                <span class="n">ea</span><span class="p">,</span> <span class="n">eb</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">vb</span> <span class="o">=</span> <span class="n">get_grain_geom</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;ellipsis&#39;</span><span class="p">,</span> <span class="n">two_dim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># std: &#39;ellipsis&#39;, failsafe: &#39;raw&#39;</span>
                <span class="c1"># assert ea &gt;= eb</span>
                <span class="k">if</span> <span class="n">eb</span> <span class="o">&lt;</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="n">ea</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Grain </span><span class="si">{</span><span class="n">num</span><span class="si">}</span><span class="s1"> has too high aspect ratio: main axes: </span><span class="si">{</span><span class="n">ea</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">eb</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">eb</span> <span class="o">=</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="n">ea</span>
                <span class="n">sc_fct</span> <span class="o">=</span> <span class="n">eqd</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ea</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">eb</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># rescale axes of ellipsis to ensure consistency with eqd</span>
                <span class="n">ea</span> <span class="o">*=</span> <span class="n">sc_fct</span>
                <span class="n">eb</span> <span class="o">*=</span> <span class="n">sc_fct</span>
                <span class="c1"># assert np.dot(va, vb) &lt; 1.e-9</span>
                <span class="c1"># assert np.isclose(np.linalg.norm(va), 1.0)</span>
                <span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">va</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># angle of major axis against y-axis of map in range [0, pi]</span>
                <span class="n">node</span><span class="p">[</span><span class="s1">&#39;max_dia&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ea</span>
                <span class="n">node</span><span class="p">[</span><span class="s1">&#39;min_dia&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">eb</span>
                <span class="n">node</span><span class="p">[</span><span class="s1">&#39;equ_dia&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">eqd</span>
                <span class="n">node</span><span class="p">[</span><span class="s1">&#39;maj_ax&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">va</span>
                <span class="n">node</span><span class="p">[</span><span class="s1">&#39;min_ax&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">vb</span>
                <span class="n">node</span><span class="p">[</span><span class="s1">&#39;omega&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">omega</span>
                <span class="n">node</span><span class="p">[</span><span class="s1">&#39;center&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hull</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">arr_a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ea</span><span class="p">)</span>
                <span class="n">arr_b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eb</span><span class="p">)</span>
                <span class="n">arr_eqd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eqd</span><span class="p">)</span>
                <span class="n">arr_om</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span>
            <span class="n">arr_om</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr_om</span><span class="p">)</span>
            <span class="n">arr_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr_a</span><span class="p">)</span>
            <span class="n">arr_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr_b</span><span class="p">)</span>
            <span class="n">arr_eqd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr_eqd</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">--------------------------------------------------------&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Statistical microstructure parameters in pixel map &#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;--------------------------------------------------------&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">arr_a</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">arr_a</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">arr_b</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">arr_b</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">arr_eqd</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">arr_eqd</span><span class="p">))</span>

            <span class="c1"># calculate equivalent diameters</span>
            <span class="n">doffs</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">deq_log</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">arr_eqd</span><span class="p">)</span>
            <span class="n">dscale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">deq_log</span><span class="p">))</span>
            <span class="n">dsig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">deq_log</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;gs_param&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dsig</span><span class="p">,</span> <span class="n">doffs</span><span class="p">,</span> <span class="n">dscale</span><span class="p">])</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;gs_data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr_eqd</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;gs_moments&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">dscale</span><span class="p">,</span> <span class="n">dsig</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">show_hist</span><span class="p">:</span>
                <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
                <span class="n">hc</span><span class="p">,</span> <span class="n">hb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">arr_eqd</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
                <span class="n">x0</span> <span class="o">=</span> <span class="n">hb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">hc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># find first bin with count == 1</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">x1</span> <span class="o">=</span> <span class="n">hb</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">x1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">arr_eqd</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="mi">150</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dsig</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">doffs</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">dscale</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;-r&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;lognorm fit&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">arr_eqd</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">),</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Histogram of grain equivalent diameters&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Equivalent diameter (micron)&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Normalized frequency&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

            <span class="c1"># grain aspect ratio</span>
            <span class="n">asp</span> <span class="o">=</span> <span class="n">arr_a</span> <span class="o">/</span> <span class="n">arr_b</span>
            <span class="n">aoffs</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">asp_log</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">asp</span><span class="p">)</span>
            <span class="n">ascale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">asp_log</span><span class="p">))</span>  <span class="c1"># lognorm.median(asig, loc=aoffs, scale=ascale)</span>
            <span class="n">asig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">asp_log</span><span class="p">)</span>  <span class="c1"># lognorm.std(asig, loc=aoffs, scale=ascale)</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ar_param&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">asig</span><span class="p">,</span> <span class="n">aoffs</span><span class="p">,</span> <span class="n">ascale</span><span class="p">])</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ar_data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">asp</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ar_moments&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">ascale</span><span class="p">,</span> <span class="n">asig</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">show_hist</span><span class="p">:</span>
                <span class="c1"># plot distribution of aspect ratios</span>
                <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
                <span class="n">hc</span><span class="p">,</span> <span class="n">hb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">asp</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
                <span class="n">x0</span> <span class="o">=</span> <span class="n">hb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">hc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># find first bin with count == 1</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">x1</span> <span class="o">=</span> <span class="n">hb</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">x1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">asp</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="mi">150</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">asig</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">aoffs</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">ascale</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;-r&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;lognorm fit&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">asp</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="nb">range</span> <span class="o">=</span> <span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">),</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Histogram of grain aspect ratio&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;aspect ratio&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;normalized frequency&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

            <span class="c1"># angles of main axis</span>
            <span class="c1"># fit von Mises distribution (circular normal distribution) to data</span>
            <span class="n">kappa</span><span class="p">,</span> <span class="n">oloc</span><span class="p">,</span> <span class="n">oscale</span> <span class="o">=</span> <span class="n">vonmises</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">arr_om</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
            <span class="n">med_om</span> <span class="o">=</span> <span class="n">vonmises</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">kappa</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">oloc</span><span class="p">)</span>  <span class="c1"># scale parameter has no effect on vonmises distribution</span>
            <span class="n">std_om</span> <span class="o">=</span> <span class="n">vonmises</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">kappa</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">oloc</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;om_param&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">kappa</span><span class="p">,</span> <span class="n">oloc</span><span class="p">])</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;om_data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr_om</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;om_moments&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">med_om</span><span class="p">,</span> <span class="n">std_om</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">show_hist</span><span class="p">:</span>
                <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>  <span class="c1"># np.amin(omega), np.amax(omega), 150)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">vonmises</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">kappa</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">oloc</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;-r&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;von Mises fit&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">arr_om</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Histogram of tilt angles of major axes&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;angle (rad)&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;normalized frequency&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Analyzed microstructure of phase #</span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">) with </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ngrains</span><span class="si">}</span><span class="s2"> grains.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Median values: equiv. diameter: </span><span class="si">{</span><span class="n">dscale</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="si">}</span><span class="s1"> micron, &#39;</span> <span class="o">+</span>
                  <span class="sa">f</span><span class="s1">&#39;aspect ratio: </span><span class="si">{</span><span class="n">ascale</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="si">}</span><span class="s1">, &#39;</span> <span class="o">+</span>
                  <span class="sa">f</span><span class="s1">&#39;tilt angle: </span><span class="si">{</span><span class="p">(</span><span class="n">med_om</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">180</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="si">}</span><span class="s1">°&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Std. dev: equivalent diameter: </span><span class="si">{</span><span class="n">dsig</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="si">}</span><span class="s1"> micron, &#39;</span> <span class="o">+</span>
                  <span class="sa">f</span><span class="s1">&#39;aspect ratio: </span><span class="si">{</span><span class="n">asig</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="si">}</span><span class="s1">, &#39;</span> <span class="o">+</span>
                  <span class="sa">f</span><span class="s1">&#39;tilt angle: </span><span class="si">{</span><span class="p">(</span><span class="n">std_om</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">180</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="si">}</span><span class="s1">°&#39;</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;graph&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ms_graph</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ms_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">show_plot</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_mo_map</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_ipf_map</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_segmentation</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_pf</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">show_grains</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_grains</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">felzenszwalb</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_felsenszwalb</span><span class="p">()</span>
        <span class="k">return</span>

<div class="viewcode-block" id="EBSDmap.calcORI">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.EBSDmap.calcORI">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calcORI</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Ng</span><span class="p">,</span> <span class="n">iphase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">shared_area</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nbins</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span>
                <span class="n">res_low</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">res_high</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">res_step</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">lim</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate optimum kernel half-width and produce reduced set of</span>
<span class="sd">        orientations for given number of grains</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Ng : int</span>
<span class="sd">            Numbr of grains for which orientation is requested.</span>
<span class="sd">        iphase : int, optional</span>
<span class="sd">            Phase for which data is requested. The default is 0.</span>
<span class="sd">        shared_area : array, optional</span>
<span class="sd">            Grain boundary data. The default is None.</span>
<span class="sd">        nbins : int, optional</span>
<span class="sd">            number of bins for GB texture. The default is 12.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ori : (Ng, 3)-array</span>
<span class="sd">            Array with Ng Euler angles.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms_data</span><span class="p">[</span><span class="n">iphase</span><span class="p">]</span>
        <span class="n">orired</span><span class="p">,</span> <span class="n">odfred</span><span class="p">,</span> <span class="n">ero</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="n">texture_reconstruction</span><span class="p">(</span><span class="n">Ng</span><span class="p">,</span> <span class="n">orientations</span><span class="o">=</span><span class="n">ms</span><span class="p">[</span><span class="s1">&#39;ori&#39;</span><span class="p">],</span>
                                                          <span class="n">res_low</span><span class="o">=</span><span class="n">res_low</span><span class="p">,</span> <span class="n">res_high</span><span class="o">=</span><span class="n">res_high</span><span class="p">,</span>
                                                          <span class="n">res_step</span><span class="o">=</span><span class="n">res_step</span><span class="p">,</span> <span class="n">lim</span><span class="o">=</span><span class="n">lim</span><span class="p">,</span>
                                                          <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">shared_area</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">full_output</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">orired</span><span class="p">,</span> <span class="n">odfred</span><span class="p">,</span> <span class="n">ero</span><span class="p">,</span> <span class="n">res</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">orired</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span><span class="s1">&#39;Shared area is not implemented yet in pure Python version.</span><span class="se">\n</span><span class="s1">&#39;</span>
                                      <span class="s1">&#39;Use kanapy-mtex for this option.&#39;</span><span class="p">)</span></div>

            <span class="c1">#orilist, ein, eout, mbin = \</span>
            <span class="c1">#    self.eng.gb_textureReconstruction(ms[&#39;grains&#39;], orired,</span>
            <span class="c1">#                                      matlab.double(shared_area), nbins, nargout=4)</span>
            <span class="c1">#return np.array(self.eng.Euler(orilist))</span>

<div class="viewcode-block" id="EBSDmap.showIPF">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.EBSDmap.showIPF">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">showIPF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the inverse pole figure (IPF) color key for all phases in the EBSD map</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phases</span><span class="o">.</span><span class="n">ids</span><span class="p">:</span>
            <span class="n">pg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">point_group</span><span class="o">.</span><span class="n">laue</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
            <span class="n">ax0</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s2">&quot;ipf&quot;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="n">pg</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">ax0</span><span class="o">.</span><span class="n">plot_ipf_color_key</span><span class="p">(</span><span class="n">show_title</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">ax0</span><span class="o">.</span><span class="n">patch</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s2">&quot;None&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="EBSDmap.plot_ci_map">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.EBSDmap.plot_ci_map">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_ci_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the confidence index (CI) map of the EBSD data if available</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;ci&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">prop</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ci_map</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_y</span><span class="p">)))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;CI values in EBSD map&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;CI&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="EBSDmap.plot_pf">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.EBSDmap.plot_pf">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_pf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot pole figures for all phases using the specified sample direction</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vector : array-like, optional</span>
<span class="sd">            Sample reference vector for the pole figure. Default is [0, 0, 1].</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Plots &lt;111&gt; poles in the sample reference frame for each phase.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># plot inverse pole figure</span>
        <span class="c1"># &lt;111&gt; poles in the sample reference frame</span>
        <span class="k">if</span> <span class="n">vector</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vector</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">pids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phases</span><span class="o">.</span><span class="n">ids</span><span class="p">)</span>
        <span class="n">pids</span> <span class="o">=</span> <span class="n">pids</span><span class="p">[</span><span class="n">pids</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">n_ph</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ms_data</span><span class="p">):</span>
            <span class="n">orientations</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ori&#39;</span><span class="p">]</span>
            <span class="n">plot_pole_figure</span><span class="p">(</span><span class="n">orientations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">pids</span><span class="p">[</span><span class="n">n_ph</span><span class="p">]],</span> <span class="n">vector</span><span class="o">=</span><span class="n">vector</span><span class="p">)</span></div>

            <span class="c1">#t_ = Miller(uvw=vector, phase=self.emap.phases[ind]).symmetrise(unique=True)</span>
            <span class="c1">#t_all = orientations.inv().outer(t_)</span>
            <span class="c1">#fig = plt.figure(figsize=(8, 8))</span>
            <span class="c1">#ax = fig.add_subplot(111, projection=&quot;stereographic&quot;)</span>
            <span class="c1">#ax.scatter(t_all)</span>
            <span class="c1">#ax.set_labels(&quot;X&quot;, &quot;Y&quot;, None)</span>
            <span class="c1">#ax.set_title(data[&#39;name&#39;] + r&quot; $\left&lt;001\right&gt;$ PF&quot;)</span>
            <span class="c1">#plt.show()</span>

<div class="viewcode-block" id="EBSDmap.plot_pf_proj">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.EBSDmap.plot_pf_proj">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_pf_proj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot projected pole figures for all phases using the specified sample direction</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vector : array-like, optional</span>
<span class="sd">            Sample reference vector for the projected pole figure. Default is [0, 0, 1].</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Uses a projection method to visualize &lt;111&gt; poles in the sample reference frame.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># plot inverse pole figure</span>
        <span class="c1"># &lt;111&gt; poles in the sample reference frame</span>
        <span class="k">if</span> <span class="n">vector</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vector</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">pids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phases</span><span class="o">.</span><span class="n">ids</span><span class="p">)</span>
        <span class="n">pids</span> <span class="o">=</span> <span class="n">pids</span><span class="p">[</span><span class="n">pids</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">n_ph</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ms_data</span><span class="p">):</span>
            <span class="n">orientations</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ori&#39;</span><span class="p">]</span>
            <span class="n">plot_pole_figure_proj</span><span class="p">(</span><span class="n">orientations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">pids</span><span class="p">[</span><span class="n">n_ph</span><span class="p">]],</span> <span class="n">vector</span><span class="o">=</span><span class="n">vector</span><span class="p">)</span></div>


<div class="viewcode-block" id="EBSDmap.plot_grains_marked">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.EBSDmap.plot_grains_marked">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_grains_marked</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot grains with labels and major/minor axes for all phases</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Each grain is annotated with its number. Major axes are plotted in black,</span>
<span class="sd">        minor axes in red. The plot uses a distinct colormap for different grains.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># plot grain with numbers and axes</span>
        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms_data</span><span class="p">:</span>
            <span class="n">ngr</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ngrains&#39;</span><span class="p">]</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">get_distinct_colormap</span><span class="p">(</span><span class="n">ngr</span><span class="p">)</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">LinearSegmentedColormap</span><span class="o">.</span><span class="n">from_list</span><span class="p">(</span><span class="s1">&#39;segs&#39;</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">ngr</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;graph&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;label_map&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">ngr</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;graph&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">ctr</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;graph&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">num</span><span class="p">][</span><span class="s1">&#39;center&#39;</span><span class="p">]</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">num</span><span class="p">),</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">ctr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ctr</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
                <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;center&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;max_dia&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;maj_ax&#39;</span><span class="p">]</span>
                <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;center&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;max_dia&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;maj_ax&#39;</span><span class="p">]</span>
                <span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;center&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;min_dia&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;min_ax&#39;</span><span class="p">]</span>
                <span class="n">pts</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;center&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;min_dia&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;min_ax&#39;</span><span class="p">]</span>
                <span class="n">pts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
                <span class="n">pts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Phase #</span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">): Grain labels and axes: </span><span class="si">{</span><span class="n">ngr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;Grain Number&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="EBSDmap.plot_mo_map">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.EBSDmap.plot_mo_map">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_mo_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the misorientation map for all phases</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Shows the misorientation angle of each pixel with respect to a reference orientation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms_data</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;mo_map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_y</span><span class="p">)))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Phase #</span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">): Misorientation angle wrt reference&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Misorientation (rad)&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="EBSDmap.plot_segmentation">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.EBSDmap.plot_segmentation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_segmentation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">show_mo</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">show_ipf</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot segmentation results for all phases</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        show_mo : bool, optional</span>
<span class="sd">            If True, overlay grain boundaries on the misorientation map. Default is True.</span>
<span class="sd">        show_ipf : bool, optional</span>
<span class="sd">            If True, overlay grain boundaries on the IPF map. Default is True.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Uses similarity-based segmentation to highlight grain boundaries on the maps.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># plot segmentation results</span>
        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms_data</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">show_mo</span><span class="p">:</span>
                <span class="n">gscale_map</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;mo_map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_y</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">mark_boundaries</span><span class="p">(</span><span class="n">gscale_map</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;graph&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;label_map&#39;</span><span class="p">]))</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Phase #</span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">): Misorientation map with similarity segmentation&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">show_ipf</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">mark_boundaries</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;rgb_im&#39;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;graph&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;label_map&#39;</span><span class="p">]))</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Phase #</span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">): IPF map with similarity segmentation&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="EBSDmap.plot_felsenszwalb">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.EBSDmap.plot_felsenszwalb">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_felsenszwalb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply Felzenszwalb segmentation to the misorientation map and plot the results</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Segments the misorientation map using the Felzenszwalb algorithm and overlays</span>
<span class="sd">        the segment boundaries for visualization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">skimage.segmentation</span><span class="w"> </span><span class="kn">import</span> <span class="n">felzenszwalb</span>
        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms_data</span><span class="p">:</span>
            <span class="n">gscale_map</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;mo_map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_y</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="n">labels_fz</span> <span class="o">=</span> <span class="n">felzenszwalb</span><span class="p">(</span><span class="n">gscale_map</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span> <span class="n">min_size</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>  <span class="c1"># sc=300, sig=0.8, min_s=25</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">mark_boundaries</span><span class="p">(</span><span class="n">gscale_map</span><span class="p">,</span> <span class="n">labels_fz</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Phase #</span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">): Misorientation map with Felzenszwalb segmentation&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="EBSDmap.plot_graph">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.EBSDmap.plot_graph">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Visualize the microstructure graph for all phases</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Uses the `visualize_graph` function to display nodes and connections of each phase&#39;s graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># visualize graph</span>
        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms_data</span><span class="p">:</span>
            <span class="n">visualize_graph</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;graph&#39;</span><span class="p">])</span></div>


<div class="viewcode-block" id="EBSDmap.plot_ipf_map">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.EBSDmap.plot_ipf_map">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_ipf_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the IPF (inverse pole figure) map for all phases</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Pixels belonging to other phases are set to black. Each phase is visualized separately.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># plot EBSD maps for all phase</span>
        <span class="c1"># set pixels of other phases to black</span>
        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms_data</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emap</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                <span class="n">data</span><span class="p">[</span><span class="s1">&#39;rgb_im&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npx</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                <span class="n">return_figure</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">figure_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;figsize&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">)},</span>
            <span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="EBSDmap.plot_grains">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.EBSDmap.plot_grains">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_grains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the N largest grains with one-hot maps, convex hulls, and principal axes</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        N : int, optional</span>
<span class="sd">            Number of largest grains to plot for each phase. Default is 5.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Each grain is visualized with its pixels, convex hull, and major/minor axes.</span>
<span class="sd">        Major axes are plotted in cyan, minor axes in green.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># select N largest gains and create a one-hot-plot for each grain</span>
        <span class="c1"># showing its pixels, the vertices of the convex hull and the convex hull itself</span>
        <span class="c1"># together with the principal axes of the grain</span>
        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms_data</span><span class="p">:</span>
            <span class="n">glist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">slist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;graph&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">hs</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;equ_dia&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">hs</span> <span class="o">&gt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">slist</span><span class="p">):</span>
                    <span class="n">glist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
                    <span class="n">slist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hs</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">glist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">N</span><span class="p">:</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">slist</span><span class="p">)</span>
                        <span class="n">glist</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                        <span class="n">slist</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">glist</span><span class="p">:</span>
                <span class="n">pix_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;graph&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">num</span><span class="p">][</span><span class="s1">&#39;pixels&#39;</span><span class="p">],</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_y</span><span class="p">))</span>
                <span class="n">oh_grain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">sh_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_y</span><span class="p">))</span>
                <span class="n">oh_grain</span><span class="p">[</span><span class="n">pix_c</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.3</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;graph&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">num</span><span class="p">]</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;hull&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">vertices</span>
                <span class="n">oh_grain</span><span class="p">[</span><span class="n">pix_c</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ind</span><span class="p">],</span> <span class="n">pix_c</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">ind</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">oh_grain</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
                <span class="c1"># add convex hull</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">ix</span> <span class="o">=</span> <span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ind</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pix_c</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">ix</span><span class="p">],</span> <span class="n">pix_c</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ix</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pix_c</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">ix</span><span class="p">],</span> <span class="n">pix_c</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ix</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
                <span class="c1"># add axes</span>
                <span class="n">ctr</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;center&#39;</span><span class="p">]</span>
                <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
                <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">ctr</span> <span class="o">-</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;max_dia&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;maj_ax&#39;</span><span class="p">]</span>
                <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">ctr</span> <span class="o">+</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;max_dia&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;maj_ax&#39;</span><span class="p">]</span>
                <span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">ctr</span> <span class="o">-</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;min_dia&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;min_ax&#39;</span><span class="p">]</span>
                <span class="n">pts</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">ctr</span> <span class="o">+</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;min_dia&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;min_ax&#39;</span><span class="p">]</span>
                <span class="n">pts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
                <span class="n">pts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;cyan&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Phase #</span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">): Grain #</span><span class="si">{</span><span class="n">num</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="get_ipf_colors">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.get_ipf_colors">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_ipf_colors</span><span class="p">(</span><span class="n">ori_list</span><span class="p">,</span> <span class="n">color_key</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get RGB colors for a list of orientations in radians</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ori_list : (N, 3) ndarray</span>
<span class="sd">        List of N Euler angles in radians</span>

<span class="sd">    color_key : int, optional</span>
<span class="sd">        Index of the IPF color key to use. Default is 0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    colors : (N, 3) ndarray</span>
<span class="sd">        RGB values corresponding to each orientation</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Assumes cubic crystal symmetry and cubic specimen symmetry</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># get colors</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ori_list</span><span class="p">,</span> <span class="n">Orientation</span><span class="p">):</span>
        <span class="n">ori_list</span> <span class="o">=</span> <span class="n">Orientation</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="n">ori_list</span><span class="p">)</span>
    <span class="n">ckey</span> <span class="o">=</span> <span class="n">ox_plot</span><span class="o">.</span><span class="n">IPFColorKeyTSL</span><span class="p">(</span><span class="n">ori_list</span><span class="o">.</span><span class="n">symmetry</span><span class="p">)</span>
    <span class="n">ocol</span> <span class="o">=</span> <span class="n">ckey</span><span class="o">.</span><span class="n">orientation2color</span><span class="p">(</span><span class="n">ori_list</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ocol</span></div>



<div class="viewcode-block" id="createOriset">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.createOriset">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">createOriset</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">ang</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">hist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shared_area</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">cs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">Nbase</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">res_low</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">res_high</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">res_step</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">lim</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a set of Euler angles according to an ODF defined by input orientations and kernel half-width</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    num : int</span>
<span class="sd">        Number of Euler angles to generate</span>
<span class="sd">    ang : (3,) or (M, 3) array or Orientation</span>
<span class="sd">        Input set of Euler angles (in degrees or radians) defining the ODF</span>
<span class="sd">    omega : float</span>
<span class="sd">        Kernel half-width (in degrees or radians)</span>
<span class="sd">    hist : array, optional</span>
<span class="sd">        Histogram of MDF. Default is None</span>
<span class="sd">    shared_area : array, optional</span>
<span class="sd">        Shared area between pairs of grains. Default is None</span>
<span class="sd">    cs : Symmetry, optional</span>
<span class="sd">        Crystal symmetry group. Default is &#39;m3m&#39;</span>
<span class="sd">    degree : bool, optional</span>
<span class="sd">        If True, input angles and omega are in degrees. Default is True</span>
<span class="sd">    Nbase : int, optional</span>
<span class="sd">        Base number of orientations for artificial ODF. Default is 10000</span>
<span class="sd">    resolution : float, optional</span>
<span class="sd">        Resolution for orientation generation. If None, derived from omega</span>
<span class="sd">    res_low, res_high, res_step, lim : int, optional</span>
<span class="sd">        Parameters for texture reconstruction</span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        If True, prints progress messages. Default is False</span>
<span class="sd">    full_output : bool, optional</span>
<span class="sd">        If True, returns additional reconstruction outputs. Default is False</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ori : (num, 3) ndarray</span>
<span class="sd">        Reduced set of Euler angles</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Can generate artificial ODFs if input set is small. Grain-boundary-texture</span>
<span class="sd">    reconstruction with hist or shared_area requires the kanapy-mtex module.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># prepare parameters</span>
    <span class="k">if</span> <span class="n">hist</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">shared_area</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span><span class="s1">&#39;The grain-boundary-texture module is currently only available in kanapy-mtex.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">Symmetry</span><span class="p">):</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Crystal Symmetry &quot;cs&quot; must be provided as Symmetry object.&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">cs</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">resolution</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">degree</span><span class="p">:</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="n">omega</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span>  <span class="c1"># resolution must be given in degrees</span>
    <span class="k">if</span> <span class="n">degree</span><span class="p">:</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ang</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">degree</span><span class="p">:</span>
            <span class="n">ang</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">ang</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ang</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ang</span><span class="p">)</span>
        <span class="n">ang</span> <span class="o">=</span> <span class="n">Orientation</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="n">ang</span><span class="p">,</span> <span class="n">cs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ang</span><span class="p">,</span> <span class="n">Orientation</span><span class="p">)</span>    
    <span class="c1"># psi = DeLaValleePoussinKernel(halfwidth=omega)</span>
    <span class="k">if</span> <span class="n">ang</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">Nbase</span><span class="o">/</span><span class="mi">100</span><span class="p">:</span>
        <span class="c1"># create artificial ODF for monomodal texture or small orientation set</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Creating artificial ODF centered around orientation </span><span class="si">{</span><span class="n">ang</span><span class="si">}</span><span class="s1"> with &#39;</span>
                         <span class="sa">f</span><span class="s1">&#39;kernel halfwidth: </span><span class="si">{</span><span class="n">omega</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">odf</span> <span class="o">=</span> <span class="n">ODF</span><span class="p">(</span><span class="n">ang</span><span class="p">,</span> <span class="n">halfwidth</span><span class="o">=</span><span class="n">omega</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Creating </span><span class="si">{</span><span class="n">Nbase</span><span class="si">}</span><span class="s1"> orientation from artificial ODF.&#39;</span><span class="p">)</span>
        <span class="n">ori</span> <span class="o">=</span> <span class="n">calc_orientations</span><span class="p">(</span><span class="n">odf</span><span class="p">,</span> <span class="n">Nbase</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="n">resolution</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">ori</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">Nbase</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ori</span> <span class="o">=</span> <span class="n">ang</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Texture reconstruction generating </span><span class="si">{</span><span class="n">num</span><span class="si">}</span><span class="s1"> orientations from </span><span class="si">{</span><span class="n">ori</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s1"> inputs.&#39;</span>
                 <span class="sa">f</span><span class="s1">&#39;Kernel halfwidth: </span><span class="si">{</span><span class="n">omega</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">ori_red</span><span class="p">,</span> <span class="n">odfred</span><span class="p">,</span> <span class="n">ero</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="n">texture_reconstruction</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">orientations</span><span class="o">=</span><span class="n">ori</span><span class="p">,</span>
                                                   <span class="n">kernel_halfwidth</span><span class="o">=</span><span class="n">omega</span><span class="p">,</span>
                                                   <span class="n">res_low</span><span class="o">=</span><span class="n">res_low</span><span class="p">,</span> <span class="n">res_high</span><span class="o">=</span><span class="n">res_high</span><span class="p">,</span>
                                                   <span class="n">res_step</span><span class="o">=</span><span class="n">res_step</span><span class="p">,</span> <span class="n">lim</span><span class="o">=</span><span class="n">lim</span><span class="p">,</span>
                                                   <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">hist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">full_output</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ori_red</span><span class="p">,</span> <span class="n">odfred</span><span class="p">,</span> <span class="n">ero</span><span class="p">,</span> <span class="n">res</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ori_red</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span></div>

        <span class="c1">#if shared_area is None:</span>
        <span class="c1">#    raise ValueError(&#39;Microstructure.shared_area must be provided if hist is given.&#39;)</span>
        <span class="c1">#orilist, ein, eout, mbin = \</span>
        <span class="c1">#    eng.gb_textureReconstruction(matlab.double(hist), ori,</span>
        <span class="c1">#                                 matlab.double(shared_area), len(hist), nargout=4)</span>
        <span class="c1">#return np.array(eng.Euler(orilist))</span>


<div class="viewcode-block" id="createOrisetRandom">
<a class="viewcode-back" href="../../kanapy.html#kanapy.texture.createOrisetRandom">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">createOrisetRandom</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">omega</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shared_area</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Nbase</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a set of Euler angles for a random texture</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    num : int</span>
<span class="sd">        Number of Euler angles to generate</span>
<span class="sd">    omega : float, optional</span>
<span class="sd">        Kernel half-width in degrees. Default is 7.5</span>
<span class="sd">    hist : array, optional</span>
<span class="sd">        Histogram of MDF. Default is None</span>
<span class="sd">    shared_area : array, optional</span>
<span class="sd">        Shared area between pairs of grains. Default is None</span>
<span class="sd">    cs : Symmetry, optional</span>
<span class="sd">        Crystal symmetry group. Default is &#39;m3m&#39;</span>
<span class="sd">    Nbase : int, optional</span>
<span class="sd">        Base number of orientations for random texture. Default is 5000</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ori : (num, 3) ndarray</span>
<span class="sd">        Set of randomly distributed Euler angles</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Unlike `createOriset`, this function directly generates `num` random orientations</span>
<span class="sd">    without reducing a larger artificial EBSD set. Grain-boundary-texture reconstruction</span>
<span class="sd">    using `hist` or `shared_area` requires the kanapy-mtex module.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">hist</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">shared_area</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span><span class="s1">&#39;The grain-boundary-texture module is currently only available in kanapy-mtex.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">Symmetry</span><span class="p">):</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Crystal Symmetry &quot;cs&quot; must be provided as Symmetry object.&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">cs</span><span class="p">))</span>

    <span class="n">ori</span> <span class="o">=</span> <span class="n">Orientation</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">cs</span><span class="p">)</span><span class="o">.</span><span class="n">in_euler_fundamental_region</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">hist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ori</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span></div>

    <span class="c1"># ori = eng.project2FundamentalRegion(ori)</span>
    <span class="c1">#    if shared_area is None:</span>
    <span class="c1">#        raise ValueError(&#39;Shared grain boundary area (geometry[&quot;GBarea&quot;]) must be provided if hist is given.&#39;)</span>
    <span class="c1">#    orilist, ein, eout, mbin = \</span>
    <span class="c1">#        eng.gb_textureReconstruction(matlab.double(hist), ori,</span>
    <span class="c1">#                                     matlab.double(shared_area), len(hist), nargout=4)</span>
    <span class="c1">#    return np.array(eng.Euler(orilist))</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright This work is published under a CC BY-SA 4.0 license.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>